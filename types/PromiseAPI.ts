import { ResponseContext, RequestContext, HttpFile } from '../http/http';
import * as models from '../models/all';
import { Configuration} from '../configuration'

import { AaaAbstractAuditRecord } from '../models/AaaAbstractAuditRecord';
import { AaaAbstractAuditRecordAllOf } from '../models/AaaAbstractAuditRecordAllOf';
import { AaaAuditRecord } from '../models/AaaAuditRecord';
import { AaaAuditRecordAllOf } from '../models/AaaAuditRecordAllOf';
import { AaaAuditRecordList } from '../models/AaaAuditRecordList';
import { AaaAuditRecordListAllOf } from '../models/AaaAuditRecordListAllOf';
import { AaaAuditRecordResponse } from '../models/AaaAuditRecordResponse';
import { AdapterAdapterConfig } from '../models/AdapterAdapterConfig';
import { AdapterAdapterConfigAllOf } from '../models/AdapterAdapterConfigAllOf';
import { AdapterConfigPolicy } from '../models/AdapterConfigPolicy';
import { AdapterConfigPolicyAllOf } from '../models/AdapterConfigPolicyAllOf';
import { AdapterConfigPolicyList } from '../models/AdapterConfigPolicyList';
import { AdapterConfigPolicyListAllOf } from '../models/AdapterConfigPolicyListAllOf';
import { AdapterConfigPolicyResponse } from '../models/AdapterConfigPolicyResponse';
import { AdapterDceInterfaceSettings } from '../models/AdapterDceInterfaceSettings';
import { AdapterDceInterfaceSettingsAllOf } from '../models/AdapterDceInterfaceSettingsAllOf';
import { AdapterEthSettings } from '../models/AdapterEthSettings';
import { AdapterEthSettingsAllOf } from '../models/AdapterEthSettingsAllOf';
import { AdapterExtEthInterface } from '../models/AdapterExtEthInterface';
import { AdapterExtEthInterfaceAllOf } from '../models/AdapterExtEthInterfaceAllOf';
import { AdapterExtEthInterfaceList } from '../models/AdapterExtEthInterfaceList';
import { AdapterExtEthInterfaceListAllOf } from '../models/AdapterExtEthInterfaceListAllOf';
import { AdapterExtEthInterfaceRelationship } from '../models/AdapterExtEthInterfaceRelationship';
import { AdapterExtEthInterfaceResponse } from '../models/AdapterExtEthInterfaceResponse';
import { AdapterFcSettings } from '../models/AdapterFcSettings';
import { AdapterFcSettingsAllOf } from '../models/AdapterFcSettingsAllOf';
import { AdapterHostEthInterface } from '../models/AdapterHostEthInterface';
import { AdapterHostEthInterfaceAllOf } from '../models/AdapterHostEthInterfaceAllOf';
import { AdapterHostEthInterfaceList } from '../models/AdapterHostEthInterfaceList';
import { AdapterHostEthInterfaceListAllOf } from '../models/AdapterHostEthInterfaceListAllOf';
import { AdapterHostEthInterfaceRelationship } from '../models/AdapterHostEthInterfaceRelationship';
import { AdapterHostEthInterfaceResponse } from '../models/AdapterHostEthInterfaceResponse';
import { AdapterHostFcInterface } from '../models/AdapterHostFcInterface';
import { AdapterHostFcInterfaceAllOf } from '../models/AdapterHostFcInterfaceAllOf';
import { AdapterHostFcInterfaceList } from '../models/AdapterHostFcInterfaceList';
import { AdapterHostFcInterfaceListAllOf } from '../models/AdapterHostFcInterfaceListAllOf';
import { AdapterHostFcInterfaceRelationship } from '../models/AdapterHostFcInterfaceRelationship';
import { AdapterHostFcInterfaceResponse } from '../models/AdapterHostFcInterfaceResponse';
import { AdapterHostIscsiInterface } from '../models/AdapterHostIscsiInterface';
import { AdapterHostIscsiInterfaceAllOf } from '../models/AdapterHostIscsiInterfaceAllOf';
import { AdapterHostIscsiInterfaceList } from '../models/AdapterHostIscsiInterfaceList';
import { AdapterHostIscsiInterfaceListAllOf } from '../models/AdapterHostIscsiInterfaceListAllOf';
import { AdapterHostIscsiInterfaceRelationship } from '../models/AdapterHostIscsiInterfaceRelationship';
import { AdapterHostIscsiInterfaceResponse } from '../models/AdapterHostIscsiInterfaceResponse';
import { AdapterPortChannelSettings } from '../models/AdapterPortChannelSettings';
import { AdapterPortChannelSettingsAllOf } from '../models/AdapterPortChannelSettingsAllOf';
import { AdapterUnit } from '../models/AdapterUnit';
import { AdapterUnitAllOf } from '../models/AdapterUnitAllOf';
import { AdapterUnitList } from '../models/AdapterUnitList';
import { AdapterUnitListAllOf } from '../models/AdapterUnitListAllOf';
import { AdapterUnitRelationship } from '../models/AdapterUnitRelationship';
import { AdapterUnitResponse } from '../models/AdapterUnitResponse';
import { ApplianceBackup } from '../models/ApplianceBackup';
import { ApplianceBackupAllOf } from '../models/ApplianceBackupAllOf';
import { ApplianceBackupBase } from '../models/ApplianceBackupBase';
import { ApplianceBackupBaseAllOf } from '../models/ApplianceBackupBaseAllOf';
import { ApplianceBackupList } from '../models/ApplianceBackupList';
import { ApplianceBackupListAllOf } from '../models/ApplianceBackupListAllOf';
import { ApplianceBackupPolicy } from '../models/ApplianceBackupPolicy';
import { ApplianceBackupPolicyAllOf } from '../models/ApplianceBackupPolicyAllOf';
import { ApplianceBackupPolicyList } from '../models/ApplianceBackupPolicyList';
import { ApplianceBackupPolicyListAllOf } from '../models/ApplianceBackupPolicyListAllOf';
import { ApplianceBackupPolicyResponse } from '../models/ApplianceBackupPolicyResponse';
import { ApplianceBackupResponse } from '../models/ApplianceBackupResponse';
import { ApplianceCertificateSetting } from '../models/ApplianceCertificateSetting';
import { ApplianceCertificateSettingAllOf } from '../models/ApplianceCertificateSettingAllOf';
import { ApplianceCertificateSettingList } from '../models/ApplianceCertificateSettingList';
import { ApplianceCertificateSettingListAllOf } from '../models/ApplianceCertificateSettingListAllOf';
import { ApplianceCertificateSettingResponse } from '../models/ApplianceCertificateSettingResponse';
import { ApplianceDataExportPolicy } from '../models/ApplianceDataExportPolicy';
import { ApplianceDataExportPolicyAllOf } from '../models/ApplianceDataExportPolicyAllOf';
import { ApplianceDataExportPolicyList } from '../models/ApplianceDataExportPolicyList';
import { ApplianceDataExportPolicyListAllOf } from '../models/ApplianceDataExportPolicyListAllOf';
import { ApplianceDataExportPolicyRelationship } from '../models/ApplianceDataExportPolicyRelationship';
import { ApplianceDataExportPolicyResponse } from '../models/ApplianceDataExportPolicyResponse';
import { ApplianceDeviceClaim } from '../models/ApplianceDeviceClaim';
import { ApplianceDeviceClaimAllOf } from '../models/ApplianceDeviceClaimAllOf';
import { ApplianceDeviceClaimList } from '../models/ApplianceDeviceClaimList';
import { ApplianceDeviceClaimListAllOf } from '../models/ApplianceDeviceClaimListAllOf';
import { ApplianceDeviceClaimResponse } from '../models/ApplianceDeviceClaimResponse';
import { ApplianceDiagSetting } from '../models/ApplianceDiagSetting';
import { ApplianceDiagSettingAllOf } from '../models/ApplianceDiagSettingAllOf';
import { ApplianceDiagSettingList } from '../models/ApplianceDiagSettingList';
import { ApplianceDiagSettingListAllOf } from '../models/ApplianceDiagSettingListAllOf';
import { ApplianceDiagSettingResponse } from '../models/ApplianceDiagSettingResponse';
import { ApplianceImageBundle } from '../models/ApplianceImageBundle';
import { ApplianceImageBundleAllOf } from '../models/ApplianceImageBundleAllOf';
import { ApplianceImageBundleList } from '../models/ApplianceImageBundleList';
import { ApplianceImageBundleListAllOf } from '../models/ApplianceImageBundleListAllOf';
import { ApplianceImageBundleRelationship } from '../models/ApplianceImageBundleRelationship';
import { ApplianceImageBundleResponse } from '../models/ApplianceImageBundleResponse';
import { ApplianceKeyValuePair } from '../models/ApplianceKeyValuePair';
import { ApplianceKeyValuePairAllOf } from '../models/ApplianceKeyValuePairAllOf';
import { ApplianceNodeInfo } from '../models/ApplianceNodeInfo';
import { ApplianceNodeInfoAllOf } from '../models/ApplianceNodeInfoAllOf';
import { ApplianceNodeInfoList } from '../models/ApplianceNodeInfoList';
import { ApplianceNodeInfoListAllOf } from '../models/ApplianceNodeInfoListAllOf';
import { ApplianceNodeInfoResponse } from '../models/ApplianceNodeInfoResponse';
import { ApplianceReleaseNote } from '../models/ApplianceReleaseNote';
import { ApplianceReleaseNoteAllOf } from '../models/ApplianceReleaseNoteAllOf';
import { ApplianceReleaseNoteList } from '../models/ApplianceReleaseNoteList';
import { ApplianceReleaseNoteListAllOf } from '../models/ApplianceReleaseNoteListAllOf';
import { ApplianceReleaseNoteResponse } from '../models/ApplianceReleaseNoteResponse';
import { ApplianceRestore } from '../models/ApplianceRestore';
import { ApplianceRestoreAllOf } from '../models/ApplianceRestoreAllOf';
import { ApplianceRestoreList } from '../models/ApplianceRestoreList';
import { ApplianceRestoreListAllOf } from '../models/ApplianceRestoreListAllOf';
import { ApplianceRestoreResponse } from '../models/ApplianceRestoreResponse';
import { ApplianceSetupInfo } from '../models/ApplianceSetupInfo';
import { ApplianceSetupInfoAllOf } from '../models/ApplianceSetupInfoAllOf';
import { ApplianceSetupInfoList } from '../models/ApplianceSetupInfoList';
import { ApplianceSetupInfoListAllOf } from '../models/ApplianceSetupInfoListAllOf';
import { ApplianceSetupInfoResponse } from '../models/ApplianceSetupInfoResponse';
import { ApplianceSystemInfo } from '../models/ApplianceSystemInfo';
import { ApplianceSystemInfoAllOf } from '../models/ApplianceSystemInfoAllOf';
import { ApplianceSystemInfoList } from '../models/ApplianceSystemInfoList';
import { ApplianceSystemInfoListAllOf } from '../models/ApplianceSystemInfoListAllOf';
import { ApplianceSystemInfoResponse } from '../models/ApplianceSystemInfoResponse';
import { ApplianceUpgrade } from '../models/ApplianceUpgrade';
import { ApplianceUpgradeAllOf } from '../models/ApplianceUpgradeAllOf';
import { ApplianceUpgradeList } from '../models/ApplianceUpgradeList';
import { ApplianceUpgradeListAllOf } from '../models/ApplianceUpgradeListAllOf';
import { ApplianceUpgradePolicy } from '../models/ApplianceUpgradePolicy';
import { ApplianceUpgradePolicyAllOf } from '../models/ApplianceUpgradePolicyAllOf';
import { ApplianceUpgradePolicyList } from '../models/ApplianceUpgradePolicyList';
import { ApplianceUpgradePolicyListAllOf } from '../models/ApplianceUpgradePolicyListAllOf';
import { ApplianceUpgradePolicyResponse } from '../models/ApplianceUpgradePolicyResponse';
import { ApplianceUpgradeResponse } from '../models/ApplianceUpgradeResponse';
import { AssetAddressInformation } from '../models/AssetAddressInformation';
import { AssetAddressInformationAllOf } from '../models/AssetAddressInformationAllOf';
import { AssetCloudConnection } from '../models/AssetCloudConnection';
import { AssetCloudConnectionAllOf } from '../models/AssetCloudConnectionAllOf';
import { AssetClusterMember } from '../models/AssetClusterMember';
import { AssetClusterMemberAllOf } from '../models/AssetClusterMemberAllOf';
import { AssetClusterMemberList } from '../models/AssetClusterMemberList';
import { AssetClusterMemberListAllOf } from '../models/AssetClusterMemberListAllOf';
import { AssetClusterMemberRelationship } from '../models/AssetClusterMemberRelationship';
import { AssetClusterMemberResponse } from '../models/AssetClusterMemberResponse';
import { AssetConnection } from '../models/AssetConnection';
import { AssetConnectionControlMessage } from '../models/AssetConnectionControlMessage';
import { AssetConnectionControlMessageAllOf } from '../models/AssetConnectionControlMessageAllOf';
import { AssetContractInformation } from '../models/AssetContractInformation';
import { AssetContractInformationAllOf } from '../models/AssetContractInformationAllOf';
import { AssetCredential } from '../models/AssetCredential';
import { AssetCustomerInformation } from '../models/AssetCustomerInformation';
import { AssetCustomerInformationAllOf } from '../models/AssetCustomerInformationAllOf';
import { AssetDeviceClaim } from '../models/AssetDeviceClaim';
import { AssetDeviceClaimAllOf } from '../models/AssetDeviceClaimAllOf';
import { AssetDeviceClaimRelationship } from '../models/AssetDeviceClaimRelationship';
import { AssetDeviceConfiguration } from '../models/AssetDeviceConfiguration';
import { AssetDeviceConfigurationAllOf } from '../models/AssetDeviceConfigurationAllOf';
import { AssetDeviceConfigurationList } from '../models/AssetDeviceConfigurationList';
import { AssetDeviceConfigurationListAllOf } from '../models/AssetDeviceConfigurationListAllOf';
import { AssetDeviceConfigurationRelationship } from '../models/AssetDeviceConfigurationRelationship';
import { AssetDeviceConfigurationResponse } from '../models/AssetDeviceConfigurationResponse';
import { AssetDeviceConnection } from '../models/AssetDeviceConnection';
import { AssetDeviceConnectionAllOf } from '../models/AssetDeviceConnectionAllOf';
import { AssetDeviceConnectionRelationship } from '../models/AssetDeviceConnectionRelationship';
import { AssetDeviceConnectorManager } from '../models/AssetDeviceConnectorManager';
import { AssetDeviceConnectorManagerAllOf } from '../models/AssetDeviceConnectorManagerAllOf';
import { AssetDeviceConnectorManagerList } from '../models/AssetDeviceConnectorManagerList';
import { AssetDeviceConnectorManagerListAllOf } from '../models/AssetDeviceConnectorManagerListAllOf';
import { AssetDeviceConnectorManagerResponse } from '../models/AssetDeviceConnectorManagerResponse';
import { AssetDeviceContractInformation } from '../models/AssetDeviceContractInformation';
import { AssetDeviceContractInformationAllOf } from '../models/AssetDeviceContractInformationAllOf';
import { AssetDeviceContractInformationList } from '../models/AssetDeviceContractInformationList';
import { AssetDeviceContractInformationListAllOf } from '../models/AssetDeviceContractInformationListAllOf';
import { AssetDeviceContractInformationResponse } from '../models/AssetDeviceContractInformationResponse';
import { AssetDeviceRegistration } from '../models/AssetDeviceRegistration';
import { AssetDeviceRegistrationAllOf } from '../models/AssetDeviceRegistrationAllOf';
import { AssetDeviceRegistrationList } from '../models/AssetDeviceRegistrationList';
import { AssetDeviceRegistrationListAllOf } from '../models/AssetDeviceRegistrationListAllOf';
import { AssetDeviceRegistrationRelationship } from '../models/AssetDeviceRegistrationRelationship';
import { AssetDeviceRegistrationResponse } from '../models/AssetDeviceRegistrationResponse';
import { AssetGlobalUltimate } from '../models/AssetGlobalUltimate';
import { AssetGlobalUltimateAllOf } from '../models/AssetGlobalUltimateAllOf';
import { AssetHttpConnection } from '../models/AssetHttpConnection';
import { AssetHttpConnectionAllOf } from '../models/AssetHttpConnectionAllOf';
import { AssetManagedDevice } from '../models/AssetManagedDevice';
import { AssetManagedDeviceAllOf } from '../models/AssetManagedDeviceAllOf';
import { AssetManagedDeviceList } from '../models/AssetManagedDeviceList';
import { AssetManagedDeviceListAllOf } from '../models/AssetManagedDeviceListAllOf';
import { AssetManagedDeviceResponse } from '../models/AssetManagedDeviceResponse';
import { AssetManagedDeviceStatus } from '../models/AssetManagedDeviceStatus';
import { AssetManagedDeviceStatusAllOf } from '../models/AssetManagedDeviceStatusAllOf';
import { AssetOrchestrationService } from '../models/AssetOrchestrationService';
import { AssetOrchestrationServiceAllOf } from '../models/AssetOrchestrationServiceAllOf';
import { AssetParentConnectionSignature } from '../models/AssetParentConnectionSignature';
import { AssetParentConnectionSignatureAllOf } from '../models/AssetParentConnectionSignatureAllOf';
import { AssetProductInformation } from '../models/AssetProductInformation';
import { AssetProductInformationAllOf } from '../models/AssetProductInformationAllOf';
import { AssetService } from '../models/AssetService';
import { AssetServiceAllOf } from '../models/AssetServiceAllOf';
import { AssetServiceOptions } from '../models/AssetServiceOptions';
import { AssetSudiInfo } from '../models/AssetSudiInfo';
import { AssetSudiInfoAllOf } from '../models/AssetSudiInfoAllOf';
import { AssetTarget } from '../models/AssetTarget';
import { AssetTargetAllOf } from '../models/AssetTargetAllOf';
import { AssetTargetList } from '../models/AssetTargetList';
import { AssetTargetListAllOf } from '../models/AssetTargetListAllOf';
import { AssetTargetResponse } from '../models/AssetTargetResponse';
import { AssetUsernamePasswordCredential } from '../models/AssetUsernamePasswordCredential';
import { AssetUsernamePasswordCredentialAllOf } from '../models/AssetUsernamePasswordCredentialAllOf';
import { AssetWorkloadOptimizerService } from '../models/AssetWorkloadOptimizerService';
import { AssetWorkloadOptimizerVmwareVcenterOptionsanyType } from '../models/AssetWorkloadOptimizerVmwareVcenterOptionsanyType';
import { AssetWorkloadOptimizerVmwareVcenterOptionsanyTypeAllOf } from '../models/AssetWorkloadOptimizerVmwareVcenterOptionsanyTypeAllOf';
import { BiosBootMode } from '../models/BiosBootMode';
import { BiosBootModeAllOf } from '../models/BiosBootModeAllOf';
import { BiosBootModeList } from '../models/BiosBootModeList';
import { BiosBootModeListAllOf } from '../models/BiosBootModeListAllOf';
import { BiosBootModeRelationship } from '../models/BiosBootModeRelationship';
import { BiosBootModeResponse } from '../models/BiosBootModeResponse';
import { BiosPolicy } from '../models/BiosPolicy';
import { BiosPolicyAllOf } from '../models/BiosPolicyAllOf';
import { BiosPolicyList } from '../models/BiosPolicyList';
import { BiosPolicyListAllOf } from '../models/BiosPolicyListAllOf';
import { BiosPolicyResponse } from '../models/BiosPolicyResponse';
import { BiosUnit } from '../models/BiosUnit';
import { BiosUnitAllOf } from '../models/BiosUnitAllOf';
import { BiosUnitList } from '../models/BiosUnitList';
import { BiosUnitListAllOf } from '../models/BiosUnitListAllOf';
import { BiosUnitRelationship } from '../models/BiosUnitRelationship';
import { BiosUnitResponse } from '../models/BiosUnitResponse';
import { BootBootloader } from '../models/BootBootloader';
import { BootBootloaderAllOf } from '../models/BootBootloaderAllOf';
import { BootDeviceBase } from '../models/BootDeviceBase';
import { BootDeviceBaseAllOf } from '../models/BootDeviceBaseAllOf';
import { BootDeviceBootMode } from '../models/BootDeviceBootMode';
import { BootDeviceBootModeAllOf } from '../models/BootDeviceBootModeAllOf';
import { BootDeviceBootModeList } from '../models/BootDeviceBootModeList';
import { BootDeviceBootModeListAllOf } from '../models/BootDeviceBootModeListAllOf';
import { BootDeviceBootModeRelationship } from '../models/BootDeviceBootModeRelationship';
import { BootDeviceBootModeResponse } from '../models/BootDeviceBootModeResponse';
import { BootIscsi } from '../models/BootIscsi';
import { BootIscsiAllOf } from '../models/BootIscsiAllOf';
import { BootLocalCdd } from '../models/BootLocalCdd';
import { BootLocalDisk } from '../models/BootLocalDisk';
import { BootLocalDiskAllOf } from '../models/BootLocalDiskAllOf';
import { BootNvme } from '../models/BootNvme';
import { BootPchStorage } from '../models/BootPchStorage';
import { BootPchStorageAllOf } from '../models/BootPchStorageAllOf';
import { BootPrecisionPolicy } from '../models/BootPrecisionPolicy';
import { BootPrecisionPolicyAllOf } from '../models/BootPrecisionPolicyAllOf';
import { BootPrecisionPolicyList } from '../models/BootPrecisionPolicyList';
import { BootPrecisionPolicyListAllOf } from '../models/BootPrecisionPolicyListAllOf';
import { BootPrecisionPolicyResponse } from '../models/BootPrecisionPolicyResponse';
import { BootPxe } from '../models/BootPxe';
import { BootPxeAllOf } from '../models/BootPxeAllOf';
import { BootSan } from '../models/BootSan';
import { BootSanAllOf } from '../models/BootSanAllOf';
import { BootSdCard } from '../models/BootSdCard';
import { BootSdCardAllOf } from '../models/BootSdCardAllOf';
import { BootUefiShell } from '../models/BootUefiShell';
import { BootUsb } from '../models/BootUsb';
import { BootUsbAllOf } from '../models/BootUsbAllOf';
import { BootVirtualMedia } from '../models/BootVirtualMedia';
import { BootVirtualMediaAllOf } from '../models/BootVirtualMediaAllOf';
import { CmrfCmRf } from '../models/CmrfCmRf';
import { CmrfCmRfAllOf } from '../models/CmrfCmRfAllOf';
import { CommConcreteCredential } from '../models/CommConcreteCredential';
import { CommConcreteCredentialAllOf } from '../models/CommConcreteCredentialAllOf';
import { CommCredential } from '../models/CommCredential';
import { CommCredentialAllOf } from '../models/CommCredentialAllOf';
import { CommIpV4Interface } from '../models/CommIpV4Interface';
import { CommIpV4InterfaceAllOf } from '../models/CommIpV4InterfaceAllOf';
import { CommVmwareCredential } from '../models/CommVmwareCredential';
import { CommVmwareCredentialAllOf } from '../models/CommVmwareCredentialAllOf';
import { ComputeBlade } from '../models/ComputeBlade';
import { ComputeBladeAllOf } from '../models/ComputeBladeAllOf';
import { ComputeBladeList } from '../models/ComputeBladeList';
import { ComputeBladeListAllOf } from '../models/ComputeBladeListAllOf';
import { ComputeBladeRelationship } from '../models/ComputeBladeRelationship';
import { ComputeBladeResponse } from '../models/ComputeBladeResponse';
import { ComputeBoard } from '../models/ComputeBoard';
import { ComputeBoardAllOf } from '../models/ComputeBoardAllOf';
import { ComputeBoardList } from '../models/ComputeBoardList';
import { ComputeBoardListAllOf } from '../models/ComputeBoardListAllOf';
import { ComputeBoardRelationship } from '../models/ComputeBoardRelationship';
import { ComputeBoardResponse } from '../models/ComputeBoardResponse';
import { ComputeIpAddress } from '../models/ComputeIpAddress';
import { ComputeIpAddressAllOf } from '../models/ComputeIpAddressAllOf';
import { ComputePersistentMemoryModule } from '../models/ComputePersistentMemoryModule';
import { ComputePersistentMemoryModuleAllOf } from '../models/ComputePersistentMemoryModuleAllOf';
import { ComputePersistentMemoryOperation } from '../models/ComputePersistentMemoryOperation';
import { ComputePersistentMemoryOperationAllOf } from '../models/ComputePersistentMemoryOperationAllOf';
import { ComputePhysical } from '../models/ComputePhysical';
import { ComputePhysicalAllOf } from '../models/ComputePhysicalAllOf';
import { ComputePhysicalRelationship } from '../models/ComputePhysicalRelationship';
import { ComputePhysicalSummary } from '../models/ComputePhysicalSummary';
import { ComputePhysicalSummaryAllOf } from '../models/ComputePhysicalSummaryAllOf';
import { ComputePhysicalSummaryList } from '../models/ComputePhysicalSummaryList';
import { ComputePhysicalSummaryListAllOf } from '../models/ComputePhysicalSummaryListAllOf';
import { ComputePhysicalSummaryResponse } from '../models/ComputePhysicalSummaryResponse';
import { ComputeRackUnit } from '../models/ComputeRackUnit';
import { ComputeRackUnitAllOf } from '../models/ComputeRackUnitAllOf';
import { ComputeRackUnitList } from '../models/ComputeRackUnitList';
import { ComputeRackUnitListAllOf } from '../models/ComputeRackUnitListAllOf';
import { ComputeRackUnitRelationship } from '../models/ComputeRackUnitRelationship';
import { ComputeRackUnitResponse } from '../models/ComputeRackUnitResponse';
import { ComputeServerConfig } from '../models/ComputeServerConfig';
import { ComputeServerConfigAllOf } from '../models/ComputeServerConfigAllOf';
import { ComputeServerSetting } from '../models/ComputeServerSetting';
import { ComputeServerSettingAllOf } from '../models/ComputeServerSettingAllOf';
import { ComputeServerSettingList } from '../models/ComputeServerSettingList';
import { ComputeServerSettingListAllOf } from '../models/ComputeServerSettingListAllOf';
import { ComputeServerSettingResponse } from '../models/ComputeServerSettingResponse';
import { CondAlarm } from '../models/CondAlarm';
import { CondAlarmAllOf } from '../models/CondAlarmAllOf';
import { CondAlarmList } from '../models/CondAlarmList';
import { CondAlarmListAllOf } from '../models/CondAlarmListAllOf';
import { CondAlarmResponse } from '../models/CondAlarmResponse';
import { CondHclStatus } from '../models/CondHclStatus';
import { CondHclStatusAllOf } from '../models/CondHclStatusAllOf';
import { CondHclStatusDetail } from '../models/CondHclStatusDetail';
import { CondHclStatusDetailAllOf } from '../models/CondHclStatusDetailAllOf';
import { CondHclStatusDetailList } from '../models/CondHclStatusDetailList';
import { CondHclStatusDetailListAllOf } from '../models/CondHclStatusDetailListAllOf';
import { CondHclStatusDetailRelationship } from '../models/CondHclStatusDetailRelationship';
import { CondHclStatusDetailResponse } from '../models/CondHclStatusDetailResponse';
import { CondHclStatusJob } from '../models/CondHclStatusJob';
import { CondHclStatusJobAllOf } from '../models/CondHclStatusJobAllOf';
import { CondHclStatusJobList } from '../models/CondHclStatusJobList';
import { CondHclStatusJobListAllOf } from '../models/CondHclStatusJobListAllOf';
import { CondHclStatusJobResponse } from '../models/CondHclStatusJobResponse';
import { CondHclStatusList } from '../models/CondHclStatusList';
import { CondHclStatusListAllOf } from '../models/CondHclStatusListAllOf';
import { CondHclStatusRelationship } from '../models/CondHclStatusRelationship';
import { CondHclStatusResponse } from '../models/CondHclStatusResponse';
import { ConnectorScopedInventory } from '../models/ConnectorScopedInventory';
import { ConnectorScopedInventoryAllOf } from '../models/ConnectorScopedInventoryAllOf';
import { ConnectorpackConnectorPackUpdate } from '../models/ConnectorpackConnectorPackUpdate';
import { ConnectorpackConnectorPackUpdateAllOf } from '../models/ConnectorpackConnectorPackUpdateAllOf';
import { ConnectorpackConnectorPackUpgrade } from '../models/ConnectorpackConnectorPackUpgrade';
import { ConnectorpackConnectorPackUpgradeAllOf } from '../models/ConnectorpackConnectorPackUpgradeAllOf';
import { ConnectorpackConnectorPackUpgradeList } from '../models/ConnectorpackConnectorPackUpgradeList';
import { ConnectorpackConnectorPackUpgradeListAllOf } from '../models/ConnectorpackConnectorPackUpgradeListAllOf';
import { ConnectorpackConnectorPackUpgradeResponse } from '../models/ConnectorpackConnectorPackUpgradeResponse';
import { ConnectorpackUpgradeImpact } from '../models/ConnectorpackUpgradeImpact';
import { ConnectorpackUpgradeImpactAllOf } from '../models/ConnectorpackUpgradeImpactAllOf';
import { ConnectorpackUpgradeImpactList } from '../models/ConnectorpackUpgradeImpactList';
import { ConnectorpackUpgradeImpactListAllOf } from '../models/ConnectorpackUpgradeImpactListAllOf';
import { ConnectorpackUpgradeImpactResponse } from '../models/ConnectorpackUpgradeImpactResponse';
import { ContentBaseParameter } from '../models/ContentBaseParameter';
import { ContentBaseParameterAllOf } from '../models/ContentBaseParameterAllOf';
import { ContentComplexType } from '../models/ContentComplexType';
import { ContentComplexTypeAllOf } from '../models/ContentComplexTypeAllOf';
import { ContentGrammar } from '../models/ContentGrammar';
import { ContentGrammarAllOf } from '../models/ContentGrammarAllOf';
import { ContentParameter } from '../models/ContentParameter';
import { ContentTextParameter } from '../models/ContentTextParameter';
import { ContentTextParameterAllOf } from '../models/ContentTextParameterAllOf';
import { DeviceconnectorPolicy } from '../models/DeviceconnectorPolicy';
import { DeviceconnectorPolicyAllOf } from '../models/DeviceconnectorPolicyAllOf';
import { DeviceconnectorPolicyList } from '../models/DeviceconnectorPolicyList';
import { DeviceconnectorPolicyListAllOf } from '../models/DeviceconnectorPolicyListAllOf';
import { DeviceconnectorPolicyResponse } from '../models/DeviceconnectorPolicyResponse';
import { EquipmentAbstractDevice } from '../models/EquipmentAbstractDevice';
import { EquipmentAbstractDeviceAllOf } from '../models/EquipmentAbstractDeviceAllOf';
import { EquipmentBase } from '../models/EquipmentBase';
import { EquipmentBaseAllOf } from '../models/EquipmentBaseAllOf';
import { EquipmentChassis } from '../models/EquipmentChassis';
import { EquipmentChassisAllOf } from '../models/EquipmentChassisAllOf';
import { EquipmentChassisList } from '../models/EquipmentChassisList';
import { EquipmentChassisListAllOf } from '../models/EquipmentChassisListAllOf';
import { EquipmentChassisRelationship } from '../models/EquipmentChassisRelationship';
import { EquipmentChassisResponse } from '../models/EquipmentChassisResponse';
import { EquipmentDeviceSummary } from '../models/EquipmentDeviceSummary';
import { EquipmentDeviceSummaryAllOf } from '../models/EquipmentDeviceSummaryAllOf';
import { EquipmentDeviceSummaryList } from '../models/EquipmentDeviceSummaryList';
import { EquipmentDeviceSummaryListAllOf } from '../models/EquipmentDeviceSummaryListAllOf';
import { EquipmentDeviceSummaryResponse } from '../models/EquipmentDeviceSummaryResponse';
import { EquipmentFan } from '../models/EquipmentFan';
import { EquipmentFanAllOf } from '../models/EquipmentFanAllOf';
import { EquipmentFanList } from '../models/EquipmentFanList';
import { EquipmentFanListAllOf } from '../models/EquipmentFanListAllOf';
import { EquipmentFanModule } from '../models/EquipmentFanModule';
import { EquipmentFanModuleAllOf } from '../models/EquipmentFanModuleAllOf';
import { EquipmentFanModuleList } from '../models/EquipmentFanModuleList';
import { EquipmentFanModuleListAllOf } from '../models/EquipmentFanModuleListAllOf';
import { EquipmentFanModuleRelationship } from '../models/EquipmentFanModuleRelationship';
import { EquipmentFanModuleResponse } from '../models/EquipmentFanModuleResponse';
import { EquipmentFanRelationship } from '../models/EquipmentFanRelationship';
import { EquipmentFanResponse } from '../models/EquipmentFanResponse';
import { EquipmentFex } from '../models/EquipmentFex';
import { EquipmentFexAllOf } from '../models/EquipmentFexAllOf';
import { EquipmentFexList } from '../models/EquipmentFexList';
import { EquipmentFexListAllOf } from '../models/EquipmentFexListAllOf';
import { EquipmentFexResponse } from '../models/EquipmentFexResponse';
import { EquipmentIoCard } from '../models/EquipmentIoCard';
import { EquipmentIoCardAllOf } from '../models/EquipmentIoCardAllOf';
import { EquipmentIoCardList } from '../models/EquipmentIoCardList';
import { EquipmentIoCardListAllOf } from '../models/EquipmentIoCardListAllOf';
import { EquipmentIoCardRelationship } from '../models/EquipmentIoCardRelationship';
import { EquipmentIoCardResponse } from '../models/EquipmentIoCardResponse';
import { EquipmentIoExpander } from '../models/EquipmentIoExpander';
import { EquipmentIoExpanderAllOf } from '../models/EquipmentIoExpanderAllOf';
import { EquipmentIoExpanderList } from '../models/EquipmentIoExpanderList';
import { EquipmentIoExpanderListAllOf } from '../models/EquipmentIoExpanderListAllOf';
import { EquipmentIoExpanderRelationship } from '../models/EquipmentIoExpanderRelationship';
import { EquipmentIoExpanderResponse } from '../models/EquipmentIoExpanderResponse';
import { EquipmentLocatorLed } from '../models/EquipmentLocatorLed';
import { EquipmentLocatorLedAllOf } from '../models/EquipmentLocatorLedAllOf';
import { EquipmentLocatorLedList } from '../models/EquipmentLocatorLedList';
import { EquipmentLocatorLedListAllOf } from '../models/EquipmentLocatorLedListAllOf';
import { EquipmentLocatorLedRelationship } from '../models/EquipmentLocatorLedRelationship';
import { EquipmentLocatorLedResponse } from '../models/EquipmentLocatorLedResponse';
import { EquipmentPsu } from '../models/EquipmentPsu';
import { EquipmentPsuAllOf } from '../models/EquipmentPsuAllOf';
import { EquipmentPsuList } from '../models/EquipmentPsuList';
import { EquipmentPsuListAllOf } from '../models/EquipmentPsuListAllOf';
import { EquipmentPsuRelationship } from '../models/EquipmentPsuRelationship';
import { EquipmentPsuResponse } from '../models/EquipmentPsuResponse';
import { EquipmentRackEnclosure } from '../models/EquipmentRackEnclosure';
import { EquipmentRackEnclosureAllOf } from '../models/EquipmentRackEnclosureAllOf';
import { EquipmentRackEnclosureList } from '../models/EquipmentRackEnclosureList';
import { EquipmentRackEnclosureListAllOf } from '../models/EquipmentRackEnclosureListAllOf';
import { EquipmentRackEnclosureRelationship } from '../models/EquipmentRackEnclosureRelationship';
import { EquipmentRackEnclosureResponse } from '../models/EquipmentRackEnclosureResponse';
import { EquipmentRackEnclosureSlot } from '../models/EquipmentRackEnclosureSlot';
import { EquipmentRackEnclosureSlotAllOf } from '../models/EquipmentRackEnclosureSlotAllOf';
import { EquipmentRackEnclosureSlotList } from '../models/EquipmentRackEnclosureSlotList';
import { EquipmentRackEnclosureSlotListAllOf } from '../models/EquipmentRackEnclosureSlotListAllOf';
import { EquipmentRackEnclosureSlotRelationship } from '../models/EquipmentRackEnclosureSlotRelationship';
import { EquipmentRackEnclosureSlotResponse } from '../models/EquipmentRackEnclosureSlotResponse';
import { EquipmentSharedIoModule } from '../models/EquipmentSharedIoModule';
import { EquipmentSharedIoModuleAllOf } from '../models/EquipmentSharedIoModuleAllOf';
import { EquipmentSharedIoModuleList } from '../models/EquipmentSharedIoModuleList';
import { EquipmentSharedIoModuleListAllOf } from '../models/EquipmentSharedIoModuleListAllOf';
import { EquipmentSharedIoModuleRelationship } from '../models/EquipmentSharedIoModuleRelationship';
import { EquipmentSharedIoModuleResponse } from '../models/EquipmentSharedIoModuleResponse';
import { EquipmentSwitchCard } from '../models/EquipmentSwitchCard';
import { EquipmentSwitchCardAllOf } from '../models/EquipmentSwitchCardAllOf';
import { EquipmentSwitchCardList } from '../models/EquipmentSwitchCardList';
import { EquipmentSwitchCardListAllOf } from '../models/EquipmentSwitchCardListAllOf';
import { EquipmentSwitchCardRelationship } from '../models/EquipmentSwitchCardRelationship';
import { EquipmentSwitchCardResponse } from '../models/EquipmentSwitchCardResponse';
import { EquipmentSystemIoController } from '../models/EquipmentSystemIoController';
import { EquipmentSystemIoControllerAllOf } from '../models/EquipmentSystemIoControllerAllOf';
import { EquipmentSystemIoControllerList } from '../models/EquipmentSystemIoControllerList';
import { EquipmentSystemIoControllerListAllOf } from '../models/EquipmentSystemIoControllerListAllOf';
import { EquipmentSystemIoControllerRelationship } from '../models/EquipmentSystemIoControllerRelationship';
import { EquipmentSystemIoControllerResponse } from '../models/EquipmentSystemIoControllerResponse';
import { EquipmentTpm } from '../models/EquipmentTpm';
import { EquipmentTpmAllOf } from '../models/EquipmentTpmAllOf';
import { EquipmentTpmList } from '../models/EquipmentTpmList';
import { EquipmentTpmListAllOf } from '../models/EquipmentTpmListAllOf';
import { EquipmentTpmRelationship } from '../models/EquipmentTpmRelationship';
import { EquipmentTpmResponse } from '../models/EquipmentTpmResponse';
import { EtherPhysicalPort } from '../models/EtherPhysicalPort';
import { EtherPhysicalPortAllOf } from '../models/EtherPhysicalPortAllOf';
import { EtherPhysicalPortList } from '../models/EtherPhysicalPortList';
import { EtherPhysicalPortListAllOf } from '../models/EtherPhysicalPortListAllOf';
import { EtherPhysicalPortRelationship } from '../models/EtherPhysicalPortRelationship';
import { EtherPhysicalPortResponse } from '../models/EtherPhysicalPortResponse';
import { ExternalsiteAuthorization } from '../models/ExternalsiteAuthorization';
import { ExternalsiteAuthorizationAllOf } from '../models/ExternalsiteAuthorizationAllOf';
import { ExternalsiteAuthorizationList } from '../models/ExternalsiteAuthorizationList';
import { ExternalsiteAuthorizationListAllOf } from '../models/ExternalsiteAuthorizationListAllOf';
import { ExternalsiteAuthorizationResponse } from '../models/ExternalsiteAuthorizationResponse';
import { FaultInstance } from '../models/FaultInstance';
import { FaultInstanceAllOf } from '../models/FaultInstanceAllOf';
import { FaultInstanceList } from '../models/FaultInstanceList';
import { FaultInstanceListAllOf } from '../models/FaultInstanceListAllOf';
import { FaultInstanceResponse } from '../models/FaultInstanceResponse';
import { FcPhysicalPort } from '../models/FcPhysicalPort';
import { FcPhysicalPortAllOf } from '../models/FcPhysicalPortAllOf';
import { FcPhysicalPortList } from '../models/FcPhysicalPortList';
import { FcPhysicalPortListAllOf } from '../models/FcPhysicalPortListAllOf';
import { FcPhysicalPortRelationship } from '../models/FcPhysicalPortRelationship';
import { FcPhysicalPortResponse } from '../models/FcPhysicalPortResponse';
import { FeedbackFeedbackData } from '../models/FeedbackFeedbackData';
import { FeedbackFeedbackDataAllOf } from '../models/FeedbackFeedbackDataAllOf';
import { FeedbackFeedbackPost } from '../models/FeedbackFeedbackPost';
import { FeedbackFeedbackPostAllOf } from '../models/FeedbackFeedbackPostAllOf';
import { FirmwareBaseDistributable } from '../models/FirmwareBaseDistributable';
import { FirmwareBaseDistributableAllOf } from '../models/FirmwareBaseDistributableAllOf';
import { FirmwareCifsServer } from '../models/FirmwareCifsServer';
import { FirmwareCifsServerAllOf } from '../models/FirmwareCifsServerAllOf';
import { FirmwareDirectDownload } from '../models/FirmwareDirectDownload';
import { FirmwareDirectDownloadAllOf } from '../models/FirmwareDirectDownloadAllOf';
import { FirmwareDistributable } from '../models/FirmwareDistributable';
import { FirmwareDistributableAllOf } from '../models/FirmwareDistributableAllOf';
import { FirmwareDistributableList } from '../models/FirmwareDistributableList';
import { FirmwareDistributableListAllOf } from '../models/FirmwareDistributableListAllOf';
import { FirmwareDistributableRelationship } from '../models/FirmwareDistributableRelationship';
import { FirmwareDistributableResponse } from '../models/FirmwareDistributableResponse';
import { FirmwareDriverDistributable } from '../models/FirmwareDriverDistributable';
import { FirmwareDriverDistributableAllOf } from '../models/FirmwareDriverDistributableAllOf';
import { FirmwareDriverDistributableList } from '../models/FirmwareDriverDistributableList';
import { FirmwareDriverDistributableListAllOf } from '../models/FirmwareDriverDistributableListAllOf';
import { FirmwareDriverDistributableResponse } from '../models/FirmwareDriverDistributableResponse';
import { FirmwareEula } from '../models/FirmwareEula';
import { FirmwareEulaAllOf } from '../models/FirmwareEulaAllOf';
import { FirmwareEulaList } from '../models/FirmwareEulaList';
import { FirmwareEulaListAllOf } from '../models/FirmwareEulaListAllOf';
import { FirmwareEulaResponse } from '../models/FirmwareEulaResponse';
import { FirmwareHttpServer } from '../models/FirmwareHttpServer';
import { FirmwareHttpServerAllOf } from '../models/FirmwareHttpServerAllOf';
import { FirmwareNetworkShare } from '../models/FirmwareNetworkShare';
import { FirmwareNetworkShareAllOf } from '../models/FirmwareNetworkShareAllOf';
import { FirmwareNfsServer } from '../models/FirmwareNfsServer';
import { FirmwareNfsServerAllOf } from '../models/FirmwareNfsServerAllOf';
import { FirmwareRunningFirmware } from '../models/FirmwareRunningFirmware';
import { FirmwareRunningFirmwareAllOf } from '../models/FirmwareRunningFirmwareAllOf';
import { FirmwareRunningFirmwareList } from '../models/FirmwareRunningFirmwareList';
import { FirmwareRunningFirmwareListAllOf } from '../models/FirmwareRunningFirmwareListAllOf';
import { FirmwareRunningFirmwareRelationship } from '../models/FirmwareRunningFirmwareRelationship';
import { FirmwareRunningFirmwareResponse } from '../models/FirmwareRunningFirmwareResponse';
import { FirmwareServerConfigurationUtilityDistributable } from '../models/FirmwareServerConfigurationUtilityDistributable';
import { FirmwareServerConfigurationUtilityDistributableAllOf } from '../models/FirmwareServerConfigurationUtilityDistributableAllOf';
import { FirmwareServerConfigurationUtilityDistributableList } from '../models/FirmwareServerConfigurationUtilityDistributableList';
import { FirmwareServerConfigurationUtilityDistributableListAllOf } from '../models/FirmwareServerConfigurationUtilityDistributableListAllOf';
import { FirmwareServerConfigurationUtilityDistributableRelationship } from '../models/FirmwareServerConfigurationUtilityDistributableRelationship';
import { FirmwareServerConfigurationUtilityDistributableResponse } from '../models/FirmwareServerConfigurationUtilityDistributableResponse';
import { FirmwareUpgrade } from '../models/FirmwareUpgrade';
import { FirmwareUpgradeAllOf } from '../models/FirmwareUpgradeAllOf';
import { FirmwareUpgradeList } from '../models/FirmwareUpgradeList';
import { FirmwareUpgradeListAllOf } from '../models/FirmwareUpgradeListAllOf';
import { FirmwareUpgradeRelationship } from '../models/FirmwareUpgradeRelationship';
import { FirmwareUpgradeResponse } from '../models/FirmwareUpgradeResponse';
import { FirmwareUpgradeStatus } from '../models/FirmwareUpgradeStatus';
import { FirmwareUpgradeStatusAllOf } from '../models/FirmwareUpgradeStatusAllOf';
import { FirmwareUpgradeStatusList } from '../models/FirmwareUpgradeStatusList';
import { FirmwareUpgradeStatusListAllOf } from '../models/FirmwareUpgradeStatusListAllOf';
import { FirmwareUpgradeStatusRelationship } from '../models/FirmwareUpgradeStatusRelationship';
import { FirmwareUpgradeStatusResponse } from '../models/FirmwareUpgradeStatusResponse';
import { ForecastCatalog } from '../models/ForecastCatalog';
import { ForecastCatalogAllOf } from '../models/ForecastCatalogAllOf';
import { ForecastCatalogList } from '../models/ForecastCatalogList';
import { ForecastCatalogListAllOf } from '../models/ForecastCatalogListAllOf';
import { ForecastCatalogRelationship } from '../models/ForecastCatalogRelationship';
import { ForecastCatalogResponse } from '../models/ForecastCatalogResponse';
import { ForecastDefinition } from '../models/ForecastDefinition';
import { ForecastDefinitionAllOf } from '../models/ForecastDefinitionAllOf';
import { ForecastDefinitionList } from '../models/ForecastDefinitionList';
import { ForecastDefinitionListAllOf } from '../models/ForecastDefinitionListAllOf';
import { ForecastDefinitionRelationship } from '../models/ForecastDefinitionRelationship';
import { ForecastDefinitionResponse } from '../models/ForecastDefinitionResponse';
import { ForecastInstance } from '../models/ForecastInstance';
import { ForecastInstanceAllOf } from '../models/ForecastInstanceAllOf';
import { ForecastInstanceList } from '../models/ForecastInstanceList';
import { ForecastInstanceListAllOf } from '../models/ForecastInstanceListAllOf';
import { ForecastInstanceResponse } from '../models/ForecastInstanceResponse';
import { ForecastModel } from '../models/ForecastModel';
import { ForecastModelAllOf } from '../models/ForecastModelAllOf';
import { GraphicsCard } from '../models/GraphicsCard';
import { GraphicsCardAllOf } from '../models/GraphicsCardAllOf';
import { GraphicsCardList } from '../models/GraphicsCardList';
import { GraphicsCardListAllOf } from '../models/GraphicsCardListAllOf';
import { GraphicsCardRelationship } from '../models/GraphicsCardRelationship';
import { GraphicsCardResponse } from '../models/GraphicsCardResponse';
import { GraphicsController } from '../models/GraphicsController';
import { GraphicsControllerAllOf } from '../models/GraphicsControllerAllOf';
import { GraphicsControllerList } from '../models/GraphicsControllerList';
import { GraphicsControllerListAllOf } from '../models/GraphicsControllerListAllOf';
import { GraphicsControllerRelationship } from '../models/GraphicsControllerRelationship';
import { GraphicsControllerResponse } from '../models/GraphicsControllerResponse';
import { HclCompatibilityStatus } from '../models/HclCompatibilityStatus';
import { HclCompatibilityStatusAllOf } from '../models/HclCompatibilityStatusAllOf';
import { HclConstraint } from '../models/HclConstraint';
import { HclConstraintAllOf } from '../models/HclConstraintAllOf';
import { HclDriverImage } from '../models/HclDriverImage';
import { HclDriverImageAllOf } from '../models/HclDriverImageAllOf';
import { HclDriverImageList } from '../models/HclDriverImageList';
import { HclDriverImageListAllOf } from '../models/HclDriverImageListAllOf';
import { HclDriverImageResponse } from '../models/HclDriverImageResponse';
import { HclExemptedCatalog } from '../models/HclExemptedCatalog';
import { HclExemptedCatalogAllOf } from '../models/HclExemptedCatalogAllOf';
import { HclExemptedCatalogList } from '../models/HclExemptedCatalogList';
import { HclExemptedCatalogListAllOf } from '../models/HclExemptedCatalogListAllOf';
import { HclExemptedCatalogResponse } from '../models/HclExemptedCatalogResponse';
import { HclFirmware } from '../models/HclFirmware';
import { HclFirmwareAllOf } from '../models/HclFirmwareAllOf';
import { HclHardwareCompatibilityProfile } from '../models/HclHardwareCompatibilityProfile';
import { HclHardwareCompatibilityProfileAllOf } from '../models/HclHardwareCompatibilityProfileAllOf';
import { HclHyperflexSoftwareCompatibilityInfo } from '../models/HclHyperflexSoftwareCompatibilityInfo';
import { HclHyperflexSoftwareCompatibilityInfoAllOf } from '../models/HclHyperflexSoftwareCompatibilityInfoAllOf';
import { HclHyperflexSoftwareCompatibilityInfoList } from '../models/HclHyperflexSoftwareCompatibilityInfoList';
import { HclHyperflexSoftwareCompatibilityInfoListAllOf } from '../models/HclHyperflexSoftwareCompatibilityInfoListAllOf';
import { HclHyperflexSoftwareCompatibilityInfoRelationship } from '../models/HclHyperflexSoftwareCompatibilityInfoRelationship';
import { HclHyperflexSoftwareCompatibilityInfoResponse } from '../models/HclHyperflexSoftwareCompatibilityInfoResponse';
import { HclOperatingSystem } from '../models/HclOperatingSystem';
import { HclOperatingSystemAllOf } from '../models/HclOperatingSystemAllOf';
import { HclOperatingSystemList } from '../models/HclOperatingSystemList';
import { HclOperatingSystemListAllOf } from '../models/HclOperatingSystemListAllOf';
import { HclOperatingSystemRelationship } from '../models/HclOperatingSystemRelationship';
import { HclOperatingSystemResponse } from '../models/HclOperatingSystemResponse';
import { HclOperatingSystemVendor } from '../models/HclOperatingSystemVendor';
import { HclOperatingSystemVendorAllOf } from '../models/HclOperatingSystemVendorAllOf';
import { HclOperatingSystemVendorList } from '../models/HclOperatingSystemVendorList';
import { HclOperatingSystemVendorListAllOf } from '../models/HclOperatingSystemVendorListAllOf';
import { HclOperatingSystemVendorRelationship } from '../models/HclOperatingSystemVendorRelationship';
import { HclOperatingSystemVendorResponse } from '../models/HclOperatingSystemVendorResponse';
import { HclProduct } from '../models/HclProduct';
import { HclProductAllOf } from '../models/HclProductAllOf';
import { HclServiceStatus } from '../models/HclServiceStatus';
import { HclServiceStatusAllOf } from '../models/HclServiceStatusAllOf';
import { HclServiceStatusList } from '../models/HclServiceStatusList';
import { HclServiceStatusListAllOf } from '../models/HclServiceStatusListAllOf';
import { HclServiceStatusResponse } from '../models/HclServiceStatusResponse';
import { HclSupportedDriverName } from '../models/HclSupportedDriverName';
import { HclSupportedDriverNameAllOf } from '../models/HclSupportedDriverNameAllOf';
import { HyperflexAbstractAppSetting } from '../models/HyperflexAbstractAppSetting';
import { HyperflexAbstractAppSettingAllOf } from '../models/HyperflexAbstractAppSettingAllOf';
import { HyperflexAlarm } from '../models/HyperflexAlarm';
import { HyperflexAlarmAllOf } from '../models/HyperflexAlarmAllOf';
import { HyperflexAlarmList } from '../models/HyperflexAlarmList';
import { HyperflexAlarmListAllOf } from '../models/HyperflexAlarmListAllOf';
import { HyperflexAlarmRelationship } from '../models/HyperflexAlarmRelationship';
import { HyperflexAlarmResponse } from '../models/HyperflexAlarmResponse';
import { HyperflexAppCatalog } from '../models/HyperflexAppCatalog';
import { HyperflexAppCatalogAllOf } from '../models/HyperflexAppCatalogAllOf';
import { HyperflexAppCatalogList } from '../models/HyperflexAppCatalogList';
import { HyperflexAppCatalogListAllOf } from '../models/HyperflexAppCatalogListAllOf';
import { HyperflexAppCatalogRelationship } from '../models/HyperflexAppCatalogRelationship';
import { HyperflexAppCatalogResponse } from '../models/HyperflexAppCatalogResponse';
import { HyperflexAppSettingConstraint } from '../models/HyperflexAppSettingConstraint';
import { HyperflexAppSettingConstraintAllOf } from '../models/HyperflexAppSettingConstraintAllOf';
import { HyperflexAutoSupportPolicy } from '../models/HyperflexAutoSupportPolicy';
import { HyperflexAutoSupportPolicyAllOf } from '../models/HyperflexAutoSupportPolicyAllOf';
import { HyperflexAutoSupportPolicyList } from '../models/HyperflexAutoSupportPolicyList';
import { HyperflexAutoSupportPolicyListAllOf } from '../models/HyperflexAutoSupportPolicyListAllOf';
import { HyperflexAutoSupportPolicyRelationship } from '../models/HyperflexAutoSupportPolicyRelationship';
import { HyperflexAutoSupportPolicyResponse } from '../models/HyperflexAutoSupportPolicyResponse';
import { HyperflexCapabilityInfo } from '../models/HyperflexCapabilityInfo';
import { HyperflexCapabilityInfoAllOf } from '../models/HyperflexCapabilityInfoAllOf';
import { HyperflexCapabilityInfoList } from '../models/HyperflexCapabilityInfoList';
import { HyperflexCapabilityInfoListAllOf } from '../models/HyperflexCapabilityInfoListAllOf';
import { HyperflexCapabilityInfoRelationship } from '../models/HyperflexCapabilityInfoRelationship';
import { HyperflexCapabilityInfoResponse } from '../models/HyperflexCapabilityInfoResponse';
import { HyperflexCluster } from '../models/HyperflexCluster';
import { HyperflexClusterAllOf } from '../models/HyperflexClusterAllOf';
import { HyperflexClusterList } from '../models/HyperflexClusterList';
import { HyperflexClusterListAllOf } from '../models/HyperflexClusterListAllOf';
import { HyperflexClusterNetworkPolicy } from '../models/HyperflexClusterNetworkPolicy';
import { HyperflexClusterNetworkPolicyAllOf } from '../models/HyperflexClusterNetworkPolicyAllOf';
import { HyperflexClusterNetworkPolicyList } from '../models/HyperflexClusterNetworkPolicyList';
import { HyperflexClusterNetworkPolicyListAllOf } from '../models/HyperflexClusterNetworkPolicyListAllOf';
import { HyperflexClusterNetworkPolicyRelationship } from '../models/HyperflexClusterNetworkPolicyRelationship';
import { HyperflexClusterNetworkPolicyResponse } from '../models/HyperflexClusterNetworkPolicyResponse';
import { HyperflexClusterProfile } from '../models/HyperflexClusterProfile';
import { HyperflexClusterProfileAllOf } from '../models/HyperflexClusterProfileAllOf';
import { HyperflexClusterProfileList } from '../models/HyperflexClusterProfileList';
import { HyperflexClusterProfileListAllOf } from '../models/HyperflexClusterProfileListAllOf';
import { HyperflexClusterProfileRelationship } from '../models/HyperflexClusterProfileRelationship';
import { HyperflexClusterProfileResponse } from '../models/HyperflexClusterProfileResponse';
import { HyperflexClusterRelationship } from '../models/HyperflexClusterRelationship';
import { HyperflexClusterResponse } from '../models/HyperflexClusterResponse';
import { HyperflexClusterStoragePolicy } from '../models/HyperflexClusterStoragePolicy';
import { HyperflexClusterStoragePolicyAllOf } from '../models/HyperflexClusterStoragePolicyAllOf';
import { HyperflexClusterStoragePolicyList } from '../models/HyperflexClusterStoragePolicyList';
import { HyperflexClusterStoragePolicyListAllOf } from '../models/HyperflexClusterStoragePolicyListAllOf';
import { HyperflexClusterStoragePolicyRelationship } from '../models/HyperflexClusterStoragePolicyRelationship';
import { HyperflexClusterStoragePolicyResponse } from '../models/HyperflexClusterStoragePolicyResponse';
import { HyperflexConfigResult } from '../models/HyperflexConfigResult';
import { HyperflexConfigResultAllOf } from '../models/HyperflexConfigResultAllOf';
import { HyperflexConfigResultEntry } from '../models/HyperflexConfigResultEntry';
import { HyperflexConfigResultEntryAllOf } from '../models/HyperflexConfigResultEntryAllOf';
import { HyperflexConfigResultEntryList } from '../models/HyperflexConfigResultEntryList';
import { HyperflexConfigResultEntryListAllOf } from '../models/HyperflexConfigResultEntryListAllOf';
import { HyperflexConfigResultEntryRelationship } from '../models/HyperflexConfigResultEntryRelationship';
import { HyperflexConfigResultEntryResponse } from '../models/HyperflexConfigResultEntryResponse';
import { HyperflexConfigResultList } from '../models/HyperflexConfigResultList';
import { HyperflexConfigResultListAllOf } from '../models/HyperflexConfigResultListAllOf';
import { HyperflexConfigResultRelationship } from '../models/HyperflexConfigResultRelationship';
import { HyperflexConfigResultResponse } from '../models/HyperflexConfigResultResponse';
import { HyperflexExtFcStoragePolicy } from '../models/HyperflexExtFcStoragePolicy';
import { HyperflexExtFcStoragePolicyAllOf } from '../models/HyperflexExtFcStoragePolicyAllOf';
import { HyperflexExtFcStoragePolicyList } from '../models/HyperflexExtFcStoragePolicyList';
import { HyperflexExtFcStoragePolicyListAllOf } from '../models/HyperflexExtFcStoragePolicyListAllOf';
import { HyperflexExtFcStoragePolicyRelationship } from '../models/HyperflexExtFcStoragePolicyRelationship';
import { HyperflexExtFcStoragePolicyResponse } from '../models/HyperflexExtFcStoragePolicyResponse';
import { HyperflexExtIscsiStoragePolicy } from '../models/HyperflexExtIscsiStoragePolicy';
import { HyperflexExtIscsiStoragePolicyAllOf } from '../models/HyperflexExtIscsiStoragePolicyAllOf';
import { HyperflexExtIscsiStoragePolicyList } from '../models/HyperflexExtIscsiStoragePolicyList';
import { HyperflexExtIscsiStoragePolicyListAllOf } from '../models/HyperflexExtIscsiStoragePolicyListAllOf';
import { HyperflexExtIscsiStoragePolicyRelationship } from '../models/HyperflexExtIscsiStoragePolicyRelationship';
import { HyperflexExtIscsiStoragePolicyResponse } from '../models/HyperflexExtIscsiStoragePolicyResponse';
import { HyperflexFeatureLimitEntry } from '../models/HyperflexFeatureLimitEntry';
import { HyperflexFeatureLimitEntryAllOf } from '../models/HyperflexFeatureLimitEntryAllOf';
import { HyperflexFeatureLimitExternal } from '../models/HyperflexFeatureLimitExternal';
import { HyperflexFeatureLimitExternalAllOf } from '../models/HyperflexFeatureLimitExternalAllOf';
import { HyperflexFeatureLimitExternalList } from '../models/HyperflexFeatureLimitExternalList';
import { HyperflexFeatureLimitExternalListAllOf } from '../models/HyperflexFeatureLimitExternalListAllOf';
import { HyperflexFeatureLimitExternalRelationship } from '../models/HyperflexFeatureLimitExternalRelationship';
import { HyperflexFeatureLimitExternalResponse } from '../models/HyperflexFeatureLimitExternalResponse';
import { HyperflexFeatureLimitInternal } from '../models/HyperflexFeatureLimitInternal';
import { HyperflexFeatureLimitInternalAllOf } from '../models/HyperflexFeatureLimitInternalAllOf';
import { HyperflexFeatureLimitInternalList } from '../models/HyperflexFeatureLimitInternalList';
import { HyperflexFeatureLimitInternalListAllOf } from '../models/HyperflexFeatureLimitInternalListAllOf';
import { HyperflexFeatureLimitInternalRelationship } from '../models/HyperflexFeatureLimitInternalRelationship';
import { HyperflexFeatureLimitInternalResponse } from '../models/HyperflexFeatureLimitInternalResponse';
import { HyperflexHealth } from '../models/HyperflexHealth';
import { HyperflexHealthAllOf } from '../models/HyperflexHealthAllOf';
import { HyperflexHealthList } from '../models/HyperflexHealthList';
import { HyperflexHealthListAllOf } from '../models/HyperflexHealthListAllOf';
import { HyperflexHealthRelationship } from '../models/HyperflexHealthRelationship';
import { HyperflexHealthResponse } from '../models/HyperflexHealthResponse';
import { HyperflexHxLinkDt } from '../models/HyperflexHxLinkDt';
import { HyperflexHxLinkDtAllOf } from '../models/HyperflexHxLinkDtAllOf';
import { HyperflexHxNetworkAddressDt } from '../models/HyperflexHxNetworkAddressDt';
import { HyperflexHxNetworkAddressDtAllOf } from '../models/HyperflexHxNetworkAddressDtAllOf';
import { HyperflexHxResiliencyInfoDt } from '../models/HyperflexHxResiliencyInfoDt';
import { HyperflexHxResiliencyInfoDtAllOf } from '../models/HyperflexHxResiliencyInfoDtAllOf';
import { HyperflexHxUuIdDt } from '../models/HyperflexHxUuIdDt';
import { HyperflexHxUuIdDtAllOf } from '../models/HyperflexHxUuIdDtAllOf';
import { HyperflexHxZoneResiliencyInfoDt } from '../models/HyperflexHxZoneResiliencyInfoDt';
import { HyperflexHxZoneResiliencyInfoDtAllOf } from '../models/HyperflexHxZoneResiliencyInfoDtAllOf';
import { HyperflexHxdpVersion } from '../models/HyperflexHxdpVersion';
import { HyperflexHxdpVersionAllOf } from '../models/HyperflexHxdpVersionAllOf';
import { HyperflexHxdpVersionList } from '../models/HyperflexHxdpVersionList';
import { HyperflexHxdpVersionListAllOf } from '../models/HyperflexHxdpVersionListAllOf';
import { HyperflexHxdpVersionRelationship } from '../models/HyperflexHxdpVersionRelationship';
import { HyperflexHxdpVersionResponse } from '../models/HyperflexHxdpVersionResponse';
import { HyperflexIpAddrRange } from '../models/HyperflexIpAddrRange';
import { HyperflexIpAddrRangeAllOf } from '../models/HyperflexIpAddrRangeAllOf';
import { HyperflexLocalCredentialPolicy } from '../models/HyperflexLocalCredentialPolicy';
import { HyperflexLocalCredentialPolicyAllOf } from '../models/HyperflexLocalCredentialPolicyAllOf';
import { HyperflexLocalCredentialPolicyList } from '../models/HyperflexLocalCredentialPolicyList';
import { HyperflexLocalCredentialPolicyListAllOf } from '../models/HyperflexLocalCredentialPolicyListAllOf';
import { HyperflexLocalCredentialPolicyRelationship } from '../models/HyperflexLocalCredentialPolicyRelationship';
import { HyperflexLocalCredentialPolicyResponse } from '../models/HyperflexLocalCredentialPolicyResponse';
import { HyperflexLogicalAvailabilityZone } from '../models/HyperflexLogicalAvailabilityZone';
import { HyperflexLogicalAvailabilityZoneAllOf } from '../models/HyperflexLogicalAvailabilityZoneAllOf';
import { HyperflexMacAddrPrefixRange } from '../models/HyperflexMacAddrPrefixRange';
import { HyperflexMacAddrPrefixRangeAllOf } from '../models/HyperflexMacAddrPrefixRangeAllOf';
import { HyperflexNamedVlan } from '../models/HyperflexNamedVlan';
import { HyperflexNamedVlanAllOf } from '../models/HyperflexNamedVlanAllOf';
import { HyperflexNamedVsan } from '../models/HyperflexNamedVsan';
import { HyperflexNamedVsanAllOf } from '../models/HyperflexNamedVsanAllOf';
import { HyperflexNode } from '../models/HyperflexNode';
import { HyperflexNodeAllOf } from '../models/HyperflexNodeAllOf';
import { HyperflexNodeConfigPolicy } from '../models/HyperflexNodeConfigPolicy';
import { HyperflexNodeConfigPolicyAllOf } from '../models/HyperflexNodeConfigPolicyAllOf';
import { HyperflexNodeConfigPolicyList } from '../models/HyperflexNodeConfigPolicyList';
import { HyperflexNodeConfigPolicyListAllOf } from '../models/HyperflexNodeConfigPolicyListAllOf';
import { HyperflexNodeConfigPolicyRelationship } from '../models/HyperflexNodeConfigPolicyRelationship';
import { HyperflexNodeConfigPolicyResponse } from '../models/HyperflexNodeConfigPolicyResponse';
import { HyperflexNodeList } from '../models/HyperflexNodeList';
import { HyperflexNodeListAllOf } from '../models/HyperflexNodeListAllOf';
import { HyperflexNodeProfile } from '../models/HyperflexNodeProfile';
import { HyperflexNodeProfileAllOf } from '../models/HyperflexNodeProfileAllOf';
import { HyperflexNodeProfileList } from '../models/HyperflexNodeProfileList';
import { HyperflexNodeProfileListAllOf } from '../models/HyperflexNodeProfileListAllOf';
import { HyperflexNodeProfileRelationship } from '../models/HyperflexNodeProfileRelationship';
import { HyperflexNodeProfileResponse } from '../models/HyperflexNodeProfileResponse';
import { HyperflexNodeRelationship } from '../models/HyperflexNodeRelationship';
import { HyperflexNodeResponse } from '../models/HyperflexNodeResponse';
import { HyperflexProxySettingPolicy } from '../models/HyperflexProxySettingPolicy';
import { HyperflexProxySettingPolicyAllOf } from '../models/HyperflexProxySettingPolicyAllOf';
import { HyperflexProxySettingPolicyList } from '../models/HyperflexProxySettingPolicyList';
import { HyperflexProxySettingPolicyListAllOf } from '../models/HyperflexProxySettingPolicyListAllOf';
import { HyperflexProxySettingPolicyRelationship } from '../models/HyperflexProxySettingPolicyRelationship';
import { HyperflexProxySettingPolicyResponse } from '../models/HyperflexProxySettingPolicyResponse';
import { HyperflexServerFirmwareVersion } from '../models/HyperflexServerFirmwareVersion';
import { HyperflexServerFirmwareVersionAllOf } from '../models/HyperflexServerFirmwareVersionAllOf';
import { HyperflexServerFirmwareVersionEntry } from '../models/HyperflexServerFirmwareVersionEntry';
import { HyperflexServerFirmwareVersionEntryAllOf } from '../models/HyperflexServerFirmwareVersionEntryAllOf';
import { HyperflexServerFirmwareVersionList } from '../models/HyperflexServerFirmwareVersionList';
import { HyperflexServerFirmwareVersionListAllOf } from '../models/HyperflexServerFirmwareVersionListAllOf';
import { HyperflexServerFirmwareVersionRelationship } from '../models/HyperflexServerFirmwareVersionRelationship';
import { HyperflexServerFirmwareVersionResponse } from '../models/HyperflexServerFirmwareVersionResponse';
import { HyperflexServerModel } from '../models/HyperflexServerModel';
import { HyperflexServerModelAllOf } from '../models/HyperflexServerModelAllOf';
import { HyperflexServerModelEntry } from '../models/HyperflexServerModelEntry';
import { HyperflexServerModelEntryAllOf } from '../models/HyperflexServerModelEntryAllOf';
import { HyperflexServerModelList } from '../models/HyperflexServerModelList';
import { HyperflexServerModelListAllOf } from '../models/HyperflexServerModelListAllOf';
import { HyperflexServerModelRelationship } from '../models/HyperflexServerModelRelationship';
import { HyperflexServerModelResponse } from '../models/HyperflexServerModelResponse';
import { HyperflexSoftwareVersionPolicy } from '../models/HyperflexSoftwareVersionPolicy';
import { HyperflexSoftwareVersionPolicyAllOf } from '../models/HyperflexSoftwareVersionPolicyAllOf';
import { HyperflexSoftwareVersionPolicyList } from '../models/HyperflexSoftwareVersionPolicyList';
import { HyperflexSoftwareVersionPolicyListAllOf } from '../models/HyperflexSoftwareVersionPolicyListAllOf';
import { HyperflexSoftwareVersionPolicyRelationship } from '../models/HyperflexSoftwareVersionPolicyRelationship';
import { HyperflexSoftwareVersionPolicyResponse } from '../models/HyperflexSoftwareVersionPolicyResponse';
import { HyperflexStPlatformClusterHealingInfo } from '../models/HyperflexStPlatformClusterHealingInfo';
import { HyperflexStPlatformClusterHealingInfoAllOf } from '../models/HyperflexStPlatformClusterHealingInfoAllOf';
import { HyperflexStPlatformClusterResiliencyInfo } from '../models/HyperflexStPlatformClusterResiliencyInfo';
import { HyperflexStPlatformClusterResiliencyInfoAllOf } from '../models/HyperflexStPlatformClusterResiliencyInfoAllOf';
import { HyperflexSummary } from '../models/HyperflexSummary';
import { HyperflexSummaryAllOf } from '../models/HyperflexSummaryAllOf';
import { HyperflexSysConfigPolicy } from '../models/HyperflexSysConfigPolicy';
import { HyperflexSysConfigPolicyAllOf } from '../models/HyperflexSysConfigPolicyAllOf';
import { HyperflexSysConfigPolicyList } from '../models/HyperflexSysConfigPolicyList';
import { HyperflexSysConfigPolicyListAllOf } from '../models/HyperflexSysConfigPolicyListAllOf';
import { HyperflexSysConfigPolicyRelationship } from '../models/HyperflexSysConfigPolicyRelationship';
import { HyperflexSysConfigPolicyResponse } from '../models/HyperflexSysConfigPolicyResponse';
import { HyperflexUcsmConfigPolicy } from '../models/HyperflexUcsmConfigPolicy';
import { HyperflexUcsmConfigPolicyAllOf } from '../models/HyperflexUcsmConfigPolicyAllOf';
import { HyperflexUcsmConfigPolicyList } from '../models/HyperflexUcsmConfigPolicyList';
import { HyperflexUcsmConfigPolicyListAllOf } from '../models/HyperflexUcsmConfigPolicyListAllOf';
import { HyperflexUcsmConfigPolicyRelationship } from '../models/HyperflexUcsmConfigPolicyRelationship';
import { HyperflexUcsmConfigPolicyResponse } from '../models/HyperflexUcsmConfigPolicyResponse';
import { HyperflexVcenterConfigPolicy } from '../models/HyperflexVcenterConfigPolicy';
import { HyperflexVcenterConfigPolicyAllOf } from '../models/HyperflexVcenterConfigPolicyAllOf';
import { HyperflexVcenterConfigPolicyList } from '../models/HyperflexVcenterConfigPolicyList';
import { HyperflexVcenterConfigPolicyListAllOf } from '../models/HyperflexVcenterConfigPolicyListAllOf';
import { HyperflexVcenterConfigPolicyRelationship } from '../models/HyperflexVcenterConfigPolicyRelationship';
import { HyperflexVcenterConfigPolicyResponse } from '../models/HyperflexVcenterConfigPolicyResponse';
import { HyperflexWwxnPrefixRange } from '../models/HyperflexWwxnPrefixRange';
import { HyperflexWwxnPrefixRangeAllOf } from '../models/HyperflexWwxnPrefixRangeAllOf';
import { I18nMessage } from '../models/I18nMessage';
import { I18nMessageAllOf } from '../models/I18nMessageAllOf';
import { I18nMessageParam } from '../models/I18nMessageParam';
import { I18nMessageParamAllOf } from '../models/I18nMessageParamAllOf';
import { IaasConnectorPack } from '../models/IaasConnectorPack';
import { IaasConnectorPackAllOf } from '../models/IaasConnectorPackAllOf';
import { IaasConnectorPackList } from '../models/IaasConnectorPackList';
import { IaasConnectorPackListAllOf } from '../models/IaasConnectorPackListAllOf';
import { IaasConnectorPackRelationship } from '../models/IaasConnectorPackRelationship';
import { IaasConnectorPackResponse } from '../models/IaasConnectorPackResponse';
import { IaasDeviceStatus } from '../models/IaasDeviceStatus';
import { IaasDeviceStatusAllOf } from '../models/IaasDeviceStatusAllOf';
import { IaasDeviceStatusList } from '../models/IaasDeviceStatusList';
import { IaasDeviceStatusListAllOf } from '../models/IaasDeviceStatusListAllOf';
import { IaasDeviceStatusRelationship } from '../models/IaasDeviceStatusRelationship';
import { IaasDeviceStatusResponse } from '../models/IaasDeviceStatusResponse';
import { IaasLicenseInfo } from '../models/IaasLicenseInfo';
import { IaasLicenseInfoAllOf } from '../models/IaasLicenseInfoAllOf';
import { IaasLicenseInfoList } from '../models/IaasLicenseInfoList';
import { IaasLicenseInfoListAllOf } from '../models/IaasLicenseInfoListAllOf';
import { IaasLicenseInfoRelationship } from '../models/IaasLicenseInfoRelationship';
import { IaasLicenseInfoResponse } from '../models/IaasLicenseInfoResponse';
import { IaasLicenseKeysInfo } from '../models/IaasLicenseKeysInfo';
import { IaasLicenseKeysInfoAllOf } from '../models/IaasLicenseKeysInfoAllOf';
import { IaasLicenseUtilizationInfo } from '../models/IaasLicenseUtilizationInfo';
import { IaasLicenseUtilizationInfoAllOf } from '../models/IaasLicenseUtilizationInfoAllOf';
import { IaasMostRunTasks } from '../models/IaasMostRunTasks';
import { IaasMostRunTasksAllOf } from '../models/IaasMostRunTasksAllOf';
import { IaasMostRunTasksList } from '../models/IaasMostRunTasksList';
import { IaasMostRunTasksListAllOf } from '../models/IaasMostRunTasksListAllOf';
import { IaasMostRunTasksRelationship } from '../models/IaasMostRunTasksRelationship';
import { IaasMostRunTasksResponse } from '../models/IaasMostRunTasksResponse';
import { IaasUcsdInfo } from '../models/IaasUcsdInfo';
import { IaasUcsdInfoAllOf } from '../models/IaasUcsdInfoAllOf';
import { IaasUcsdInfoList } from '../models/IaasUcsdInfoList';
import { IaasUcsdInfoListAllOf } from '../models/IaasUcsdInfoListAllOf';
import { IaasUcsdInfoRelationship } from '../models/IaasUcsdInfoRelationship';
import { IaasUcsdInfoResponse } from '../models/IaasUcsdInfoResponse';
import { IaasUcsdManagedInfra } from '../models/IaasUcsdManagedInfra';
import { IaasUcsdManagedInfraAllOf } from '../models/IaasUcsdManagedInfraAllOf';
import { IaasUcsdManagedInfraList } from '../models/IaasUcsdManagedInfraList';
import { IaasUcsdManagedInfraListAllOf } from '../models/IaasUcsdManagedInfraListAllOf';
import { IaasUcsdManagedInfraRelationship } from '../models/IaasUcsdManagedInfraRelationship';
import { IaasUcsdManagedInfraResponse } from '../models/IaasUcsdManagedInfraResponse';
import { IamAccount } from '../models/IamAccount';
import { IamAccountAllOf } from '../models/IamAccountAllOf';
import { IamAccountExperience } from '../models/IamAccountExperience';
import { IamAccountExperienceAllOf } from '../models/IamAccountExperienceAllOf';
import { IamAccountExperienceList } from '../models/IamAccountExperienceList';
import { IamAccountExperienceListAllOf } from '../models/IamAccountExperienceListAllOf';
import { IamAccountExperienceResponse } from '../models/IamAccountExperienceResponse';
import { IamAccountList } from '../models/IamAccountList';
import { IamAccountListAllOf } from '../models/IamAccountListAllOf';
import { IamAccountPermissions } from '../models/IamAccountPermissions';
import { IamAccountPermissionsAllOf } from '../models/IamAccountPermissionsAllOf';
import { IamAccountRelationship } from '../models/IamAccountRelationship';
import { IamAccountResponse } from '../models/IamAccountResponse';
import { IamApiKey } from '../models/IamApiKey';
import { IamApiKeyAllOf } from '../models/IamApiKeyAllOf';
import { IamApiKeyList } from '../models/IamApiKeyList';
import { IamApiKeyListAllOf } from '../models/IamApiKeyListAllOf';
import { IamApiKeyRelationship } from '../models/IamApiKeyRelationship';
import { IamApiKeyResponse } from '../models/IamApiKeyResponse';
import { IamAppRegistration } from '../models/IamAppRegistration';
import { IamAppRegistrationAllOf } from '../models/IamAppRegistrationAllOf';
import { IamAppRegistrationList } from '../models/IamAppRegistrationList';
import { IamAppRegistrationListAllOf } from '../models/IamAppRegistrationListAllOf';
import { IamAppRegistrationRelationship } from '../models/IamAppRegistrationRelationship';
import { IamAppRegistrationResponse } from '../models/IamAppRegistrationResponse';
import { IamCertificate } from '../models/IamCertificate';
import { IamCertificateAllOf } from '../models/IamCertificateAllOf';
import { IamCertificateList } from '../models/IamCertificateList';
import { IamCertificateListAllOf } from '../models/IamCertificateListAllOf';
import { IamCertificateRelationship } from '../models/IamCertificateRelationship';
import { IamCertificateRequest } from '../models/IamCertificateRequest';
import { IamCertificateRequestAllOf } from '../models/IamCertificateRequestAllOf';
import { IamCertificateRequestList } from '../models/IamCertificateRequestList';
import { IamCertificateRequestListAllOf } from '../models/IamCertificateRequestListAllOf';
import { IamCertificateRequestRelationship } from '../models/IamCertificateRequestRelationship';
import { IamCertificateRequestResponse } from '../models/IamCertificateRequestResponse';
import { IamCertificateResponse } from '../models/IamCertificateResponse';
import { IamClientMeta } from '../models/IamClientMeta';
import { IamClientMetaAllOf } from '../models/IamClientMetaAllOf';
import { IamDomainGroup } from '../models/IamDomainGroup';
import { IamDomainGroupAllOf } from '../models/IamDomainGroupAllOf';
import { IamDomainGroupList } from '../models/IamDomainGroupList';
import { IamDomainGroupListAllOf } from '../models/IamDomainGroupListAllOf';
import { IamDomainGroupRelationship } from '../models/IamDomainGroupRelationship';
import { IamDomainGroupResponse } from '../models/IamDomainGroupResponse';
import { IamEndPointPasswordProperties } from '../models/IamEndPointPasswordProperties';
import { IamEndPointPasswordPropertiesAllOf } from '../models/IamEndPointPasswordPropertiesAllOf';
import { IamEndPointPrivilege } from '../models/IamEndPointPrivilege';
import { IamEndPointPrivilegeAllOf } from '../models/IamEndPointPrivilegeAllOf';
import { IamEndPointPrivilegeList } from '../models/IamEndPointPrivilegeList';
import { IamEndPointPrivilegeListAllOf } from '../models/IamEndPointPrivilegeListAllOf';
import { IamEndPointPrivilegeRelationship } from '../models/IamEndPointPrivilegeRelationship';
import { IamEndPointPrivilegeResponse } from '../models/IamEndPointPrivilegeResponse';
import { IamEndPointRole } from '../models/IamEndPointRole';
import { IamEndPointRoleAllOf } from '../models/IamEndPointRoleAllOf';
import { IamEndPointRoleList } from '../models/IamEndPointRoleList';
import { IamEndPointRoleListAllOf } from '../models/IamEndPointRoleListAllOf';
import { IamEndPointRoleRelationship } from '../models/IamEndPointRoleRelationship';
import { IamEndPointRoleResponse } from '../models/IamEndPointRoleResponse';
import { IamEndPointUser } from '../models/IamEndPointUser';
import { IamEndPointUserAllOf } from '../models/IamEndPointUserAllOf';
import { IamEndPointUserList } from '../models/IamEndPointUserList';
import { IamEndPointUserListAllOf } from '../models/IamEndPointUserListAllOf';
import { IamEndPointUserPolicy } from '../models/IamEndPointUserPolicy';
import { IamEndPointUserPolicyAllOf } from '../models/IamEndPointUserPolicyAllOf';
import { IamEndPointUserPolicyList } from '../models/IamEndPointUserPolicyList';
import { IamEndPointUserPolicyListAllOf } from '../models/IamEndPointUserPolicyListAllOf';
import { IamEndPointUserPolicyRelationship } from '../models/IamEndPointUserPolicyRelationship';
import { IamEndPointUserPolicyResponse } from '../models/IamEndPointUserPolicyResponse';
import { IamEndPointUserRelationship } from '../models/IamEndPointUserRelationship';
import { IamEndPointUserResponse } from '../models/IamEndPointUserResponse';
import { IamEndPointUserRole } from '../models/IamEndPointUserRole';
import { IamEndPointUserRoleAllOf } from '../models/IamEndPointUserRoleAllOf';
import { IamEndPointUserRoleList } from '../models/IamEndPointUserRoleList';
import { IamEndPointUserRoleListAllOf } from '../models/IamEndPointUserRoleListAllOf';
import { IamEndPointUserRoleRelationship } from '../models/IamEndPointUserRoleRelationship';
import { IamEndPointUserRoleResponse } from '../models/IamEndPointUserRoleResponse';
import { IamFeatureDefinition } from '../models/IamFeatureDefinition';
import { IamFeatureDefinitionAllOf } from '../models/IamFeatureDefinitionAllOf';
import { IamGroupPermissionToRoles } from '../models/IamGroupPermissionToRoles';
import { IamGroupPermissionToRolesAllOf } from '../models/IamGroupPermissionToRolesAllOf';
import { IamIdp } from '../models/IamIdp';
import { IamIdpAllOf } from '../models/IamIdpAllOf';
import { IamIdpList } from '../models/IamIdpList';
import { IamIdpListAllOf } from '../models/IamIdpListAllOf';
import { IamIdpReference } from '../models/IamIdpReference';
import { IamIdpReferenceAllOf } from '../models/IamIdpReferenceAllOf';
import { IamIdpReferenceList } from '../models/IamIdpReferenceList';
import { IamIdpReferenceListAllOf } from '../models/IamIdpReferenceListAllOf';
import { IamIdpReferenceRelationship } from '../models/IamIdpReferenceRelationship';
import { IamIdpReferenceResponse } from '../models/IamIdpReferenceResponse';
import { IamIdpRelationship } from '../models/IamIdpRelationship';
import { IamIdpResponse } from '../models/IamIdpResponse';
import { IamLdapBaseProperties } from '../models/IamLdapBaseProperties';
import { IamLdapBasePropertiesAllOf } from '../models/IamLdapBasePropertiesAllOf';
import { IamLdapDnsParameters } from '../models/IamLdapDnsParameters';
import { IamLdapDnsParametersAllOf } from '../models/IamLdapDnsParametersAllOf';
import { IamLdapGroup } from '../models/IamLdapGroup';
import { IamLdapGroupAllOf } from '../models/IamLdapGroupAllOf';
import { IamLdapGroupList } from '../models/IamLdapGroupList';
import { IamLdapGroupListAllOf } from '../models/IamLdapGroupListAllOf';
import { IamLdapGroupRelationship } from '../models/IamLdapGroupRelationship';
import { IamLdapGroupResponse } from '../models/IamLdapGroupResponse';
import { IamLdapPolicy } from '../models/IamLdapPolicy';
import { IamLdapPolicyAllOf } from '../models/IamLdapPolicyAllOf';
import { IamLdapPolicyList } from '../models/IamLdapPolicyList';
import { IamLdapPolicyListAllOf } from '../models/IamLdapPolicyListAllOf';
import { IamLdapPolicyRelationship } from '../models/IamLdapPolicyRelationship';
import { IamLdapPolicyResponse } from '../models/IamLdapPolicyResponse';
import { IamLdapProvider } from '../models/IamLdapProvider';
import { IamLdapProviderAllOf } from '../models/IamLdapProviderAllOf';
import { IamLdapProviderList } from '../models/IamLdapProviderList';
import { IamLdapProviderListAllOf } from '../models/IamLdapProviderListAllOf';
import { IamLdapProviderRelationship } from '../models/IamLdapProviderRelationship';
import { IamLdapProviderResponse } from '../models/IamLdapProviderResponse';
import { IamLocalUserPassword } from '../models/IamLocalUserPassword';
import { IamLocalUserPasswordAllOf } from '../models/IamLocalUserPasswordAllOf';
import { IamLocalUserPasswordRelationship } from '../models/IamLocalUserPasswordRelationship';
import { IamOAuthToken } from '../models/IamOAuthToken';
import { IamOAuthTokenAllOf } from '../models/IamOAuthTokenAllOf';
import { IamOAuthTokenList } from '../models/IamOAuthTokenList';
import { IamOAuthTokenListAllOf } from '../models/IamOAuthTokenListAllOf';
import { IamOAuthTokenRelationship } from '../models/IamOAuthTokenRelationship';
import { IamOAuthTokenResponse } from '../models/IamOAuthTokenResponse';
import { IamPermission } from '../models/IamPermission';
import { IamPermissionAllOf } from '../models/IamPermissionAllOf';
import { IamPermissionList } from '../models/IamPermissionList';
import { IamPermissionListAllOf } from '../models/IamPermissionListAllOf';
import { IamPermissionReference } from '../models/IamPermissionReference';
import { IamPermissionReferenceAllOf } from '../models/IamPermissionReferenceAllOf';
import { IamPermissionRelationship } from '../models/IamPermissionRelationship';
import { IamPermissionResponse } from '../models/IamPermissionResponse';
import { IamPermissionToRoles } from '../models/IamPermissionToRoles';
import { IamPermissionToRolesAllOf } from '../models/IamPermissionToRolesAllOf';
import { IamPrivateKeySpec } from '../models/IamPrivateKeySpec';
import { IamPrivateKeySpecAllOf } from '../models/IamPrivateKeySpecAllOf';
import { IamPrivateKeySpecList } from '../models/IamPrivateKeySpecList';
import { IamPrivateKeySpecListAllOf } from '../models/IamPrivateKeySpecListAllOf';
import { IamPrivateKeySpecRelationship } from '../models/IamPrivateKeySpecRelationship';
import { IamPrivateKeySpecResponse } from '../models/IamPrivateKeySpecResponse';
import { IamPrivilege } from '../models/IamPrivilege';
import { IamPrivilegeAllOf } from '../models/IamPrivilegeAllOf';
import { IamPrivilegeList } from '../models/IamPrivilegeList';
import { IamPrivilegeListAllOf } from '../models/IamPrivilegeListAllOf';
import { IamPrivilegeRelationship } from '../models/IamPrivilegeRelationship';
import { IamPrivilegeResponse } from '../models/IamPrivilegeResponse';
import { IamPrivilegeSet } from '../models/IamPrivilegeSet';
import { IamPrivilegeSetAllOf } from '../models/IamPrivilegeSetAllOf';
import { IamPrivilegeSetList } from '../models/IamPrivilegeSetList';
import { IamPrivilegeSetListAllOf } from '../models/IamPrivilegeSetListAllOf';
import { IamPrivilegeSetRelationship } from '../models/IamPrivilegeSetRelationship';
import { IamPrivilegeSetResponse } from '../models/IamPrivilegeSetResponse';
import { IamQualifier } from '../models/IamQualifier';
import { IamQualifierAllOf } from '../models/IamQualifierAllOf';
import { IamQualifierList } from '../models/IamQualifierList';
import { IamQualifierListAllOf } from '../models/IamQualifierListAllOf';
import { IamQualifierRelationship } from '../models/IamQualifierRelationship';
import { IamQualifierResponse } from '../models/IamQualifierResponse';
import { IamResourceLimits } from '../models/IamResourceLimits';
import { IamResourceLimitsAllOf } from '../models/IamResourceLimitsAllOf';
import { IamResourceLimitsList } from '../models/IamResourceLimitsList';
import { IamResourceLimitsListAllOf } from '../models/IamResourceLimitsListAllOf';
import { IamResourceLimitsRelationship } from '../models/IamResourceLimitsRelationship';
import { IamResourceLimitsResponse } from '../models/IamResourceLimitsResponse';
import { IamResourcePermission } from '../models/IamResourcePermission';
import { IamResourcePermissionAllOf } from '../models/IamResourcePermissionAllOf';
import { IamResourcePermissionList } from '../models/IamResourcePermissionList';
import { IamResourcePermissionListAllOf } from '../models/IamResourcePermissionListAllOf';
import { IamResourcePermissionRelationship } from '../models/IamResourcePermissionRelationship';
import { IamResourcePermissionResponse } from '../models/IamResourcePermissionResponse';
import { IamResourceRoles } from '../models/IamResourceRoles';
import { IamResourceRolesAllOf } from '../models/IamResourceRolesAllOf';
import { IamResourceRolesList } from '../models/IamResourceRolesList';
import { IamResourceRolesListAllOf } from '../models/IamResourceRolesListAllOf';
import { IamResourceRolesRelationship } from '../models/IamResourceRolesRelationship';
import { IamResourceRolesResponse } from '../models/IamResourceRolesResponse';
import { IamRole } from '../models/IamRole';
import { IamRoleAllOf } from '../models/IamRoleAllOf';
import { IamRoleList } from '../models/IamRoleList';
import { IamRoleListAllOf } from '../models/IamRoleListAllOf';
import { IamRoleRelationship } from '../models/IamRoleRelationship';
import { IamRoleResponse } from '../models/IamRoleResponse';
import { IamSecurityHolder } from '../models/IamSecurityHolder';
import { IamSecurityHolderAllOf } from '../models/IamSecurityHolderAllOf';
import { IamSecurityHolderList } from '../models/IamSecurityHolderList';
import { IamSecurityHolderListAllOf } from '../models/IamSecurityHolderListAllOf';
import { IamSecurityHolderRelationship } from '../models/IamSecurityHolderRelationship';
import { IamSecurityHolderResponse } from '../models/IamSecurityHolderResponse';
import { IamServiceProvider } from '../models/IamServiceProvider';
import { IamServiceProviderAllOf } from '../models/IamServiceProviderAllOf';
import { IamServiceProviderList } from '../models/IamServiceProviderList';
import { IamServiceProviderListAllOf } from '../models/IamServiceProviderListAllOf';
import { IamServiceProviderRelationship } from '../models/IamServiceProviderRelationship';
import { IamServiceProviderResponse } from '../models/IamServiceProviderResponse';
import { IamSession } from '../models/IamSession';
import { IamSessionAllOf } from '../models/IamSessionAllOf';
import { IamSessionLimits } from '../models/IamSessionLimits';
import { IamSessionLimitsAllOf } from '../models/IamSessionLimitsAllOf';
import { IamSessionLimitsList } from '../models/IamSessionLimitsList';
import { IamSessionLimitsListAllOf } from '../models/IamSessionLimitsListAllOf';
import { IamSessionLimitsRelationship } from '../models/IamSessionLimitsRelationship';
import { IamSessionLimitsResponse } from '../models/IamSessionLimitsResponse';
import { IamSessionList } from '../models/IamSessionList';
import { IamSessionListAllOf } from '../models/IamSessionListAllOf';
import { IamSessionRelationship } from '../models/IamSessionRelationship';
import { IamSessionResponse } from '../models/IamSessionResponse';
import { IamSsoSessionAttributes } from '../models/IamSsoSessionAttributes';
import { IamSsoSessionAttributesAllOf } from '../models/IamSsoSessionAttributesAllOf';
import { IamSystem } from '../models/IamSystem';
import { IamSystemAllOf } from '../models/IamSystemAllOf';
import { IamSystemList } from '../models/IamSystemList';
import { IamSystemListAllOf } from '../models/IamSystemListAllOf';
import { IamSystemRelationship } from '../models/IamSystemRelationship';
import { IamSystemResponse } from '../models/IamSystemResponse';
import { IamTrustPoint } from '../models/IamTrustPoint';
import { IamTrustPointAllOf } from '../models/IamTrustPointAllOf';
import { IamTrustPointList } from '../models/IamTrustPointList';
import { IamTrustPointListAllOf } from '../models/IamTrustPointListAllOf';
import { IamTrustPointResponse } from '../models/IamTrustPointResponse';
import { IamUser } from '../models/IamUser';
import { IamUserAllOf } from '../models/IamUserAllOf';
import { IamUserGroup } from '../models/IamUserGroup';
import { IamUserGroupAllOf } from '../models/IamUserGroupAllOf';
import { IamUserGroupList } from '../models/IamUserGroupList';
import { IamUserGroupListAllOf } from '../models/IamUserGroupListAllOf';
import { IamUserGroupRelationship } from '../models/IamUserGroupRelationship';
import { IamUserGroupResponse } from '../models/IamUserGroupResponse';
import { IamUserList } from '../models/IamUserList';
import { IamUserListAllOf } from '../models/IamUserListAllOf';
import { IamUserPreference } from '../models/IamUserPreference';
import { IamUserPreferenceAllOf } from '../models/IamUserPreferenceAllOf';
import { IamUserPreferenceList } from '../models/IamUserPreferenceList';
import { IamUserPreferenceListAllOf } from '../models/IamUserPreferenceListAllOf';
import { IamUserPreferenceRelationship } from '../models/IamUserPreferenceRelationship';
import { IamUserPreferenceResponse } from '../models/IamUserPreferenceResponse';
import { IamUserRelationship } from '../models/IamUserRelationship';
import { IamUserResponse } from '../models/IamUserResponse';
import { InfraHardwareInfo } from '../models/InfraHardwareInfo';
import { InfraHardwareInfoAllOf } from '../models/InfraHardwareInfoAllOf';
import { InventoryBase } from '../models/InventoryBase';
import { InventoryBaseAllOf } from '../models/InventoryBaseAllOf';
import { InventoryBaseRelationship } from '../models/InventoryBaseRelationship';
import { InventoryDeviceInfo } from '../models/InventoryDeviceInfo';
import { InventoryDeviceInfoList } from '../models/InventoryDeviceInfoList';
import { InventoryDeviceInfoListAllOf } from '../models/InventoryDeviceInfoListAllOf';
import { InventoryDeviceInfoResponse } from '../models/InventoryDeviceInfoResponse';
import { InventoryDnMoBinding } from '../models/InventoryDnMoBinding';
import { InventoryDnMoBindingAllOf } from '../models/InventoryDnMoBindingAllOf';
import { InventoryDnMoBindingList } from '../models/InventoryDnMoBindingList';
import { InventoryDnMoBindingListAllOf } from '../models/InventoryDnMoBindingListAllOf';
import { InventoryDnMoBindingResponse } from '../models/InventoryDnMoBindingResponse';
import { InventoryGenericInventory } from '../models/InventoryGenericInventory';
import { InventoryGenericInventoryAllOf } from '../models/InventoryGenericInventoryAllOf';
import { InventoryGenericInventoryHolder } from '../models/InventoryGenericInventoryHolder';
import { InventoryGenericInventoryHolderAllOf } from '../models/InventoryGenericInventoryHolderAllOf';
import { InventoryGenericInventoryHolderList } from '../models/InventoryGenericInventoryHolderList';
import { InventoryGenericInventoryHolderListAllOf } from '../models/InventoryGenericInventoryHolderListAllOf';
import { InventoryGenericInventoryHolderRelationship } from '../models/InventoryGenericInventoryHolderRelationship';
import { InventoryGenericInventoryHolderResponse } from '../models/InventoryGenericInventoryHolderResponse';
import { InventoryGenericInventoryList } from '../models/InventoryGenericInventoryList';
import { InventoryGenericInventoryListAllOf } from '../models/InventoryGenericInventoryListAllOf';
import { InventoryGenericInventoryRelationship } from '../models/InventoryGenericInventoryRelationship';
import { InventoryGenericInventoryResponse } from '../models/InventoryGenericInventoryResponse';
import { InventoryInventoryMo } from '../models/InventoryInventoryMo';
import { InventoryInventoryMoAllOf } from '../models/InventoryInventoryMoAllOf';
import { InventoryRequest } from '../models/InventoryRequest';
import { InventoryRequestAllOf } from '../models/InventoryRequestAllOf';
import { IpmioverlanPolicy } from '../models/IpmioverlanPolicy';
import { IpmioverlanPolicyAllOf } from '../models/IpmioverlanPolicyAllOf';
import { IpmioverlanPolicyList } from '../models/IpmioverlanPolicyList';
import { IpmioverlanPolicyListAllOf } from '../models/IpmioverlanPolicyListAllOf';
import { IpmioverlanPolicyResponse } from '../models/IpmioverlanPolicyResponse';
import { KvmKvmSession } from '../models/KvmKvmSession';
import { KvmKvmSessionAllOf } from '../models/KvmKvmSessionAllOf';
import { KvmKvmSessionList } from '../models/KvmKvmSessionList';
import { KvmKvmSessionListAllOf } from '../models/KvmKvmSessionListAllOf';
import { KvmKvmSessionResponse } from '../models/KvmKvmSessionResponse';
import { KvmPolicy } from '../models/KvmPolicy';
import { KvmPolicyAllOf } from '../models/KvmPolicyAllOf';
import { KvmPolicyList } from '../models/KvmPolicyList';
import { KvmPolicyListAllOf } from '../models/KvmPolicyListAllOf';
import { KvmPolicyResponse } from '../models/KvmPolicyResponse';
import { LicenseAccountLicenseData } from '../models/LicenseAccountLicenseData';
import { LicenseAccountLicenseDataAllOf } from '../models/LicenseAccountLicenseDataAllOf';
import { LicenseAccountLicenseDataList } from '../models/LicenseAccountLicenseDataList';
import { LicenseAccountLicenseDataListAllOf } from '../models/LicenseAccountLicenseDataListAllOf';
import { LicenseAccountLicenseDataRelationship } from '../models/LicenseAccountLicenseDataRelationship';
import { LicenseAccountLicenseDataResponse } from '../models/LicenseAccountLicenseDataResponse';
import { LicenseCustomerOp } from '../models/LicenseCustomerOp';
import { LicenseCustomerOpAllOf } from '../models/LicenseCustomerOpAllOf';
import { LicenseCustomerOpList } from '../models/LicenseCustomerOpList';
import { LicenseCustomerOpListAllOf } from '../models/LicenseCustomerOpListAllOf';
import { LicenseCustomerOpRelationship } from '../models/LicenseCustomerOpRelationship';
import { LicenseCustomerOpResponse } from '../models/LicenseCustomerOpResponse';
import { LicenseLicenseInfo } from '../models/LicenseLicenseInfo';
import { LicenseLicenseInfoAllOf } from '../models/LicenseLicenseInfoAllOf';
import { LicenseLicenseInfoList } from '../models/LicenseLicenseInfoList';
import { LicenseLicenseInfoListAllOf } from '../models/LicenseLicenseInfoListAllOf';
import { LicenseLicenseInfoRelationship } from '../models/LicenseLicenseInfoRelationship';
import { LicenseLicenseInfoResponse } from '../models/LicenseLicenseInfoResponse';
import { LicenseSmartlicenseToken } from '../models/LicenseSmartlicenseToken';
import { LicenseSmartlicenseTokenAllOf } from '../models/LicenseSmartlicenseTokenAllOf';
import { LicenseSmartlicenseTokenList } from '../models/LicenseSmartlicenseTokenList';
import { LicenseSmartlicenseTokenListAllOf } from '../models/LicenseSmartlicenseTokenListAllOf';
import { LicenseSmartlicenseTokenRelationship } from '../models/LicenseSmartlicenseTokenRelationship';
import { LicenseSmartlicenseTokenResponse } from '../models/LicenseSmartlicenseTokenResponse';
import { LsServiceProfile } from '../models/LsServiceProfile';
import { LsServiceProfileAllOf } from '../models/LsServiceProfileAllOf';
import { LsServiceProfileList } from '../models/LsServiceProfileList';
import { LsServiceProfileListAllOf } from '../models/LsServiceProfileListAllOf';
import { LsServiceProfileResponse } from '../models/LsServiceProfileResponse';
import { ManagementController } from '../models/ManagementController';
import { ManagementControllerAllOf } from '../models/ManagementControllerAllOf';
import { ManagementControllerList } from '../models/ManagementControllerList';
import { ManagementControllerListAllOf } from '../models/ManagementControllerListAllOf';
import { ManagementControllerRelationship } from '../models/ManagementControllerRelationship';
import { ManagementControllerResponse } from '../models/ManagementControllerResponse';
import { ManagementEntity } from '../models/ManagementEntity';
import { ManagementEntityAllOf } from '../models/ManagementEntityAllOf';
import { ManagementEntityList } from '../models/ManagementEntityList';
import { ManagementEntityListAllOf } from '../models/ManagementEntityListAllOf';
import { ManagementEntityRelationship } from '../models/ManagementEntityRelationship';
import { ManagementEntityResponse } from '../models/ManagementEntityResponse';
import { ManagementInterface } from '../models/ManagementInterface';
import { ManagementInterfaceAllOf } from '../models/ManagementInterfaceAllOf';
import { ManagementInterfaceList } from '../models/ManagementInterfaceList';
import { ManagementInterfaceListAllOf } from '../models/ManagementInterfaceListAllOf';
import { ManagementInterfaceRelationship } from '../models/ManagementInterfaceRelationship';
import { ManagementInterfaceResponse } from '../models/ManagementInterfaceResponse';
import { MemoryAbstractUnit } from '../models/MemoryAbstractUnit';
import { MemoryAbstractUnitAllOf } from '../models/MemoryAbstractUnitAllOf';
import { MemoryArray } from '../models/MemoryArray';
import { MemoryArrayAllOf } from '../models/MemoryArrayAllOf';
import { MemoryArrayList } from '../models/MemoryArrayList';
import { MemoryArrayListAllOf } from '../models/MemoryArrayListAllOf';
import { MemoryArrayRelationship } from '../models/MemoryArrayRelationship';
import { MemoryArrayResponse } from '../models/MemoryArrayResponse';
import { MemoryPersistentMemoryConfigResult } from '../models/MemoryPersistentMemoryConfigResult';
import { MemoryPersistentMemoryConfigResultAllOf } from '../models/MemoryPersistentMemoryConfigResultAllOf';
import { MemoryPersistentMemoryConfigResultList } from '../models/MemoryPersistentMemoryConfigResultList';
import { MemoryPersistentMemoryConfigResultListAllOf } from '../models/MemoryPersistentMemoryConfigResultListAllOf';
import { MemoryPersistentMemoryConfigResultRelationship } from '../models/MemoryPersistentMemoryConfigResultRelationship';
import { MemoryPersistentMemoryConfigResultResponse } from '../models/MemoryPersistentMemoryConfigResultResponse';
import { MemoryPersistentMemoryConfiguration } from '../models/MemoryPersistentMemoryConfiguration';
import { MemoryPersistentMemoryConfigurationAllOf } from '../models/MemoryPersistentMemoryConfigurationAllOf';
import { MemoryPersistentMemoryConfigurationList } from '../models/MemoryPersistentMemoryConfigurationList';
import { MemoryPersistentMemoryConfigurationListAllOf } from '../models/MemoryPersistentMemoryConfigurationListAllOf';
import { MemoryPersistentMemoryConfigurationRelationship } from '../models/MemoryPersistentMemoryConfigurationRelationship';
import { MemoryPersistentMemoryConfigurationResponse } from '../models/MemoryPersistentMemoryConfigurationResponse';
import { MemoryPersistentMemoryGoal } from '../models/MemoryPersistentMemoryGoal';
import { MemoryPersistentMemoryGoalAllOf } from '../models/MemoryPersistentMemoryGoalAllOf';
import { MemoryPersistentMemoryLocalSecurity } from '../models/MemoryPersistentMemoryLocalSecurity';
import { MemoryPersistentMemoryLocalSecurityAllOf } from '../models/MemoryPersistentMemoryLocalSecurityAllOf';
import { MemoryPersistentMemoryLogicalNamespace } from '../models/MemoryPersistentMemoryLogicalNamespace';
import { MemoryPersistentMemoryLogicalNamespaceAllOf } from '../models/MemoryPersistentMemoryLogicalNamespaceAllOf';
import { MemoryPersistentMemoryNamespace } from '../models/MemoryPersistentMemoryNamespace';
import { MemoryPersistentMemoryNamespaceAllOf } from '../models/MemoryPersistentMemoryNamespaceAllOf';
import { MemoryPersistentMemoryNamespaceConfigResult } from '../models/MemoryPersistentMemoryNamespaceConfigResult';
import { MemoryPersistentMemoryNamespaceConfigResultAllOf } from '../models/MemoryPersistentMemoryNamespaceConfigResultAllOf';
import { MemoryPersistentMemoryNamespaceConfigResultList } from '../models/MemoryPersistentMemoryNamespaceConfigResultList';
import { MemoryPersistentMemoryNamespaceConfigResultListAllOf } from '../models/MemoryPersistentMemoryNamespaceConfigResultListAllOf';
import { MemoryPersistentMemoryNamespaceConfigResultRelationship } from '../models/MemoryPersistentMemoryNamespaceConfigResultRelationship';
import { MemoryPersistentMemoryNamespaceConfigResultResponse } from '../models/MemoryPersistentMemoryNamespaceConfigResultResponse';
import { MemoryPersistentMemoryNamespaceList } from '../models/MemoryPersistentMemoryNamespaceList';
import { MemoryPersistentMemoryNamespaceListAllOf } from '../models/MemoryPersistentMemoryNamespaceListAllOf';
import { MemoryPersistentMemoryNamespaceRelationship } from '../models/MemoryPersistentMemoryNamespaceRelationship';
import { MemoryPersistentMemoryNamespaceResponse } from '../models/MemoryPersistentMemoryNamespaceResponse';
import { MemoryPersistentMemoryPolicy } from '../models/MemoryPersistentMemoryPolicy';
import { MemoryPersistentMemoryPolicyAllOf } from '../models/MemoryPersistentMemoryPolicyAllOf';
import { MemoryPersistentMemoryPolicyList } from '../models/MemoryPersistentMemoryPolicyList';
import { MemoryPersistentMemoryPolicyListAllOf } from '../models/MemoryPersistentMemoryPolicyListAllOf';
import { MemoryPersistentMemoryPolicyResponse } from '../models/MemoryPersistentMemoryPolicyResponse';
import { MemoryPersistentMemoryRegion } from '../models/MemoryPersistentMemoryRegion';
import { MemoryPersistentMemoryRegionAllOf } from '../models/MemoryPersistentMemoryRegionAllOf';
import { MemoryPersistentMemoryRegionList } from '../models/MemoryPersistentMemoryRegionList';
import { MemoryPersistentMemoryRegionListAllOf } from '../models/MemoryPersistentMemoryRegionListAllOf';
import { MemoryPersistentMemoryRegionRelationship } from '../models/MemoryPersistentMemoryRegionRelationship';
import { MemoryPersistentMemoryRegionResponse } from '../models/MemoryPersistentMemoryRegionResponse';
import { MemoryPersistentMemoryUnit } from '../models/MemoryPersistentMemoryUnit';
import { MemoryPersistentMemoryUnitAllOf } from '../models/MemoryPersistentMemoryUnitAllOf';
import { MemoryPersistentMemoryUnitList } from '../models/MemoryPersistentMemoryUnitList';
import { MemoryPersistentMemoryUnitListAllOf } from '../models/MemoryPersistentMemoryUnitListAllOf';
import { MemoryPersistentMemoryUnitRelationship } from '../models/MemoryPersistentMemoryUnitRelationship';
import { MemoryPersistentMemoryUnitResponse } from '../models/MemoryPersistentMemoryUnitResponse';
import { MemoryUnit } from '../models/MemoryUnit';
import { MemoryUnitAllOf } from '../models/MemoryUnitAllOf';
import { MemoryUnitList } from '../models/MemoryUnitList';
import { MemoryUnitListAllOf } from '../models/MemoryUnitListAllOf';
import { MemoryUnitRelationship } from '../models/MemoryUnitRelationship';
import { MemoryUnitResponse } from '../models/MemoryUnitResponse';
import { MetaAccessPrivilege } from '../models/MetaAccessPrivilege';
import { MetaAccessPrivilegeAllOf } from '../models/MetaAccessPrivilegeAllOf';
import { MetaDefinition } from '../models/MetaDefinition';
import { MetaDefinitionAllOf } from '../models/MetaDefinitionAllOf';
import { MetaDefinitionList } from '../models/MetaDefinitionList';
import { MetaDefinitionListAllOf } from '../models/MetaDefinitionListAllOf';
import { MetaDefinitionResponse } from '../models/MetaDefinitionResponse';
import { MetaPropDefinition } from '../models/MetaPropDefinition';
import { MetaPropDefinitionAllOf } from '../models/MetaPropDefinitionAllOf';
import { MetaRelationshipDefinition } from '../models/MetaRelationshipDefinition';
import { MetaRelationshipDefinitionAllOf } from '../models/MetaRelationshipDefinitionAllOf';
import { MoBaseComplexType } from '../models/MoBaseComplexType';
import { MoBaseMo } from '../models/MoBaseMo';
import { MoBaseMoRelationship } from '../models/MoBaseMoRelationship';
import { MoBaseResponse } from '../models/MoBaseResponse';
import { MoDocumentCount } from '../models/MoDocumentCount';
import { MoDocumentCountAllOf } from '../models/MoDocumentCountAllOf';
import { MoMoRef } from '../models/MoMoRef';
import { MoMoRefAllOf } from '../models/MoMoRefAllOf';
import { MoTag } from '../models/MoTag';
import { MoTagKeySummary } from '../models/MoTagKeySummary';
import { MoVersionContext } from '../models/MoVersionContext';
import { MoVersionContextAllOf } from '../models/MoVersionContextAllOf';
import { ModelError } from '../models/ModelError';
import { NetworkElement } from '../models/NetworkElement';
import { NetworkElementAllOf } from '../models/NetworkElementAllOf';
import { NetworkElementList } from '../models/NetworkElementList';
import { NetworkElementListAllOf } from '../models/NetworkElementListAllOf';
import { NetworkElementRelationship } from '../models/NetworkElementRelationship';
import { NetworkElementResponse } from '../models/NetworkElementResponse';
import { NetworkElementSummary } from '../models/NetworkElementSummary';
import { NetworkElementSummaryAllOf } from '../models/NetworkElementSummaryAllOf';
import { NetworkElementSummaryList } from '../models/NetworkElementSummaryList';
import { NetworkElementSummaryListAllOf } from '../models/NetworkElementSummaryListAllOf';
import { NetworkElementSummaryResponse } from '../models/NetworkElementSummaryResponse';
import { NetworkconfigPolicy } from '../models/NetworkconfigPolicy';
import { NetworkconfigPolicyAllOf } from '../models/NetworkconfigPolicyAllOf';
import { NetworkconfigPolicyList } from '../models/NetworkconfigPolicyList';
import { NetworkconfigPolicyListAllOf } from '../models/NetworkconfigPolicyListAllOf';
import { NetworkconfigPolicyResponse } from '../models/NetworkconfigPolicyResponse';
import { NiaapiApicCcoPost } from '../models/NiaapiApicCcoPost';
import { NiaapiApicCcoPostList } from '../models/NiaapiApicCcoPostList';
import { NiaapiApicCcoPostListAllOf } from '../models/NiaapiApicCcoPostListAllOf';
import { NiaapiApicCcoPostResponse } from '../models/NiaapiApicCcoPostResponse';
import { NiaapiApicFieldNotice } from '../models/NiaapiApicFieldNotice';
import { NiaapiApicFieldNoticeList } from '../models/NiaapiApicFieldNoticeList';
import { NiaapiApicFieldNoticeListAllOf } from '../models/NiaapiApicFieldNoticeListAllOf';
import { NiaapiApicFieldNoticeResponse } from '../models/NiaapiApicFieldNoticeResponse';
import { NiaapiApicHweol } from '../models/NiaapiApicHweol';
import { NiaapiApicHweolList } from '../models/NiaapiApicHweolList';
import { NiaapiApicHweolListAllOf } from '../models/NiaapiApicHweolListAllOf';
import { NiaapiApicHweolResponse } from '../models/NiaapiApicHweolResponse';
import { NiaapiApicLatestMaintainedRelease } from '../models/NiaapiApicLatestMaintainedRelease';
import { NiaapiApicLatestMaintainedReleaseList } from '../models/NiaapiApicLatestMaintainedReleaseList';
import { NiaapiApicLatestMaintainedReleaseListAllOf } from '../models/NiaapiApicLatestMaintainedReleaseListAllOf';
import { NiaapiApicLatestMaintainedReleaseResponse } from '../models/NiaapiApicLatestMaintainedReleaseResponse';
import { NiaapiApicReleaseRecommend } from '../models/NiaapiApicReleaseRecommend';
import { NiaapiApicReleaseRecommendList } from '../models/NiaapiApicReleaseRecommendList';
import { NiaapiApicReleaseRecommendListAllOf } from '../models/NiaapiApicReleaseRecommendListAllOf';
import { NiaapiApicReleaseRecommendResponse } from '../models/NiaapiApicReleaseRecommendResponse';
import { NiaapiApicSweol } from '../models/NiaapiApicSweol';
import { NiaapiApicSweolList } from '../models/NiaapiApicSweolList';
import { NiaapiApicSweolListAllOf } from '../models/NiaapiApicSweolListAllOf';
import { NiaapiApicSweolResponse } from '../models/NiaapiApicSweolResponse';
import { NiaapiDcnmCcoPost } from '../models/NiaapiDcnmCcoPost';
import { NiaapiDcnmCcoPostList } from '../models/NiaapiDcnmCcoPostList';
import { NiaapiDcnmCcoPostListAllOf } from '../models/NiaapiDcnmCcoPostListAllOf';
import { NiaapiDcnmCcoPostResponse } from '../models/NiaapiDcnmCcoPostResponse';
import { NiaapiDcnmFieldNotice } from '../models/NiaapiDcnmFieldNotice';
import { NiaapiDcnmFieldNoticeList } from '../models/NiaapiDcnmFieldNoticeList';
import { NiaapiDcnmFieldNoticeListAllOf } from '../models/NiaapiDcnmFieldNoticeListAllOf';
import { NiaapiDcnmFieldNoticeResponse } from '../models/NiaapiDcnmFieldNoticeResponse';
import { NiaapiDcnmHweol } from '../models/NiaapiDcnmHweol';
import { NiaapiDcnmHweolList } from '../models/NiaapiDcnmHweolList';
import { NiaapiDcnmHweolListAllOf } from '../models/NiaapiDcnmHweolListAllOf';
import { NiaapiDcnmHweolResponse } from '../models/NiaapiDcnmHweolResponse';
import { NiaapiDcnmLatestMaintainedRelease } from '../models/NiaapiDcnmLatestMaintainedRelease';
import { NiaapiDcnmLatestMaintainedReleaseList } from '../models/NiaapiDcnmLatestMaintainedReleaseList';
import { NiaapiDcnmLatestMaintainedReleaseListAllOf } from '../models/NiaapiDcnmLatestMaintainedReleaseListAllOf';
import { NiaapiDcnmLatestMaintainedReleaseResponse } from '../models/NiaapiDcnmLatestMaintainedReleaseResponse';
import { NiaapiDcnmReleaseRecommend } from '../models/NiaapiDcnmReleaseRecommend';
import { NiaapiDcnmReleaseRecommendList } from '../models/NiaapiDcnmReleaseRecommendList';
import { NiaapiDcnmReleaseRecommendListAllOf } from '../models/NiaapiDcnmReleaseRecommendListAllOf';
import { NiaapiDcnmReleaseRecommendResponse } from '../models/NiaapiDcnmReleaseRecommendResponse';
import { NiaapiDcnmSweol } from '../models/NiaapiDcnmSweol';
import { NiaapiDcnmSweolList } from '../models/NiaapiDcnmSweolList';
import { NiaapiDcnmSweolListAllOf } from '../models/NiaapiDcnmSweolListAllOf';
import { NiaapiDcnmSweolResponse } from '../models/NiaapiDcnmSweolResponse';
import { NiaapiDetail } from '../models/NiaapiDetail';
import { NiaapiDetailAllOf } from '../models/NiaapiDetailAllOf';
import { NiaapiFieldNotice } from '../models/NiaapiFieldNotice';
import { NiaapiFieldNoticeAllOf } from '../models/NiaapiFieldNoticeAllOf';
import { NiaapiFileDownloader } from '../models/NiaapiFileDownloader';
import { NiaapiFileDownloaderAllOf } from '../models/NiaapiFileDownloaderAllOf';
import { NiaapiFileDownloaderList } from '../models/NiaapiFileDownloaderList';
import { NiaapiFileDownloaderListAllOf } from '../models/NiaapiFileDownloaderListAllOf';
import { NiaapiFileDownloaderResponse } from '../models/NiaapiFileDownloaderResponse';
import { NiaapiHardwareEol } from '../models/NiaapiHardwareEol';
import { NiaapiHardwareEolAllOf } from '../models/NiaapiHardwareEolAllOf';
import { NiaapiMaintainedRelease } from '../models/NiaapiMaintainedRelease';
import { NiaapiMaintainedReleaseAllOf } from '../models/NiaapiMaintainedReleaseAllOf';
import { NiaapiNewReleaseDetail } from '../models/NiaapiNewReleaseDetail';
import { NiaapiNewReleaseDetailAllOf } from '../models/NiaapiNewReleaseDetailAllOf';
import { NiaapiNewReleasePost } from '../models/NiaapiNewReleasePost';
import { NiaapiNewReleasePostAllOf } from '../models/NiaapiNewReleasePostAllOf';
import { NiaapiNiaMetadata } from '../models/NiaapiNiaMetadata';
import { NiaapiNiaMetadataAllOf } from '../models/NiaapiNiaMetadataAllOf';
import { NiaapiNiaMetadataList } from '../models/NiaapiNiaMetadataList';
import { NiaapiNiaMetadataListAllOf } from '../models/NiaapiNiaMetadataListAllOf';
import { NiaapiNiaMetadataResponse } from '../models/NiaapiNiaMetadataResponse';
import { NiaapiReleaseRecommend } from '../models/NiaapiReleaseRecommend';
import { NiaapiReleaseRecommendAllOf } from '../models/NiaapiReleaseRecommendAllOf';
import { NiaapiRevisionInfo } from '../models/NiaapiRevisionInfo';
import { NiaapiRevisionInfoAllOf } from '../models/NiaapiRevisionInfoAllOf';
import { NiaapiSoftwareEol } from '../models/NiaapiSoftwareEol';
import { NiaapiSoftwareEolAllOf } from '../models/NiaapiSoftwareEolAllOf';
import { NiaapiSoftwareRegex } from '../models/NiaapiSoftwareRegex';
import { NiaapiSoftwareRegexAllOf } from '../models/NiaapiSoftwareRegexAllOf';
import { NiaapiVersionRegex } from '../models/NiaapiVersionRegex';
import { NiaapiVersionRegexAllOf } from '../models/NiaapiVersionRegexAllOf';
import { NiaapiVersionRegexList } from '../models/NiaapiVersionRegexList';
import { NiaapiVersionRegexListAllOf } from '../models/NiaapiVersionRegexListAllOf';
import { NiaapiVersionRegexPlatform } from '../models/NiaapiVersionRegexPlatform';
import { NiaapiVersionRegexPlatformAllOf } from '../models/NiaapiVersionRegexPlatformAllOf';
import { NiaapiVersionRegexResponse } from '../models/NiaapiVersionRegexResponse';
import { NiatelemetryDiskinfo } from '../models/NiatelemetryDiskinfo';
import { NiatelemetryDiskinfoAllOf } from '../models/NiatelemetryDiskinfoAllOf';
import { NiatelemetryNiaFeatureUsage } from '../models/NiatelemetryNiaFeatureUsage';
import { NiatelemetryNiaFeatureUsageAllOf } from '../models/NiatelemetryNiaFeatureUsageAllOf';
import { NiatelemetryNiaFeatureUsageList } from '../models/NiatelemetryNiaFeatureUsageList';
import { NiatelemetryNiaFeatureUsageListAllOf } from '../models/NiatelemetryNiaFeatureUsageListAllOf';
import { NiatelemetryNiaFeatureUsageResponse } from '../models/NiatelemetryNiaFeatureUsageResponse';
import { NiatelemetryNiaInventory } from '../models/NiatelemetryNiaInventory';
import { NiatelemetryNiaInventoryAllOf } from '../models/NiatelemetryNiaInventoryAllOf';
import { NiatelemetryNiaInventoryList } from '../models/NiatelemetryNiaInventoryList';
import { NiatelemetryNiaInventoryListAllOf } from '../models/NiatelemetryNiaInventoryListAllOf';
import { NiatelemetryNiaInventoryRelationship } from '../models/NiatelemetryNiaInventoryRelationship';
import { NiatelemetryNiaInventoryResponse } from '../models/NiatelemetryNiaInventoryResponse';
import { NiatelemetryNiaLicenseState } from '../models/NiatelemetryNiaLicenseState';
import { NiatelemetryNiaLicenseStateAllOf } from '../models/NiatelemetryNiaLicenseStateAllOf';
import { NiatelemetryNiaLicenseStateList } from '../models/NiatelemetryNiaLicenseStateList';
import { NiatelemetryNiaLicenseStateListAllOf } from '../models/NiatelemetryNiaLicenseStateListAllOf';
import { NiatelemetryNiaLicenseStateRelationship } from '../models/NiatelemetryNiaLicenseStateRelationship';
import { NiatelemetryNiaLicenseStateResponse } from '../models/NiatelemetryNiaLicenseStateResponse';
import { NtpPolicy } from '../models/NtpPolicy';
import { NtpPolicyAllOf } from '../models/NtpPolicyAllOf';
import { NtpPolicyList } from '../models/NtpPolicyList';
import { NtpPolicyListAllOf } from '../models/NtpPolicyListAllOf';
import { NtpPolicyResponse } from '../models/NtpPolicyResponse';
import { OnpremImagePackage } from '../models/OnpremImagePackage';
import { OnpremImagePackageAllOf } from '../models/OnpremImagePackageAllOf';
import { OnpremSchedule } from '../models/OnpremSchedule';
import { OnpremScheduleAllOf } from '../models/OnpremScheduleAllOf';
import { OnpremUpgradeNote } from '../models/OnpremUpgradeNote';
import { OnpremUpgradeNoteAllOf } from '../models/OnpremUpgradeNoteAllOf';
import { OnpremUpgradePhase } from '../models/OnpremUpgradePhase';
import { OnpremUpgradePhaseAllOf } from '../models/OnpremUpgradePhaseAllOf';
import { OrganizationOrganization } from '../models/OrganizationOrganization';
import { OrganizationOrganizationAllOf } from '../models/OrganizationOrganizationAllOf';
import { OrganizationOrganizationList } from '../models/OrganizationOrganizationList';
import { OrganizationOrganizationListAllOf } from '../models/OrganizationOrganizationListAllOf';
import { OrganizationOrganizationRelationship } from '../models/OrganizationOrganizationRelationship';
import { OrganizationOrganizationResponse } from '../models/OrganizationOrganizationResponse';
import { OsAnswers } from '../models/OsAnswers';
import { OsAnswersAllOf } from '../models/OsAnswersAllOf';
import { OsBaseInstallConfig } from '../models/OsBaseInstallConfig';
import { OsBaseInstallConfigAllOf } from '../models/OsBaseInstallConfigAllOf';
import { OsCatalog } from '../models/OsCatalog';
import { OsCatalogAllOf } from '../models/OsCatalogAllOf';
import { OsCatalogList } from '../models/OsCatalogList';
import { OsCatalogListAllOf } from '../models/OsCatalogListAllOf';
import { OsCatalogRelationship } from '../models/OsCatalogRelationship';
import { OsCatalogResponse } from '../models/OsCatalogResponse';
import { OsConfigurationFile } from '../models/OsConfigurationFile';
import { OsConfigurationFileAllOf } from '../models/OsConfigurationFileAllOf';
import { OsConfigurationFileList } from '../models/OsConfigurationFileList';
import { OsConfigurationFileListAllOf } from '../models/OsConfigurationFileListAllOf';
import { OsConfigurationFileRelationship } from '../models/OsConfigurationFileRelationship';
import { OsConfigurationFileResponse } from '../models/OsConfigurationFileResponse';
import { OsInstall } from '../models/OsInstall';
import { OsInstallAllOf } from '../models/OsInstallAllOf';
import { OsInstallList } from '../models/OsInstallList';
import { OsInstallListAllOf } from '../models/OsInstallListAllOf';
import { OsInstallResponse } from '../models/OsInstallResponse';
import { OsOperatingSystemParameters } from '../models/OsOperatingSystemParameters';
import { OsOsSupport } from '../models/OsOsSupport';
import { OsOsSupportAllOf } from '../models/OsOsSupportAllOf';
import { OsPlaceHolder } from '../models/OsPlaceHolder';
import { OsPlaceHolderAllOf } from '../models/OsPlaceHolderAllOf';
import { OsTemplateFile } from '../models/OsTemplateFile';
import { OsTemplateFileAllOf } from '../models/OsTemplateFileAllOf';
import { OsWindowsParameters } from '../models/OsWindowsParameters';
import { OsWindowsParametersAllOf } from '../models/OsWindowsParametersAllOf';
import { PatchDocument } from '../models/PatchDocument';
import { PciCoprocessorCard } from '../models/PciCoprocessorCard';
import { PciCoprocessorCardAllOf } from '../models/PciCoprocessorCardAllOf';
import { PciCoprocessorCardList } from '../models/PciCoprocessorCardList';
import { PciCoprocessorCardListAllOf } from '../models/PciCoprocessorCardListAllOf';
import { PciCoprocessorCardRelationship } from '../models/PciCoprocessorCardRelationship';
import { PciCoprocessorCardResponse } from '../models/PciCoprocessorCardResponse';
import { PciDevice } from '../models/PciDevice';
import { PciDeviceAllOf } from '../models/PciDeviceAllOf';
import { PciDeviceList } from '../models/PciDeviceList';
import { PciDeviceListAllOf } from '../models/PciDeviceListAllOf';
import { PciDeviceRelationship } from '../models/PciDeviceRelationship';
import { PciDeviceResponse } from '../models/PciDeviceResponse';
import { PciLink } from '../models/PciLink';
import { PciLinkAllOf } from '../models/PciLinkAllOf';
import { PciLinkList } from '../models/PciLinkList';
import { PciLinkListAllOf } from '../models/PciLinkListAllOf';
import { PciLinkRelationship } from '../models/PciLinkRelationship';
import { PciLinkResponse } from '../models/PciLinkResponse';
import { PciSwitch } from '../models/PciSwitch';
import { PciSwitchAllOf } from '../models/PciSwitchAllOf';
import { PciSwitchList } from '../models/PciSwitchList';
import { PciSwitchListAllOf } from '../models/PciSwitchListAllOf';
import { PciSwitchRelationship } from '../models/PciSwitchRelationship';
import { PciSwitchResponse } from '../models/PciSwitchResponse';
import { PkixDistinguishedName } from '../models/PkixDistinguishedName';
import { PkixDistinguishedNameAllOf } from '../models/PkixDistinguishedNameAllOf';
import { PkixEcdsaKeySpec } from '../models/PkixEcdsaKeySpec';
import { PkixEcdsaKeySpecAllOf } from '../models/PkixEcdsaKeySpecAllOf';
import { PkixEddsaKeySpec } from '../models/PkixEddsaKeySpec';
import { PkixEddsaKeySpecAllOf } from '../models/PkixEddsaKeySpecAllOf';
import { PkixKeyGenerationSpec } from '../models/PkixKeyGenerationSpec';
import { PkixKeyGenerationSpecAllOf } from '../models/PkixKeyGenerationSpecAllOf';
import { PkixRsaAlgorithm } from '../models/PkixRsaAlgorithm';
import { PkixRsaAlgorithmAllOf } from '../models/PkixRsaAlgorithmAllOf';
import { PkixSubjectAlternateName } from '../models/PkixSubjectAlternateName';
import { PkixSubjectAlternateNameAllOf } from '../models/PkixSubjectAlternateNameAllOf';
import { PolicyAbstractConfigChangeDetail } from '../models/PolicyAbstractConfigChangeDetail';
import { PolicyAbstractConfigChangeDetailAllOf } from '../models/PolicyAbstractConfigChangeDetailAllOf';
import { PolicyAbstractConfigProfile } from '../models/PolicyAbstractConfigProfile';
import { PolicyAbstractConfigProfileAllOf } from '../models/PolicyAbstractConfigProfileAllOf';
import { PolicyAbstractConfigProfileRelationship } from '../models/PolicyAbstractConfigProfileRelationship';
import { PolicyAbstractConfigResult } from '../models/PolicyAbstractConfigResult';
import { PolicyAbstractConfigResultAllOf } from '../models/PolicyAbstractConfigResultAllOf';
import { PolicyAbstractConfigResultEntry } from '../models/PolicyAbstractConfigResultEntry';
import { PolicyAbstractConfigResultEntryAllOf } from '../models/PolicyAbstractConfigResultEntryAllOf';
import { PolicyAbstractPolicy } from '../models/PolicyAbstractPolicy';
import { PolicyAbstractPolicyAllOf } from '../models/PolicyAbstractPolicyAllOf';
import { PolicyAbstractProfile } from '../models/PolicyAbstractProfile';
import { PolicyAbstractProfileAllOf } from '../models/PolicyAbstractProfileAllOf';
import { PolicyAbstractProfileRelationship } from '../models/PolicyAbstractProfileRelationship';
import { PolicyConfigChange } from '../models/PolicyConfigChange';
import { PolicyConfigChangeAllOf } from '../models/PolicyConfigChangeAllOf';
import { PolicyConfigContext } from '../models/PolicyConfigContext';
import { PolicyConfigContextAllOf } from '../models/PolicyConfigContextAllOf';
import { PolicyConfigResultContext } from '../models/PolicyConfigResultContext';
import { PolicyConfigResultContextAllOf } from '../models/PolicyConfigResultContextAllOf';
import { PolicyinventoryAbstractDeviceInfo } from '../models/PolicyinventoryAbstractDeviceInfo';
import { PolicyinventoryAbstractDeviceInfoAllOf } from '../models/PolicyinventoryAbstractDeviceInfoAllOf';
import { PolicyinventoryJobInfo } from '../models/PolicyinventoryJobInfo';
import { PolicyinventoryJobInfoAllOf } from '../models/PolicyinventoryJobInfoAllOf';
import { PortGroup } from '../models/PortGroup';
import { PortGroupAllOf } from '../models/PortGroupAllOf';
import { PortGroupList } from '../models/PortGroupList';
import { PortGroupListAllOf } from '../models/PortGroupListAllOf';
import { PortGroupRelationship } from '../models/PortGroupRelationship';
import { PortGroupResponse } from '../models/PortGroupResponse';
import { PortPhysical } from '../models/PortPhysical';
import { PortPhysicalAllOf } from '../models/PortPhysicalAllOf';
import { PortSubGroup } from '../models/PortSubGroup';
import { PortSubGroupAllOf } from '../models/PortSubGroupAllOf';
import { PortSubGroupList } from '../models/PortSubGroupList';
import { PortSubGroupListAllOf } from '../models/PortSubGroupListAllOf';
import { PortSubGroupRelationship } from '../models/PortSubGroupRelationship';
import { PortSubGroupResponse } from '../models/PortSubGroupResponse';
import { ProcessorUnit } from '../models/ProcessorUnit';
import { ProcessorUnitAllOf } from '../models/ProcessorUnitAllOf';
import { ProcessorUnitList } from '../models/ProcessorUnitList';
import { ProcessorUnitListAllOf } from '../models/ProcessorUnitListAllOf';
import { ProcessorUnitRelationship } from '../models/ProcessorUnitRelationship';
import { ProcessorUnitResponse } from '../models/ProcessorUnitResponse';
import { RecoveryAbstractBackupConfig } from '../models/RecoveryAbstractBackupConfig';
import { RecoveryAbstractBackupConfigAllOf } from '../models/RecoveryAbstractBackupConfigAllOf';
import { RecoveryAbstractBackupInfo } from '../models/RecoveryAbstractBackupInfo';
import { RecoveryAbstractBackupInfoAllOf } from '../models/RecoveryAbstractBackupInfoAllOf';
import { RecoveryAbstractBackupInfoRelationship } from '../models/RecoveryAbstractBackupInfoRelationship';
import { RecoveryBackupConfigPolicy } from '../models/RecoveryBackupConfigPolicy';
import { RecoveryBackupConfigPolicyAllOf } from '../models/RecoveryBackupConfigPolicyAllOf';
import { RecoveryBackupConfigPolicyList } from '../models/RecoveryBackupConfigPolicyList';
import { RecoveryBackupConfigPolicyListAllOf } from '../models/RecoveryBackupConfigPolicyListAllOf';
import { RecoveryBackupConfigPolicyRelationship } from '../models/RecoveryBackupConfigPolicyRelationship';
import { RecoveryBackupConfigPolicyResponse } from '../models/RecoveryBackupConfigPolicyResponse';
import { RecoveryBackupProfile } from '../models/RecoveryBackupProfile';
import { RecoveryBackupProfileAllOf } from '../models/RecoveryBackupProfileAllOf';
import { RecoveryBackupProfileList } from '../models/RecoveryBackupProfileList';
import { RecoveryBackupProfileListAllOf } from '../models/RecoveryBackupProfileListAllOf';
import { RecoveryBackupProfileRelationship } from '../models/RecoveryBackupProfileRelationship';
import { RecoveryBackupProfileResponse } from '../models/RecoveryBackupProfileResponse';
import { RecoveryBackupSchedule } from '../models/RecoveryBackupSchedule';
import { RecoveryBackupScheduleAllOf } from '../models/RecoveryBackupScheduleAllOf';
import { RecoveryConfigParams } from '../models/RecoveryConfigParams';
import { RecoveryConfigResult } from '../models/RecoveryConfigResult';
import { RecoveryConfigResultAllOf } from '../models/RecoveryConfigResultAllOf';
import { RecoveryConfigResultEntry } from '../models/RecoveryConfigResultEntry';
import { RecoveryConfigResultEntryAllOf } from '../models/RecoveryConfigResultEntryAllOf';
import { RecoveryConfigResultEntryList } from '../models/RecoveryConfigResultEntryList';
import { RecoveryConfigResultEntryListAllOf } from '../models/RecoveryConfigResultEntryListAllOf';
import { RecoveryConfigResultEntryRelationship } from '../models/RecoveryConfigResultEntryRelationship';
import { RecoveryConfigResultEntryResponse } from '../models/RecoveryConfigResultEntryResponse';
import { RecoveryConfigResultList } from '../models/RecoveryConfigResultList';
import { RecoveryConfigResultListAllOf } from '../models/RecoveryConfigResultListAllOf';
import { RecoveryConfigResultRelationship } from '../models/RecoveryConfigResultRelationship';
import { RecoveryConfigResultResponse } from '../models/RecoveryConfigResultResponse';
import { RecoveryOnDemandBackup } from '../models/RecoveryOnDemandBackup';
import { RecoveryOnDemandBackupAllOf } from '../models/RecoveryOnDemandBackupAllOf';
import { RecoveryOnDemandBackupList } from '../models/RecoveryOnDemandBackupList';
import { RecoveryOnDemandBackupListAllOf } from '../models/RecoveryOnDemandBackupListAllOf';
import { RecoveryOnDemandBackupRelationship } from '../models/RecoveryOnDemandBackupRelationship';
import { RecoveryOnDemandBackupResponse } from '../models/RecoveryOnDemandBackupResponse';
import { RecoveryRestore } from '../models/RecoveryRestore';
import { RecoveryRestoreAllOf } from '../models/RecoveryRestoreAllOf';
import { RecoveryRestoreList } from '../models/RecoveryRestoreList';
import { RecoveryRestoreListAllOf } from '../models/RecoveryRestoreListAllOf';
import { RecoveryRestoreResponse } from '../models/RecoveryRestoreResponse';
import { RecoveryScheduleConfigPolicy } from '../models/RecoveryScheduleConfigPolicy';
import { RecoveryScheduleConfigPolicyAllOf } from '../models/RecoveryScheduleConfigPolicyAllOf';
import { RecoveryScheduleConfigPolicyList } from '../models/RecoveryScheduleConfigPolicyList';
import { RecoveryScheduleConfigPolicyListAllOf } from '../models/RecoveryScheduleConfigPolicyListAllOf';
import { RecoveryScheduleConfigPolicyRelationship } from '../models/RecoveryScheduleConfigPolicyRelationship';
import { RecoveryScheduleConfigPolicyResponse } from '../models/RecoveryScheduleConfigPolicyResponse';
import { ResourceGroup } from '../models/ResourceGroup';
import { ResourceGroupAllOf } from '../models/ResourceGroupAllOf';
import { ResourceGroupList } from '../models/ResourceGroupList';
import { ResourceGroupListAllOf } from '../models/ResourceGroupListAllOf';
import { ResourceGroupMember } from '../models/ResourceGroupMember';
import { ResourceGroupMemberAllOf } from '../models/ResourceGroupMemberAllOf';
import { ResourceGroupMemberList } from '../models/ResourceGroupMemberList';
import { ResourceGroupMemberListAllOf } from '../models/ResourceGroupMemberListAllOf';
import { ResourceGroupMemberResponse } from '../models/ResourceGroupMemberResponse';
import { ResourceGroupRelationship } from '../models/ResourceGroupRelationship';
import { ResourceGroupResponse } from '../models/ResourceGroupResponse';
import { ResourceLicenseResourceCount } from '../models/ResourceLicenseResourceCount';
import { ResourceLicenseResourceCountAllOf } from '../models/ResourceLicenseResourceCountAllOf';
import { ResourceLicenseResourceCountList } from '../models/ResourceLicenseResourceCountList';
import { ResourceLicenseResourceCountListAllOf } from '../models/ResourceLicenseResourceCountListAllOf';
import { ResourceLicenseResourceCountResponse } from '../models/ResourceLicenseResourceCountResponse';
import { ResourceMembership } from '../models/ResourceMembership';
import { ResourceMembershipAllOf } from '../models/ResourceMembershipAllOf';
import { ResourceMembershipHolder } from '../models/ResourceMembershipHolder';
import { ResourceMembershipHolderAllOf } from '../models/ResourceMembershipHolderAllOf';
import { ResourceMembershipHolderList } from '../models/ResourceMembershipHolderList';
import { ResourceMembershipHolderListAllOf } from '../models/ResourceMembershipHolderListAllOf';
import { ResourceMembershipHolderRelationship } from '../models/ResourceMembershipHolderRelationship';
import { ResourceMembershipHolderResponse } from '../models/ResourceMembershipHolderResponse';
import { ResourceMembershipList } from '../models/ResourceMembershipList';
import { ResourceMembershipListAllOf } from '../models/ResourceMembershipListAllOf';
import { ResourceMembershipRelationship } from '../models/ResourceMembershipRelationship';
import { ResourceMembershipResponse } from '../models/ResourceMembershipResponse';
import { ResourcePerTypeCombinedSelector } from '../models/ResourcePerTypeCombinedSelector';
import { ResourcePerTypeCombinedSelectorAllOf } from '../models/ResourcePerTypeCombinedSelectorAllOf';
import { ResourceSelector } from '../models/ResourceSelector';
import { ResourceSelectorAllOf } from '../models/ResourceSelectorAllOf';
import { SdcardDiagnostics } from '../models/SdcardDiagnostics';
import { SdcardDrivers } from '../models/SdcardDrivers';
import { SdcardHostUpgradeUtility } from '../models/SdcardHostUpgradeUtility';
import { SdcardOperatingSystem } from '../models/SdcardOperatingSystem';
import { SdcardOperatingSystemAllOf } from '../models/SdcardOperatingSystemAllOf';
import { SdcardPartition } from '../models/SdcardPartition';
import { SdcardPartitionAllOf } from '../models/SdcardPartitionAllOf';
import { SdcardPolicy } from '../models/SdcardPolicy';
import { SdcardPolicyAllOf } from '../models/SdcardPolicyAllOf';
import { SdcardPolicyList } from '../models/SdcardPolicyList';
import { SdcardPolicyListAllOf } from '../models/SdcardPolicyListAllOf';
import { SdcardPolicyResponse } from '../models/SdcardPolicyResponse';
import { SdcardServerConfigurationUtility } from '../models/SdcardServerConfigurationUtility';
import { SdcardUserPartition } from '../models/SdcardUserPartition';
import { SdcardUserPartitionAllOf } from '../models/SdcardUserPartitionAllOf';
import { SdcardVirtualDrive } from '../models/SdcardVirtualDrive';
import { SdcardVirtualDriveAllOf } from '../models/SdcardVirtualDriveAllOf';
import { SdwanNetworkConfigurationType } from '../models/SdwanNetworkConfigurationType';
import { SdwanNetworkConfigurationTypeAllOf } from '../models/SdwanNetworkConfigurationTypeAllOf';
import { SdwanProfile } from '../models/SdwanProfile';
import { SdwanProfileAllOf } from '../models/SdwanProfileAllOf';
import { SdwanProfileList } from '../models/SdwanProfileList';
import { SdwanProfileListAllOf } from '../models/SdwanProfileListAllOf';
import { SdwanProfileRelationship } from '../models/SdwanProfileRelationship';
import { SdwanProfileResponse } from '../models/SdwanProfileResponse';
import { SdwanRouterNode } from '../models/SdwanRouterNode';
import { SdwanRouterNodeAllOf } from '../models/SdwanRouterNodeAllOf';
import { SdwanRouterNodeList } from '../models/SdwanRouterNodeList';
import { SdwanRouterNodeListAllOf } from '../models/SdwanRouterNodeListAllOf';
import { SdwanRouterNodeRelationship } from '../models/SdwanRouterNodeRelationship';
import { SdwanRouterNodeResponse } from '../models/SdwanRouterNodeResponse';
import { SdwanRouterPolicy } from '../models/SdwanRouterPolicy';
import { SdwanRouterPolicyAllOf } from '../models/SdwanRouterPolicyAllOf';
import { SdwanRouterPolicyList } from '../models/SdwanRouterPolicyList';
import { SdwanRouterPolicyListAllOf } from '../models/SdwanRouterPolicyListAllOf';
import { SdwanRouterPolicyRelationship } from '../models/SdwanRouterPolicyRelationship';
import { SdwanRouterPolicyResponse } from '../models/SdwanRouterPolicyResponse';
import { SdwanTemplateInputsType } from '../models/SdwanTemplateInputsType';
import { SdwanTemplateInputsTypeAllOf } from '../models/SdwanTemplateInputsTypeAllOf';
import { SdwanVmanageAccountPolicy } from '../models/SdwanVmanageAccountPolicy';
import { SdwanVmanageAccountPolicyAllOf } from '../models/SdwanVmanageAccountPolicyAllOf';
import { SdwanVmanageAccountPolicyList } from '../models/SdwanVmanageAccountPolicyList';
import { SdwanVmanageAccountPolicyListAllOf } from '../models/SdwanVmanageAccountPolicyListAllOf';
import { SdwanVmanageAccountPolicyRelationship } from '../models/SdwanVmanageAccountPolicyRelationship';
import { SdwanVmanageAccountPolicyResponse } from '../models/SdwanVmanageAccountPolicyResponse';
import { SearchSearchItem } from '../models/SearchSearchItem';
import { SearchSearchItemList } from '../models/SearchSearchItemList';
import { SearchSearchItemListAllOf } from '../models/SearchSearchItemListAllOf';
import { SearchSearchItemResponse } from '../models/SearchSearchItemResponse';
import { SearchSuggestItem } from '../models/SearchSuggestItem';
import { SearchSuggestItemAllOf } from '../models/SearchSuggestItemAllOf';
import { SearchTagItem } from '../models/SearchTagItem';
import { SearchTagItemList } from '../models/SearchTagItemList';
import { SearchTagItemListAllOf } from '../models/SearchTagItemListAllOf';
import { SearchTagItemResponse } from '../models/SearchTagItemResponse';
import { SecurityUnit } from '../models/SecurityUnit';
import { SecurityUnitAllOf } from '../models/SecurityUnitAllOf';
import { SecurityUnitList } from '../models/SecurityUnitList';
import { SecurityUnitListAllOf } from '../models/SecurityUnitListAllOf';
import { SecurityUnitRelationship } from '../models/SecurityUnitRelationship';
import { SecurityUnitResponse } from '../models/SecurityUnitResponse';
import { ServerConfigChangeDetail } from '../models/ServerConfigChangeDetail';
import { ServerConfigChangeDetailAllOf } from '../models/ServerConfigChangeDetailAllOf';
import { ServerConfigChangeDetailList } from '../models/ServerConfigChangeDetailList';
import { ServerConfigChangeDetailListAllOf } from '../models/ServerConfigChangeDetailListAllOf';
import { ServerConfigChangeDetailRelationship } from '../models/ServerConfigChangeDetailRelationship';
import { ServerConfigChangeDetailResponse } from '../models/ServerConfigChangeDetailResponse';
import { ServerConfigImport } from '../models/ServerConfigImport';
import { ServerConfigImportAllOf } from '../models/ServerConfigImportAllOf';
import { ServerConfigImportList } from '../models/ServerConfigImportList';
import { ServerConfigImportListAllOf } from '../models/ServerConfigImportListAllOf';
import { ServerConfigImportResponse } from '../models/ServerConfigImportResponse';
import { ServerConfigResult } from '../models/ServerConfigResult';
import { ServerConfigResultAllOf } from '../models/ServerConfigResultAllOf';
import { ServerConfigResultEntry } from '../models/ServerConfigResultEntry';
import { ServerConfigResultEntryAllOf } from '../models/ServerConfigResultEntryAllOf';
import { ServerConfigResultEntryList } from '../models/ServerConfigResultEntryList';
import { ServerConfigResultEntryListAllOf } from '../models/ServerConfigResultEntryListAllOf';
import { ServerConfigResultEntryRelationship } from '../models/ServerConfigResultEntryRelationship';
import { ServerConfigResultEntryResponse } from '../models/ServerConfigResultEntryResponse';
import { ServerConfigResultList } from '../models/ServerConfigResultList';
import { ServerConfigResultListAllOf } from '../models/ServerConfigResultListAllOf';
import { ServerConfigResultRelationship } from '../models/ServerConfigResultRelationship';
import { ServerConfigResultResponse } from '../models/ServerConfigResultResponse';
import { ServerProfile } from '../models/ServerProfile';
import { ServerProfileAllOf } from '../models/ServerProfileAllOf';
import { ServerProfileList } from '../models/ServerProfileList';
import { ServerProfileListAllOf } from '../models/ServerProfileListAllOf';
import { ServerProfileRelationship } from '../models/ServerProfileRelationship';
import { ServerProfileResponse } from '../models/ServerProfileResponse';
import { SmtpPolicy } from '../models/SmtpPolicy';
import { SmtpPolicyAllOf } from '../models/SmtpPolicyAllOf';
import { SmtpPolicyList } from '../models/SmtpPolicyList';
import { SmtpPolicyListAllOf } from '../models/SmtpPolicyListAllOf';
import { SmtpPolicyResponse } from '../models/SmtpPolicyResponse';
import { SnmpPolicy } from '../models/SnmpPolicy';
import { SnmpPolicyAllOf } from '../models/SnmpPolicyAllOf';
import { SnmpPolicyList } from '../models/SnmpPolicyList';
import { SnmpPolicyListAllOf } from '../models/SnmpPolicyListAllOf';
import { SnmpPolicyResponse } from '../models/SnmpPolicyResponse';
import { SnmpTrap } from '../models/SnmpTrap';
import { SnmpTrapAllOf } from '../models/SnmpTrapAllOf';
import { SnmpUser } from '../models/SnmpUser';
import { SnmpUserAllOf } from '../models/SnmpUserAllOf';
import { SoftwareHclMeta } from '../models/SoftwareHclMeta';
import { SoftwareHclMetaAllOf } from '../models/SoftwareHclMetaAllOf';
import { SoftwareHclMetaList } from '../models/SoftwareHclMetaList';
import { SoftwareHclMetaListAllOf } from '../models/SoftwareHclMetaListAllOf';
import { SoftwareHclMetaResponse } from '../models/SoftwareHclMetaResponse';
import { SoftwareHyperflexDistributable } from '../models/SoftwareHyperflexDistributable';
import { SoftwareHyperflexDistributableAllOf } from '../models/SoftwareHyperflexDistributableAllOf';
import { SoftwareHyperflexDistributableList } from '../models/SoftwareHyperflexDistributableList';
import { SoftwareHyperflexDistributableListAllOf } from '../models/SoftwareHyperflexDistributableListAllOf';
import { SoftwareHyperflexDistributableRelationship } from '../models/SoftwareHyperflexDistributableRelationship';
import { SoftwareHyperflexDistributableResponse } from '../models/SoftwareHyperflexDistributableResponse';
import { SoftwareSolutionDistributable } from '../models/SoftwareSolutionDistributable';
import { SoftwareSolutionDistributableAllOf } from '../models/SoftwareSolutionDistributableAllOf';
import { SoftwareSolutionDistributableList } from '../models/SoftwareSolutionDistributableList';
import { SoftwareSolutionDistributableListAllOf } from '../models/SoftwareSolutionDistributableListAllOf';
import { SoftwareSolutionDistributableRelationship } from '../models/SoftwareSolutionDistributableRelationship';
import { SoftwareSolutionDistributableResponse } from '../models/SoftwareSolutionDistributableResponse';
import { SoftwarerepositoryAuthorization } from '../models/SoftwarerepositoryAuthorization';
import { SoftwarerepositoryAuthorizationAllOf } from '../models/SoftwarerepositoryAuthorizationAllOf';
import { SoftwarerepositoryAuthorizationList } from '../models/SoftwarerepositoryAuthorizationList';
import { SoftwarerepositoryAuthorizationListAllOf } from '../models/SoftwarerepositoryAuthorizationListAllOf';
import { SoftwarerepositoryAuthorizationResponse } from '../models/SoftwarerepositoryAuthorizationResponse';
import { SoftwarerepositoryCatalog } from '../models/SoftwarerepositoryCatalog';
import { SoftwarerepositoryCatalogAllOf } from '../models/SoftwarerepositoryCatalogAllOf';
import { SoftwarerepositoryCatalogList } from '../models/SoftwarerepositoryCatalogList';
import { SoftwarerepositoryCatalogListAllOf } from '../models/SoftwarerepositoryCatalogListAllOf';
import { SoftwarerepositoryCatalogRelationship } from '../models/SoftwarerepositoryCatalogRelationship';
import { SoftwarerepositoryCatalogResponse } from '../models/SoftwarerepositoryCatalogResponse';
import { SoftwarerepositoryCifsServer } from '../models/SoftwarerepositoryCifsServer';
import { SoftwarerepositoryCifsServerAllOf } from '../models/SoftwarerepositoryCifsServerAllOf';
import { SoftwarerepositoryFile } from '../models/SoftwarerepositoryFile';
import { SoftwarerepositoryFileAllOf } from '../models/SoftwarerepositoryFileAllOf';
import { SoftwarerepositoryFileServer } from '../models/SoftwarerepositoryFileServer';
import { SoftwarerepositoryHttpServer } from '../models/SoftwarerepositoryHttpServer';
import { SoftwarerepositoryHttpServerAllOf } from '../models/SoftwarerepositoryHttpServerAllOf';
import { SoftwarerepositoryImportResult } from '../models/SoftwarerepositoryImportResult';
import { SoftwarerepositoryImportResultAllOf } from '../models/SoftwarerepositoryImportResultAllOf';
import { SoftwarerepositoryLocalMachine } from '../models/SoftwarerepositoryLocalMachine';
import { SoftwarerepositoryLocalMachineAllOf } from '../models/SoftwarerepositoryLocalMachineAllOf';
import { SoftwarerepositoryNfsServer } from '../models/SoftwarerepositoryNfsServer';
import { SoftwarerepositoryNfsServerAllOf } from '../models/SoftwarerepositoryNfsServerAllOf';
import { SoftwarerepositoryOperatingSystemFile } from '../models/SoftwarerepositoryOperatingSystemFile';
import { SoftwarerepositoryOperatingSystemFileAllOf } from '../models/SoftwarerepositoryOperatingSystemFileAllOf';
import { SoftwarerepositoryOperatingSystemFileList } from '../models/SoftwarerepositoryOperatingSystemFileList';
import { SoftwarerepositoryOperatingSystemFileListAllOf } from '../models/SoftwarerepositoryOperatingSystemFileListAllOf';
import { SoftwarerepositoryOperatingSystemFileRelationship } from '../models/SoftwarerepositoryOperatingSystemFileRelationship';
import { SoftwarerepositoryOperatingSystemFileResponse } from '../models/SoftwarerepositoryOperatingSystemFileResponse';
import { SolPolicy } from '../models/SolPolicy';
import { SolPolicyAllOf } from '../models/SolPolicyAllOf';
import { SolPolicyList } from '../models/SolPolicyList';
import { SolPolicyListAllOf } from '../models/SolPolicyListAllOf';
import { SolPolicyResponse } from '../models/SolPolicyResponse';
import { SshPolicy } from '../models/SshPolicy';
import { SshPolicyAllOf } from '../models/SshPolicyAllOf';
import { SshPolicyList } from '../models/SshPolicyList';
import { SshPolicyListAllOf } from '../models/SshPolicyListAllOf';
import { SshPolicyResponse } from '../models/SshPolicyResponse';
import { StorageArrayController } from '../models/StorageArrayController';
import { StorageArrayControllerAllOf } from '../models/StorageArrayControllerAllOf';
import { StorageArrayControllerRelationship } from '../models/StorageArrayControllerRelationship';
import { StorageArrayDisk } from '../models/StorageArrayDisk';
import { StorageArrayDiskAllOf } from '../models/StorageArrayDiskAllOf';
import { StorageCapacity } from '../models/StorageCapacity';
import { StorageCapacityAllOf } from '../models/StorageCapacityAllOf';
import { StorageController } from '../models/StorageController';
import { StorageControllerAllOf } from '../models/StorageControllerAllOf';
import { StorageControllerList } from '../models/StorageControllerList';
import { StorageControllerListAllOf } from '../models/StorageControllerListAllOf';
import { StorageControllerRelationship } from '../models/StorageControllerRelationship';
import { StorageControllerResponse } from '../models/StorageControllerResponse';
import { StorageDiskGroupPolicy } from '../models/StorageDiskGroupPolicy';
import { StorageDiskGroupPolicyAllOf } from '../models/StorageDiskGroupPolicyAllOf';
import { StorageDiskGroupPolicyList } from '../models/StorageDiskGroupPolicyList';
import { StorageDiskGroupPolicyListAllOf } from '../models/StorageDiskGroupPolicyListAllOf';
import { StorageDiskGroupPolicyRelationship } from '../models/StorageDiskGroupPolicyRelationship';
import { StorageDiskGroupPolicyResponse } from '../models/StorageDiskGroupPolicyResponse';
import { StorageDiskUtilization } from '../models/StorageDiskUtilization';
import { StorageEnclosure } from '../models/StorageEnclosure';
import { StorageEnclosureAllOf } from '../models/StorageEnclosureAllOf';
import { StorageEnclosureDisk } from '../models/StorageEnclosureDisk';
import { StorageEnclosureDiskAllOf } from '../models/StorageEnclosureDiskAllOf';
import { StorageEnclosureDiskList } from '../models/StorageEnclosureDiskList';
import { StorageEnclosureDiskListAllOf } from '../models/StorageEnclosureDiskListAllOf';
import { StorageEnclosureDiskRelationship } from '../models/StorageEnclosureDiskRelationship';
import { StorageEnclosureDiskResponse } from '../models/StorageEnclosureDiskResponse';
import { StorageEnclosureDiskSlotEp } from '../models/StorageEnclosureDiskSlotEp';
import { StorageEnclosureDiskSlotEpAllOf } from '../models/StorageEnclosureDiskSlotEpAllOf';
import { StorageEnclosureDiskSlotEpList } from '../models/StorageEnclosureDiskSlotEpList';
import { StorageEnclosureDiskSlotEpListAllOf } from '../models/StorageEnclosureDiskSlotEpListAllOf';
import { StorageEnclosureDiskSlotEpRelationship } from '../models/StorageEnclosureDiskSlotEpRelationship';
import { StorageEnclosureDiskSlotEpResponse } from '../models/StorageEnclosureDiskSlotEpResponse';
import { StorageEnclosureList } from '../models/StorageEnclosureList';
import { StorageEnclosureListAllOf } from '../models/StorageEnclosureListAllOf';
import { StorageEnclosureRelationship } from '../models/StorageEnclosureRelationship';
import { StorageEnclosureResponse } from '../models/StorageEnclosureResponse';
import { StorageFlexFlashController } from '../models/StorageFlexFlashController';
import { StorageFlexFlashControllerAllOf } from '../models/StorageFlexFlashControllerAllOf';
import { StorageFlexFlashControllerList } from '../models/StorageFlexFlashControllerList';
import { StorageFlexFlashControllerListAllOf } from '../models/StorageFlexFlashControllerListAllOf';
import { StorageFlexFlashControllerProps } from '../models/StorageFlexFlashControllerProps';
import { StorageFlexFlashControllerPropsAllOf } from '../models/StorageFlexFlashControllerPropsAllOf';
import { StorageFlexFlashControllerPropsList } from '../models/StorageFlexFlashControllerPropsList';
import { StorageFlexFlashControllerPropsListAllOf } from '../models/StorageFlexFlashControllerPropsListAllOf';
import { StorageFlexFlashControllerPropsRelationship } from '../models/StorageFlexFlashControllerPropsRelationship';
import { StorageFlexFlashControllerPropsResponse } from '../models/StorageFlexFlashControllerPropsResponse';
import { StorageFlexFlashControllerRelationship } from '../models/StorageFlexFlashControllerRelationship';
import { StorageFlexFlashControllerResponse } from '../models/StorageFlexFlashControllerResponse';
import { StorageFlexFlashPhysicalDrive } from '../models/StorageFlexFlashPhysicalDrive';
import { StorageFlexFlashPhysicalDriveAllOf } from '../models/StorageFlexFlashPhysicalDriveAllOf';
import { StorageFlexFlashPhysicalDriveList } from '../models/StorageFlexFlashPhysicalDriveList';
import { StorageFlexFlashPhysicalDriveListAllOf } from '../models/StorageFlexFlashPhysicalDriveListAllOf';
import { StorageFlexFlashPhysicalDriveRelationship } from '../models/StorageFlexFlashPhysicalDriveRelationship';
import { StorageFlexFlashPhysicalDriveResponse } from '../models/StorageFlexFlashPhysicalDriveResponse';
import { StorageFlexFlashVirtualDrive } from '../models/StorageFlexFlashVirtualDrive';
import { StorageFlexFlashVirtualDriveAllOf } from '../models/StorageFlexFlashVirtualDriveAllOf';
import { StorageFlexFlashVirtualDriveList } from '../models/StorageFlexFlashVirtualDriveList';
import { StorageFlexFlashVirtualDriveListAllOf } from '../models/StorageFlexFlashVirtualDriveListAllOf';
import { StorageFlexFlashVirtualDriveRelationship } from '../models/StorageFlexFlashVirtualDriveRelationship';
import { StorageFlexFlashVirtualDriveResponse } from '../models/StorageFlexFlashVirtualDriveResponse';
import { StorageFlexUtilController } from '../models/StorageFlexUtilController';
import { StorageFlexUtilControllerAllOf } from '../models/StorageFlexUtilControllerAllOf';
import { StorageFlexUtilControllerList } from '../models/StorageFlexUtilControllerList';
import { StorageFlexUtilControllerListAllOf } from '../models/StorageFlexUtilControllerListAllOf';
import { StorageFlexUtilControllerRelationship } from '../models/StorageFlexUtilControllerRelationship';
import { StorageFlexUtilControllerResponse } from '../models/StorageFlexUtilControllerResponse';
import { StorageFlexUtilPhysicalDrive } from '../models/StorageFlexUtilPhysicalDrive';
import { StorageFlexUtilPhysicalDriveAllOf } from '../models/StorageFlexUtilPhysicalDriveAllOf';
import { StorageFlexUtilPhysicalDriveList } from '../models/StorageFlexUtilPhysicalDriveList';
import { StorageFlexUtilPhysicalDriveListAllOf } from '../models/StorageFlexUtilPhysicalDriveListAllOf';
import { StorageFlexUtilPhysicalDriveRelationship } from '../models/StorageFlexUtilPhysicalDriveRelationship';
import { StorageFlexUtilPhysicalDriveResponse } from '../models/StorageFlexUtilPhysicalDriveResponse';
import { StorageFlexUtilVirtualDrive } from '../models/StorageFlexUtilVirtualDrive';
import { StorageFlexUtilVirtualDriveAllOf } from '../models/StorageFlexUtilVirtualDriveAllOf';
import { StorageFlexUtilVirtualDriveList } from '../models/StorageFlexUtilVirtualDriveList';
import { StorageFlexUtilVirtualDriveListAllOf } from '../models/StorageFlexUtilVirtualDriveListAllOf';
import { StorageFlexUtilVirtualDriveRelationship } from '../models/StorageFlexUtilVirtualDriveRelationship';
import { StorageFlexUtilVirtualDriveResponse } from '../models/StorageFlexUtilVirtualDriveResponse';
import { StorageGenericArray } from '../models/StorageGenericArray';
import { StorageGenericArrayAllOf } from '../models/StorageGenericArrayAllOf';
import { StorageGenericArrayRelationship } from '../models/StorageGenericArrayRelationship';
import { StorageHost } from '../models/StorageHost';
import { StorageHostAllOf } from '../models/StorageHostAllOf';
import { StorageHostGroup } from '../models/StorageHostGroup';
import { StorageHostGroupAllOf } from '../models/StorageHostGroupAllOf';
import { StorageHostLun } from '../models/StorageHostLun';
import { StorageHostLunAllOf } from '../models/StorageHostLunAllOf';
import { StorageHostRelationship } from '../models/StorageHostRelationship';
import { StorageHostUtilization } from '../models/StorageHostUtilization';
import { StorageInitiator } from '../models/StorageInitiator';
import { StorageInitiatorAllOf } from '../models/StorageInitiatorAllOf';
import { StorageLocalDisk } from '../models/StorageLocalDisk';
import { StorageLocalDiskAllOf } from '../models/StorageLocalDiskAllOf';
import { StoragePhysicalDisk } from '../models/StoragePhysicalDisk';
import { StoragePhysicalDiskAllOf } from '../models/StoragePhysicalDiskAllOf';
import { StoragePhysicalDiskExtension } from '../models/StoragePhysicalDiskExtension';
import { StoragePhysicalDiskExtensionAllOf } from '../models/StoragePhysicalDiskExtensionAllOf';
import { StoragePhysicalDiskExtensionList } from '../models/StoragePhysicalDiskExtensionList';
import { StoragePhysicalDiskExtensionListAllOf } from '../models/StoragePhysicalDiskExtensionListAllOf';
import { StoragePhysicalDiskExtensionRelationship } from '../models/StoragePhysicalDiskExtensionRelationship';
import { StoragePhysicalDiskExtensionResponse } from '../models/StoragePhysicalDiskExtensionResponse';
import { StoragePhysicalDiskList } from '../models/StoragePhysicalDiskList';
import { StoragePhysicalDiskListAllOf } from '../models/StoragePhysicalDiskListAllOf';
import { StoragePhysicalDiskRelationship } from '../models/StoragePhysicalDiskRelationship';
import { StoragePhysicalDiskResponse } from '../models/StoragePhysicalDiskResponse';
import { StoragePhysicalDiskUsage } from '../models/StoragePhysicalDiskUsage';
import { StoragePhysicalDiskUsageAllOf } from '../models/StoragePhysicalDiskUsageAllOf';
import { StoragePhysicalDiskUsageList } from '../models/StoragePhysicalDiskUsageList';
import { StoragePhysicalDiskUsageListAllOf } from '../models/StoragePhysicalDiskUsageListAllOf';
import { StoragePhysicalDiskUsageRelationship } from '../models/StoragePhysicalDiskUsageRelationship';
import { StoragePhysicalDiskUsageResponse } from '../models/StoragePhysicalDiskUsageResponse';
import { StoragePhysicalPort } from '../models/StoragePhysicalPort';
import { StoragePhysicalPortAllOf } from '../models/StoragePhysicalPortAllOf';
import { StorageProtectionGroup } from '../models/StorageProtectionGroup';
import { StorageProtectionGroupAllOf } from '../models/StorageProtectionGroupAllOf';
import { StorageProtectionGroupRelationship } from '../models/StorageProtectionGroupRelationship';
import { StorageProtectionGroupSnapshot } from '../models/StorageProtectionGroupSnapshot';
import { StorageProtectionGroupSnapshotAllOf } from '../models/StorageProtectionGroupSnapshotAllOf';
import { StorageProtectionGroupSnapshotRelationship } from '../models/StorageProtectionGroupSnapshotRelationship';
import { StoragePureArray } from '../models/StoragePureArray';
import { StoragePureArrayAllOf } from '../models/StoragePureArrayAllOf';
import { StoragePureArrayList } from '../models/StoragePureArrayList';
import { StoragePureArrayListAllOf } from '../models/StoragePureArrayListAllOf';
import { StoragePureArrayResponse } from '../models/StoragePureArrayResponse';
import { StoragePureController } from '../models/StoragePureController';
import { StoragePureControllerAllOf } from '../models/StoragePureControllerAllOf';
import { StoragePureControllerList } from '../models/StoragePureControllerList';
import { StoragePureControllerListAllOf } from '../models/StoragePureControllerListAllOf';
import { StoragePureControllerResponse } from '../models/StoragePureControllerResponse';
import { StoragePureDisk } from '../models/StoragePureDisk';
import { StoragePureDiskAllOf } from '../models/StoragePureDiskAllOf';
import { StoragePureDiskList } from '../models/StoragePureDiskList';
import { StoragePureDiskListAllOf } from '../models/StoragePureDiskListAllOf';
import { StoragePureDiskResponse } from '../models/StoragePureDiskResponse';
import { StoragePureHost } from '../models/StoragePureHost';
import { StoragePureHostAllOf } from '../models/StoragePureHostAllOf';
import { StoragePureHostGroup } from '../models/StoragePureHostGroup';
import { StoragePureHostGroupAllOf } from '../models/StoragePureHostGroupAllOf';
import { StoragePureHostGroupList } from '../models/StoragePureHostGroupList';
import { StoragePureHostGroupListAllOf } from '../models/StoragePureHostGroupListAllOf';
import { StoragePureHostGroupRelationship } from '../models/StoragePureHostGroupRelationship';
import { StoragePureHostGroupResponse } from '../models/StoragePureHostGroupResponse';
import { StoragePureHostList } from '../models/StoragePureHostList';
import { StoragePureHostListAllOf } from '../models/StoragePureHostListAllOf';
import { StoragePureHostLun } from '../models/StoragePureHostLun';
import { StoragePureHostLunAllOf } from '../models/StoragePureHostLunAllOf';
import { StoragePureHostLunList } from '../models/StoragePureHostLunList';
import { StoragePureHostLunListAllOf } from '../models/StoragePureHostLunListAllOf';
import { StoragePureHostLunResponse } from '../models/StoragePureHostLunResponse';
import { StoragePureHostRelationship } from '../models/StoragePureHostRelationship';
import { StoragePureHostResponse } from '../models/StoragePureHostResponse';
import { StoragePurePort } from '../models/StoragePurePort';
import { StoragePurePortAllOf } from '../models/StoragePurePortAllOf';
import { StoragePurePortList } from '../models/StoragePurePortList';
import { StoragePurePortListAllOf } from '../models/StoragePurePortListAllOf';
import { StoragePurePortResponse } from '../models/StoragePurePortResponse';
import { StoragePureProtectionGroup } from '../models/StoragePureProtectionGroup';
import { StoragePureProtectionGroupAllOf } from '../models/StoragePureProtectionGroupAllOf';
import { StoragePureProtectionGroupList } from '../models/StoragePureProtectionGroupList';
import { StoragePureProtectionGroupListAllOf } from '../models/StoragePureProtectionGroupListAllOf';
import { StoragePureProtectionGroupRelationship } from '../models/StoragePureProtectionGroupRelationship';
import { StoragePureProtectionGroupResponse } from '../models/StoragePureProtectionGroupResponse';
import { StoragePureProtectionGroupSnapshot } from '../models/StoragePureProtectionGroupSnapshot';
import { StoragePureProtectionGroupSnapshotAllOf } from '../models/StoragePureProtectionGroupSnapshotAllOf';
import { StoragePureProtectionGroupSnapshotList } from '../models/StoragePureProtectionGroupSnapshotList';
import { StoragePureProtectionGroupSnapshotListAllOf } from '../models/StoragePureProtectionGroupSnapshotListAllOf';
import { StoragePureProtectionGroupSnapshotResponse } from '../models/StoragePureProtectionGroupSnapshotResponse';
import { StoragePureReplicationBlackout } from '../models/StoragePureReplicationBlackout';
import { StoragePureReplicationSchedule } from '../models/StoragePureReplicationSchedule';
import { StoragePureReplicationScheduleAllOf } from '../models/StoragePureReplicationScheduleAllOf';
import { StoragePureReplicationScheduleList } from '../models/StoragePureReplicationScheduleList';
import { StoragePureReplicationScheduleListAllOf } from '../models/StoragePureReplicationScheduleListAllOf';
import { StoragePureReplicationScheduleResponse } from '../models/StoragePureReplicationScheduleResponse';
import { StoragePureSnapshotSchedule } from '../models/StoragePureSnapshotSchedule';
import { StoragePureSnapshotScheduleAllOf } from '../models/StoragePureSnapshotScheduleAllOf';
import { StoragePureSnapshotScheduleList } from '../models/StoragePureSnapshotScheduleList';
import { StoragePureSnapshotScheduleListAllOf } from '../models/StoragePureSnapshotScheduleListAllOf';
import { StoragePureSnapshotScheduleResponse } from '../models/StoragePureSnapshotScheduleResponse';
import { StoragePureVolume } from '../models/StoragePureVolume';
import { StoragePureVolumeAllOf } from '../models/StoragePureVolumeAllOf';
import { StoragePureVolumeList } from '../models/StoragePureVolumeList';
import { StoragePureVolumeListAllOf } from '../models/StoragePureVolumeListAllOf';
import { StoragePureVolumeRelationship } from '../models/StoragePureVolumeRelationship';
import { StoragePureVolumeResponse } from '../models/StoragePureVolumeResponse';
import { StoragePureVolumeSnapshot } from '../models/StoragePureVolumeSnapshot';
import { StoragePureVolumeSnapshotAllOf } from '../models/StoragePureVolumeSnapshotAllOf';
import { StoragePureVolumeSnapshotList } from '../models/StoragePureVolumeSnapshotList';
import { StoragePureVolumeSnapshotListAllOf } from '../models/StoragePureVolumeSnapshotListAllOf';
import { StoragePureVolumeSnapshotResponse } from '../models/StoragePureVolumeSnapshotResponse';
import { StorageRemoteKeySetting } from '../models/StorageRemoteKeySetting';
import { StorageRemoteKeySettingAllOf } from '../models/StorageRemoteKeySettingAllOf';
import { StorageReplicationBlackout } from '../models/StorageReplicationBlackout';
import { StorageReplicationBlackoutAllOf } from '../models/StorageReplicationBlackoutAllOf';
import { StorageReplicationSchedule } from '../models/StorageReplicationSchedule';
import { StorageReplicationScheduleAllOf } from '../models/StorageReplicationScheduleAllOf';
import { StorageSasExpander } from '../models/StorageSasExpander';
import { StorageSasExpanderAllOf } from '../models/StorageSasExpanderAllOf';
import { StorageSasExpanderList } from '../models/StorageSasExpanderList';
import { StorageSasExpanderListAllOf } from '../models/StorageSasExpanderListAllOf';
import { StorageSasExpanderRelationship } from '../models/StorageSasExpanderRelationship';
import { StorageSasExpanderResponse } from '../models/StorageSasExpanderResponse';
import { StorageSasPort } from '../models/StorageSasPort';
import { StorageSasPortAllOf } from '../models/StorageSasPortAllOf';
import { StorageSasPortList } from '../models/StorageSasPortList';
import { StorageSasPortListAllOf } from '../models/StorageSasPortListAllOf';
import { StorageSasPortRelationship } from '../models/StorageSasPortRelationship';
import { StorageSasPortResponse } from '../models/StorageSasPortResponse';
import { StorageSnapshot } from '../models/StorageSnapshot';
import { StorageSnapshotAllOf } from '../models/StorageSnapshotAllOf';
import { StorageSnapshotSchedule } from '../models/StorageSnapshotSchedule';
import { StorageSnapshotScheduleAllOf } from '../models/StorageSnapshotScheduleAllOf';
import { StorageSpanGroup } from '../models/StorageSpanGroup';
import { StorageSpanGroupAllOf } from '../models/StorageSpanGroupAllOf';
import { StorageStorageArrayUtilization } from '../models/StorageStorageArrayUtilization';
import { StorageStorageArrayUtilizationAllOf } from '../models/StorageStorageArrayUtilizationAllOf';
import { StorageStoragePolicy } from '../models/StorageStoragePolicy';
import { StorageStoragePolicyAllOf } from '../models/StorageStoragePolicyAllOf';
import { StorageStoragePolicyList } from '../models/StorageStoragePolicyList';
import { StorageStoragePolicyListAllOf } from '../models/StorageStoragePolicyListAllOf';
import { StorageStoragePolicyRelationship } from '../models/StorageStoragePolicyRelationship';
import { StorageStoragePolicyResponse } from '../models/StorageStoragePolicyResponse';
import { StorageStorageUtilization } from '../models/StorageStorageUtilization';
import { StorageStorageUtilizationAllOf } from '../models/StorageStorageUtilizationAllOf';
import { StorageVdMemberEp } from '../models/StorageVdMemberEp';
import { StorageVdMemberEpAllOf } from '../models/StorageVdMemberEpAllOf';
import { StorageVdMemberEpList } from '../models/StorageVdMemberEpList';
import { StorageVdMemberEpListAllOf } from '../models/StorageVdMemberEpListAllOf';
import { StorageVdMemberEpRelationship } from '../models/StorageVdMemberEpRelationship';
import { StorageVdMemberEpResponse } from '../models/StorageVdMemberEpResponse';
import { StorageVirtualDrive } from '../models/StorageVirtualDrive';
import { StorageVirtualDriveAllOf } from '../models/StorageVirtualDriveAllOf';
import { StorageVirtualDriveConfig } from '../models/StorageVirtualDriveConfig';
import { StorageVirtualDriveConfigAllOf } from '../models/StorageVirtualDriveConfigAllOf';
import { StorageVirtualDriveExtension } from '../models/StorageVirtualDriveExtension';
import { StorageVirtualDriveExtensionAllOf } from '../models/StorageVirtualDriveExtensionAllOf';
import { StorageVirtualDriveExtensionList } from '../models/StorageVirtualDriveExtensionList';
import { StorageVirtualDriveExtensionListAllOf } from '../models/StorageVirtualDriveExtensionListAllOf';
import { StorageVirtualDriveExtensionRelationship } from '../models/StorageVirtualDriveExtensionRelationship';
import { StorageVirtualDriveExtensionResponse } from '../models/StorageVirtualDriveExtensionResponse';
import { StorageVirtualDriveList } from '../models/StorageVirtualDriveList';
import { StorageVirtualDriveListAllOf } from '../models/StorageVirtualDriveListAllOf';
import { StorageVirtualDriveRelationship } from '../models/StorageVirtualDriveRelationship';
import { StorageVirtualDriveResponse } from '../models/StorageVirtualDriveResponse';
import { StorageVolume } from '../models/StorageVolume';
import { StorageVolumeAllOf } from '../models/StorageVolumeAllOf';
import { StorageVolumeRelationship } from '../models/StorageVolumeRelationship';
import { StorageVolumeUtilization } from '../models/StorageVolumeUtilization';
import { SyslogLocalClientBase } from '../models/SyslogLocalClientBase';
import { SyslogLocalClientBaseAllOf } from '../models/SyslogLocalClientBaseAllOf';
import { SyslogLocalFileLoggingClient } from '../models/SyslogLocalFileLoggingClient';
import { SyslogPolicy } from '../models/SyslogPolicy';
import { SyslogPolicyAllOf } from '../models/SyslogPolicyAllOf';
import { SyslogPolicyList } from '../models/SyslogPolicyList';
import { SyslogPolicyListAllOf } from '../models/SyslogPolicyListAllOf';
import { SyslogPolicyResponse } from '../models/SyslogPolicyResponse';
import { SyslogRemoteClientBase } from '../models/SyslogRemoteClientBase';
import { SyslogRemoteClientBaseAllOf } from '../models/SyslogRemoteClientBaseAllOf';
import { SyslogRemoteLoggingClient } from '../models/SyslogRemoteLoggingClient';
import { TamAction } from '../models/TamAction';
import { TamActionAllOf } from '../models/TamActionAllOf';
import { TamAdvisory } from '../models/TamAdvisory';
import { TamAdvisoryAllOf } from '../models/TamAdvisoryAllOf';
import { TamAdvisoryCount } from '../models/TamAdvisoryCount';
import { TamAdvisoryCountAllOf } from '../models/TamAdvisoryCountAllOf';
import { TamAdvisoryCountList } from '../models/TamAdvisoryCountList';
import { TamAdvisoryCountListAllOf } from '../models/TamAdvisoryCountListAllOf';
import { TamAdvisoryCountResponse } from '../models/TamAdvisoryCountResponse';
import { TamAdvisoryInfo } from '../models/TamAdvisoryInfo';
import { TamAdvisoryInfoAllOf } from '../models/TamAdvisoryInfoAllOf';
import { TamAdvisoryInfoList } from '../models/TamAdvisoryInfoList';
import { TamAdvisoryInfoListAllOf } from '../models/TamAdvisoryInfoListAllOf';
import { TamAdvisoryInfoResponse } from '../models/TamAdvisoryInfoResponse';
import { TamAdvisoryInstance } from '../models/TamAdvisoryInstance';
import { TamAdvisoryInstanceAllOf } from '../models/TamAdvisoryInstanceAllOf';
import { TamAdvisoryInstanceList } from '../models/TamAdvisoryInstanceList';
import { TamAdvisoryInstanceListAllOf } from '../models/TamAdvisoryInstanceListAllOf';
import { TamAdvisoryInstanceResponse } from '../models/TamAdvisoryInstanceResponse';
import { TamAdvisoryRelationship } from '../models/TamAdvisoryRelationship';
import { TamApiDataSource } from '../models/TamApiDataSource';
import { TamApiDataSourceAllOf } from '../models/TamApiDataSourceAllOf';
import { TamBaseDataSource } from '../models/TamBaseDataSource';
import { TamBaseDataSourceAllOf } from '../models/TamBaseDataSourceAllOf';
import { TamIdentifiers } from '../models/TamIdentifiers';
import { TamIdentifiersAllOf } from '../models/TamIdentifiersAllOf';
import { TamPsirtSeverity } from '../models/TamPsirtSeverity';
import { TamPsirtSeverityAllOf } from '../models/TamPsirtSeverityAllOf';
import { TamQueryEntry } from '../models/TamQueryEntry';
import { TamQueryEntryAllOf } from '../models/TamQueryEntryAllOf';
import { TamSecurityAdvisory } from '../models/TamSecurityAdvisory';
import { TamSecurityAdvisoryAllOf } from '../models/TamSecurityAdvisoryAllOf';
import { TamSecurityAdvisoryList } from '../models/TamSecurityAdvisoryList';
import { TamSecurityAdvisoryListAllOf } from '../models/TamSecurityAdvisoryListAllOf';
import { TamSecurityAdvisoryResponse } from '../models/TamSecurityAdvisoryResponse';
import { TamSeverity } from '../models/TamSeverity';
import { TamTextFsmTemplateDataSource } from '../models/TamTextFsmTemplateDataSource';
import { TamTextFsmTemplateDataSourceAllOf } from '../models/TamTextFsmTemplateDataSourceAllOf';
import { TaskPureScopedInventory } from '../models/TaskPureScopedInventory';
import { TaskPureScopedInventoryAllOf } from '../models/TaskPureScopedInventoryAllOf';
import { TelemetryDruidAggregateRequest } from '../models/TelemetryDruidAggregateRequest';
import { TelemetryDruidAggregator } from '../models/TelemetryDruidAggregator';
import { TelemetryDruidAndFilter } from '../models/TelemetryDruidAndFilter';
import { TelemetryDruidAndFilterAllOf } from '../models/TelemetryDruidAndFilterAllOf';
import { TelemetryDruidArithmeticPostAggregator } from '../models/TelemetryDruidArithmeticPostAggregator';
import { TelemetryDruidArithmeticPostAggregatorAllOf } from '../models/TelemetryDruidArithmeticPostAggregatorAllOf';
import { TelemetryDruidBaseAggregator } from '../models/TelemetryDruidBaseAggregator';
import { TelemetryDruidBaseDataSource } from '../models/TelemetryDruidBaseDataSource';
import { TelemetryDruidBaseDimensionSpec } from '../models/TelemetryDruidBaseDimensionSpec';
import { TelemetryDruidBaseFilter } from '../models/TelemetryDruidBaseFilter';
import { TelemetryDruidBaseGranularity } from '../models/TelemetryDruidBaseGranularity';
import { TelemetryDruidBaseHavingFilter } from '../models/TelemetryDruidBaseHavingFilter';
import { TelemetryDruidBaseLimitSpec } from '../models/TelemetryDruidBaseLimitSpec';
import { TelemetryDruidBasePostAggregator } from '../models/TelemetryDruidBasePostAggregator';
import { TelemetryDruidBaseRequest } from '../models/TelemetryDruidBaseRequest';
import { TelemetryDruidBaseTopNMetricSpec } from '../models/TelemetryDruidBaseTopNMetricSpec';
import { TelemetryDruidColumnComparisonFilter } from '../models/TelemetryDruidColumnComparisonFilter';
import { TelemetryDruidColumnComparisonFilterAllOf } from '../models/TelemetryDruidColumnComparisonFilterAllOf';
import { TelemetryDruidConstantPostAggregator } from '../models/TelemetryDruidConstantPostAggregator';
import { TelemetryDruidConstantPostAggregatorAllOf } from '../models/TelemetryDruidConstantPostAggregatorAllOf';
import { TelemetryDruidCountAggregator } from '../models/TelemetryDruidCountAggregator';
import { TelemetryDruidCountAggregatorAllOf } from '../models/TelemetryDruidCountAggregatorAllOf';
import { TelemetryDruidDataSource } from '../models/TelemetryDruidDataSource';
import { TelemetryDruidDataSourceMetadataRequest } from '../models/TelemetryDruidDataSourceMetadataRequest';
import { TelemetryDruidDataSourceMetadataRequestAllOf } from '../models/TelemetryDruidDataSourceMetadataRequestAllOf';
import { TelemetryDruidDefaultDimensionSpec } from '../models/TelemetryDruidDefaultDimensionSpec';
import { TelemetryDruidDefaultDimensionSpecAllOf } from '../models/TelemetryDruidDefaultDimensionSpecAllOf';
import { TelemetryDruidDefaultLimitSpec } from '../models/TelemetryDruidDefaultLimitSpec';
import { TelemetryDruidDefaultLimitSpecAllOf } from '../models/TelemetryDruidDefaultLimitSpecAllOf';
import { TelemetryDruidDimensionSpec } from '../models/TelemetryDruidDimensionSpec';
import { TelemetryDruidDimensionTopNMetricSpec } from '../models/TelemetryDruidDimensionTopNMetricSpec';
import { TelemetryDruidDimensionTopNMetricSpecAllOf } from '../models/TelemetryDruidDimensionTopNMetricSpecAllOf';
import { TelemetryDruidDurationGranularity } from '../models/TelemetryDruidDurationGranularity';
import { TelemetryDruidDurationGranularityAllOf } from '../models/TelemetryDruidDurationGranularityAllOf';
import { TelemetryDruidExtractionDimensionSpec } from '../models/TelemetryDruidExtractionDimensionSpec';
import { TelemetryDruidExtractionDimensionSpecAllOf } from '../models/TelemetryDruidExtractionDimensionSpecAllOf';
import { TelemetryDruidFieldAccessorPostAggregator } from '../models/TelemetryDruidFieldAccessorPostAggregator';
import { TelemetryDruidFieldAccessorPostAggregatorAllOf } from '../models/TelemetryDruidFieldAccessorPostAggregatorAllOf';
import { TelemetryDruidFilter } from '../models/TelemetryDruidFilter';
import { TelemetryDruidFirstLastAggregator } from '../models/TelemetryDruidFirstLastAggregator';
import { TelemetryDruidFirstLastAggregatorAllOf } from '../models/TelemetryDruidFirstLastAggregatorAllOf';
import { TelemetryDruidGranularity } from '../models/TelemetryDruidGranularity';
import { TelemetryDruidGreatestLeastPostAggregator } from '../models/TelemetryDruidGreatestLeastPostAggregator';
import { TelemetryDruidGreatestLeastPostAggregatorAllOf } from '../models/TelemetryDruidGreatestLeastPostAggregatorAllOf';
import { TelemetryDruidGroupByRequest } from '../models/TelemetryDruidGroupByRequest';
import { TelemetryDruidGroupByRequestAllOf } from '../models/TelemetryDruidGroupByRequestAllOf';
import { TelemetryDruidHavingDimensionSelectorFilter } from '../models/TelemetryDruidHavingDimensionSelectorFilter';
import { TelemetryDruidHavingDimensionSelectorFilterAllOf } from '../models/TelemetryDruidHavingDimensionSelectorFilterAllOf';
import { TelemetryDruidHavingFilter } from '../models/TelemetryDruidHavingFilter';
import { TelemetryDruidHavingNumericFilter } from '../models/TelemetryDruidHavingNumericFilter';
import { TelemetryDruidHavingNumericFilterAllOf } from '../models/TelemetryDruidHavingNumericFilterAllOf';
import { TelemetryDruidHavingQueryFilter } from '../models/TelemetryDruidHavingQueryFilter';
import { TelemetryDruidHavingQueryFilterAllOf } from '../models/TelemetryDruidHavingQueryFilterAllOf';
import { TelemetryDruidHyperUniquePostAggregator } from '../models/TelemetryDruidHyperUniquePostAggregator';
import { TelemetryDruidHyperUniquePostAggregatorAllOf } from '../models/TelemetryDruidHyperUniquePostAggregatorAllOf';
import { TelemetryDruidIntervalResult } from '../models/TelemetryDruidIntervalResult';
import { TelemetryDruidInvertedTopNMetricSpec } from '../models/TelemetryDruidInvertedTopNMetricSpec';
import { TelemetryDruidInvertedTopNMetricSpecAllOf } from '../models/TelemetryDruidInvertedTopNMetricSpecAllOf';
import { TelemetryDruidMinMaxAggregator } from '../models/TelemetryDruidMinMaxAggregator';
import { TelemetryDruidMinMaxAggregatorAllOf } from '../models/TelemetryDruidMinMaxAggregatorAllOf';
import { TelemetryDruidNotFilter } from '../models/TelemetryDruidNotFilter';
import { TelemetryDruidNotFilterAllOf } from '../models/TelemetryDruidNotFilterAllOf';
import { TelemetryDruidNumericTopNMetricSpec } from '../models/TelemetryDruidNumericTopNMetricSpec';
import { TelemetryDruidNumericTopNMetricSpecAllOf } from '../models/TelemetryDruidNumericTopNMetricSpecAllOf';
import { TelemetryDruidOrFilter } from '../models/TelemetryDruidOrFilter';
import { TelemetryDruidOrderByColumnSpec } from '../models/TelemetryDruidOrderByColumnSpec';
import { TelemetryDruidPeriodGranularity } from '../models/TelemetryDruidPeriodGranularity';
import { TelemetryDruidPeriodGranularityAllOf } from '../models/TelemetryDruidPeriodGranularityAllOf';
import { TelemetryDruidPostAggregator } from '../models/TelemetryDruidPostAggregator';
import { TelemetryDruidQueryContext } from '../models/TelemetryDruidQueryContext';
import { TelemetryDruidQueryDataSource } from '../models/TelemetryDruidQueryDataSource';
import { TelemetryDruidQueryDataSourceAllOf } from '../models/TelemetryDruidQueryDataSourceAllOf';
import { TelemetryDruidRegexFilter } from '../models/TelemetryDruidRegexFilter';
import { TelemetryDruidRegexFilterAllOf } from '../models/TelemetryDruidRegexFilterAllOf';
import { TelemetryDruidScanRequest } from '../models/TelemetryDruidScanRequest';
import { TelemetryDruidScanRequestAllOf } from '../models/TelemetryDruidScanRequestAllOf';
import { TelemetryDruidSegmentMetadataRequest } from '../models/TelemetryDruidSegmentMetadataRequest';
import { TelemetryDruidSegmentMetadataRequestAllOf } from '../models/TelemetryDruidSegmentMetadataRequestAllOf';
import { TelemetryDruidSelectorFilter } from '../models/TelemetryDruidSelectorFilter';
import { TelemetryDruidSelectorFilterAllOf } from '../models/TelemetryDruidSelectorFilterAllOf';
import { TelemetryDruidStringFirstLastAggregator } from '../models/TelemetryDruidStringFirstLastAggregator';
import { TelemetryDruidStringFirstLastAggregatorAllOf } from '../models/TelemetryDruidStringFirstLastAggregatorAllOf';
import { TelemetryDruidSumAggregator } from '../models/TelemetryDruidSumAggregator';
import { TelemetryDruidSumAggregatorAllOf } from '../models/TelemetryDruidSumAggregatorAllOf';
import { TelemetryDruidTableDataSource } from '../models/TelemetryDruidTableDataSource';
import { TelemetryDruidTableDataSourceAllOf } from '../models/TelemetryDruidTableDataSourceAllOf';
import { TelemetryDruidTimeBoundaryRequest } from '../models/TelemetryDruidTimeBoundaryRequest';
import { TelemetryDruidTimeBoundaryRequestAllOf } from '../models/TelemetryDruidTimeBoundaryRequestAllOf';
import { TelemetryDruidTimeSeriesRequest } from '../models/TelemetryDruidTimeSeriesRequest';
import { TelemetryDruidTimeSeriesRequestAllOf } from '../models/TelemetryDruidTimeSeriesRequestAllOf';
import { TelemetryDruidTopNMetricSpec } from '../models/TelemetryDruidTopNMetricSpec';
import { TelemetryDruidTopNRequest } from '../models/TelemetryDruidTopNRequest';
import { TelemetryDruidTopNRequestAllOf } from '../models/TelemetryDruidTopNRequestAllOf';
import { TelemetryDruidUnionDataSource } from '../models/TelemetryDruidUnionDataSource';
import { TelemetryDruidUnionDataSourceAllOf } from '../models/TelemetryDruidUnionDataSourceAllOf';
import { TerminalAuditLog } from '../models/TerminalAuditLog';
import { TerminalAuditLogAllOf } from '../models/TerminalAuditLogAllOf';
import { TerminalAuditLogList } from '../models/TerminalAuditLogList';
import { TerminalAuditLogListAllOf } from '../models/TerminalAuditLogListAllOf';
import { TerminalAuditLogResponse } from '../models/TerminalAuditLogResponse';
import { TopSystem } from '../models/TopSystem';
import { TopSystemAllOf } from '../models/TopSystemAllOf';
import { TopSystemList } from '../models/TopSystemList';
import { TopSystemListAllOf } from '../models/TopSystemListAllOf';
import { TopSystemRelationship } from '../models/TopSystemRelationship';
import { TopSystemResponse } from '../models/TopSystemResponse';
import { UcsdBackupInfo } from '../models/UcsdBackupInfo';
import { UcsdBackupInfoAllOf } from '../models/UcsdBackupInfoAllOf';
import { UcsdBackupInfoList } from '../models/UcsdBackupInfoList';
import { UcsdBackupInfoListAllOf } from '../models/UcsdBackupInfoListAllOf';
import { UcsdBackupInfoResponse } from '../models/UcsdBackupInfoResponse';
import { UcsdConnectorPack } from '../models/UcsdConnectorPack';
import { UcsdConnectorPackAllOf } from '../models/UcsdConnectorPackAllOf';
import { UcsdUcsdRestoreParameters } from '../models/UcsdUcsdRestoreParameters';
import { UcsdUcsdRestoreParametersAllOf } from '../models/UcsdUcsdRestoreParametersAllOf';
import { ViewsView } from '../models/ViewsView';
import { VirtualizationAbstractVirtualMachine } from '../models/VirtualizationAbstractVirtualMachine';
import { VirtualizationAbstractVirtualMachineAllOf } from '../models/VirtualizationAbstractVirtualMachineAllOf';
import { VirtualizationCluster } from '../models/VirtualizationCluster';
import { VirtualizationClusterAllOf } from '../models/VirtualizationClusterAllOf';
import { VirtualizationComputeCapacity } from '../models/VirtualizationComputeCapacity';
import { VirtualizationComputeCapacityAllOf } from '../models/VirtualizationComputeCapacityAllOf';
import { VirtualizationCpuInfo } from '../models/VirtualizationCpuInfo';
import { VirtualizationCpuInfoAllOf } from '../models/VirtualizationCpuInfoAllOf';
import { VirtualizationDatacenter } from '../models/VirtualizationDatacenter';
import { VirtualizationDatacenterAllOf } from '../models/VirtualizationDatacenterAllOf';
import { VirtualizationDatastore } from '../models/VirtualizationDatastore';
import { VirtualizationDatastoreAllOf } from '../models/VirtualizationDatastoreAllOf';
import { VirtualizationGuestInfo } from '../models/VirtualizationGuestInfo';
import { VirtualizationGuestInfoAllOf } from '../models/VirtualizationGuestInfoAllOf';
import { VirtualizationHost } from '../models/VirtualizationHost';
import { VirtualizationHostAllOf } from '../models/VirtualizationHostAllOf';
import { VirtualizationHypervisorManager } from '../models/VirtualizationHypervisorManager';
import { VirtualizationHypervisorManagerAllOf } from '../models/VirtualizationHypervisorManagerAllOf';
import { VirtualizationMemoryCapacity } from '../models/VirtualizationMemoryCapacity';
import { VirtualizationMemoryCapacityAllOf } from '../models/VirtualizationMemoryCapacityAllOf';
import { VirtualizationProductInfo } from '../models/VirtualizationProductInfo';
import { VirtualizationProductInfoAllOf } from '../models/VirtualizationProductInfoAllOf';
import { VirtualizationRemoteDisplayInfo } from '../models/VirtualizationRemoteDisplayInfo';
import { VirtualizationRemoteDisplayInfoAllOf } from '../models/VirtualizationRemoteDisplayInfoAllOf';
import { VirtualizationResourceConsumption } from '../models/VirtualizationResourceConsumption';
import { VirtualizationResourceConsumptionAllOf } from '../models/VirtualizationResourceConsumptionAllOf';
import { VirtualizationSourceDevice } from '../models/VirtualizationSourceDevice';
import { VirtualizationSourceDeviceAllOf } from '../models/VirtualizationSourceDeviceAllOf';
import { VirtualizationStorageCapacity } from '../models/VirtualizationStorageCapacity';
import { VirtualizationStorageCapacityAllOf } from '../models/VirtualizationStorageCapacityAllOf';
import { VirtualizationVmCpuShareInfo } from '../models/VirtualizationVmCpuShareInfo';
import { VirtualizationVmCpuShareInfoAllOf } from '../models/VirtualizationVmCpuShareInfoAllOf';
import { VirtualizationVmCpuSocketInfo } from '../models/VirtualizationVmCpuSocketInfo';
import { VirtualizationVmCpuSocketInfoAllOf } from '../models/VirtualizationVmCpuSocketInfoAllOf';
import { VirtualizationVmDiskCommitInfo } from '../models/VirtualizationVmDiskCommitInfo';
import { VirtualizationVmDiskCommitInfoAllOf } from '../models/VirtualizationVmDiskCommitInfoAllOf';
import { VirtualizationVmMemoryShareInfo } from '../models/VirtualizationVmMemoryShareInfo';
import { VirtualizationVmMemoryShareInfoAllOf } from '../models/VirtualizationVmMemoryShareInfoAllOf';
import { VirtualizationVmwareCluster } from '../models/VirtualizationVmwareCluster';
import { VirtualizationVmwareClusterAllOf } from '../models/VirtualizationVmwareClusterAllOf';
import { VirtualizationVmwareClusterList } from '../models/VirtualizationVmwareClusterList';
import { VirtualizationVmwareClusterListAllOf } from '../models/VirtualizationVmwareClusterListAllOf';
import { VirtualizationVmwareClusterRelationship } from '../models/VirtualizationVmwareClusterRelationship';
import { VirtualizationVmwareClusterResponse } from '../models/VirtualizationVmwareClusterResponse';
import { VirtualizationVmwareDatacenter } from '../models/VirtualizationVmwareDatacenter';
import { VirtualizationVmwareDatacenterAllOf } from '../models/VirtualizationVmwareDatacenterAllOf';
import { VirtualizationVmwareDatacenterList } from '../models/VirtualizationVmwareDatacenterList';
import { VirtualizationVmwareDatacenterListAllOf } from '../models/VirtualizationVmwareDatacenterListAllOf';
import { VirtualizationVmwareDatacenterRelationship } from '../models/VirtualizationVmwareDatacenterRelationship';
import { VirtualizationVmwareDatacenterResponse } from '../models/VirtualizationVmwareDatacenterResponse';
import { VirtualizationVmwareDatastore } from '../models/VirtualizationVmwareDatastore';
import { VirtualizationVmwareDatastoreAllOf } from '../models/VirtualizationVmwareDatastoreAllOf';
import { VirtualizationVmwareDatastoreList } from '../models/VirtualizationVmwareDatastoreList';
import { VirtualizationVmwareDatastoreListAllOf } from '../models/VirtualizationVmwareDatastoreListAllOf';
import { VirtualizationVmwareDatastoreRelationship } from '../models/VirtualizationVmwareDatastoreRelationship';
import { VirtualizationVmwareDatastoreResponse } from '../models/VirtualizationVmwareDatastoreResponse';
import { VirtualizationVmwareHost } from '../models/VirtualizationVmwareHost';
import { VirtualizationVmwareHostAllOf } from '../models/VirtualizationVmwareHostAllOf';
import { VirtualizationVmwareHostList } from '../models/VirtualizationVmwareHostList';
import { VirtualizationVmwareHostListAllOf } from '../models/VirtualizationVmwareHostListAllOf';
import { VirtualizationVmwareHostRelationship } from '../models/VirtualizationVmwareHostRelationship';
import { VirtualizationVmwareHostResponse } from '../models/VirtualizationVmwareHostResponse';
import { VirtualizationVmwareVcenter } from '../models/VirtualizationVmwareVcenter';
import { VirtualizationVmwareVcenterList } from '../models/VirtualizationVmwareVcenterList';
import { VirtualizationVmwareVcenterListAllOf } from '../models/VirtualizationVmwareVcenterListAllOf';
import { VirtualizationVmwareVcenterRelationship } from '../models/VirtualizationVmwareVcenterRelationship';
import { VirtualizationVmwareVcenterResponse } from '../models/VirtualizationVmwareVcenterResponse';
import { VirtualizationVmwareVirtualMachine } from '../models/VirtualizationVmwareVirtualMachine';
import { VirtualizationVmwareVirtualMachineAllOf } from '../models/VirtualizationVmwareVirtualMachineAllOf';
import { VirtualizationVmwareVirtualMachineList } from '../models/VirtualizationVmwareVirtualMachineList';
import { VirtualizationVmwareVirtualMachineListAllOf } from '../models/VirtualizationVmwareVirtualMachineListAllOf';
import { VirtualizationVmwareVirtualMachineResponse } from '../models/VirtualizationVmwareVirtualMachineResponse';
import { VmediaMapping } from '../models/VmediaMapping';
import { VmediaMappingAllOf } from '../models/VmediaMappingAllOf';
import { VmediaPolicy } from '../models/VmediaPolicy';
import { VmediaPolicyAllOf } from '../models/VmediaPolicyAllOf';
import { VmediaPolicyList } from '../models/VmediaPolicyList';
import { VmediaPolicyListAllOf } from '../models/VmediaPolicyListAllOf';
import { VmediaPolicyResponse } from '../models/VmediaPolicyResponse';
import { VnicArfsSettings } from '../models/VnicArfsSettings';
import { VnicArfsSettingsAllOf } from '../models/VnicArfsSettingsAllOf';
import { VnicCdn } from '../models/VnicCdn';
import { VnicCdnAllOf } from '../models/VnicCdnAllOf';
import { VnicCompletionQueueSettings } from '../models/VnicCompletionQueueSettings';
import { VnicCompletionQueueSettingsAllOf } from '../models/VnicCompletionQueueSettingsAllOf';
import { VnicEthAdapterPolicy } from '../models/VnicEthAdapterPolicy';
import { VnicEthAdapterPolicyAllOf } from '../models/VnicEthAdapterPolicyAllOf';
import { VnicEthAdapterPolicyList } from '../models/VnicEthAdapterPolicyList';
import { VnicEthAdapterPolicyListAllOf } from '../models/VnicEthAdapterPolicyListAllOf';
import { VnicEthAdapterPolicyRelationship } from '../models/VnicEthAdapterPolicyRelationship';
import { VnicEthAdapterPolicyResponse } from '../models/VnicEthAdapterPolicyResponse';
import { VnicEthIf } from '../models/VnicEthIf';
import { VnicEthIfAllOf } from '../models/VnicEthIfAllOf';
import { VnicEthIfList } from '../models/VnicEthIfList';
import { VnicEthIfListAllOf } from '../models/VnicEthIfListAllOf';
import { VnicEthIfRelationship } from '../models/VnicEthIfRelationship';
import { VnicEthIfResponse } from '../models/VnicEthIfResponse';
import { VnicEthInterruptSettings } from '../models/VnicEthInterruptSettings';
import { VnicEthInterruptSettingsAllOf } from '../models/VnicEthInterruptSettingsAllOf';
import { VnicEthNetworkPolicy } from '../models/VnicEthNetworkPolicy';
import { VnicEthNetworkPolicyAllOf } from '../models/VnicEthNetworkPolicyAllOf';
import { VnicEthNetworkPolicyList } from '../models/VnicEthNetworkPolicyList';
import { VnicEthNetworkPolicyListAllOf } from '../models/VnicEthNetworkPolicyListAllOf';
import { VnicEthNetworkPolicyRelationship } from '../models/VnicEthNetworkPolicyRelationship';
import { VnicEthNetworkPolicyResponse } from '../models/VnicEthNetworkPolicyResponse';
import { VnicEthQosPolicy } from '../models/VnicEthQosPolicy';
import { VnicEthQosPolicyAllOf } from '../models/VnicEthQosPolicyAllOf';
import { VnicEthQosPolicyList } from '../models/VnicEthQosPolicyList';
import { VnicEthQosPolicyListAllOf } from '../models/VnicEthQosPolicyListAllOf';
import { VnicEthQosPolicyRelationship } from '../models/VnicEthQosPolicyRelationship';
import { VnicEthQosPolicyResponse } from '../models/VnicEthQosPolicyResponse';
import { VnicEthRxQueueSettings } from '../models/VnicEthRxQueueSettings';
import { VnicEthRxQueueSettingsAllOf } from '../models/VnicEthRxQueueSettingsAllOf';
import { VnicEthTxQueueSettings } from '../models/VnicEthTxQueueSettings';
import { VnicEthTxQueueSettingsAllOf } from '../models/VnicEthTxQueueSettingsAllOf';
import { VnicFcAdapterPolicy } from '../models/VnicFcAdapterPolicy';
import { VnicFcAdapterPolicyAllOf } from '../models/VnicFcAdapterPolicyAllOf';
import { VnicFcAdapterPolicyList } from '../models/VnicFcAdapterPolicyList';
import { VnicFcAdapterPolicyListAllOf } from '../models/VnicFcAdapterPolicyListAllOf';
import { VnicFcAdapterPolicyRelationship } from '../models/VnicFcAdapterPolicyRelationship';
import { VnicFcAdapterPolicyResponse } from '../models/VnicFcAdapterPolicyResponse';
import { VnicFcErrorRecoverySettings } from '../models/VnicFcErrorRecoverySettings';
import { VnicFcErrorRecoverySettingsAllOf } from '../models/VnicFcErrorRecoverySettingsAllOf';
import { VnicFcIf } from '../models/VnicFcIf';
import { VnicFcIfAllOf } from '../models/VnicFcIfAllOf';
import { VnicFcIfList } from '../models/VnicFcIfList';
import { VnicFcIfListAllOf } from '../models/VnicFcIfListAllOf';
import { VnicFcIfRelationship } from '../models/VnicFcIfRelationship';
import { VnicFcIfResponse } from '../models/VnicFcIfResponse';
import { VnicFcInterruptSettings } from '../models/VnicFcInterruptSettings';
import { VnicFcInterruptSettingsAllOf } from '../models/VnicFcInterruptSettingsAllOf';
import { VnicFcNetworkPolicy } from '../models/VnicFcNetworkPolicy';
import { VnicFcNetworkPolicyAllOf } from '../models/VnicFcNetworkPolicyAllOf';
import { VnicFcNetworkPolicyList } from '../models/VnicFcNetworkPolicyList';
import { VnicFcNetworkPolicyListAllOf } from '../models/VnicFcNetworkPolicyListAllOf';
import { VnicFcNetworkPolicyRelationship } from '../models/VnicFcNetworkPolicyRelationship';
import { VnicFcNetworkPolicyResponse } from '../models/VnicFcNetworkPolicyResponse';
import { VnicFcQosPolicy } from '../models/VnicFcQosPolicy';
import { VnicFcQosPolicyAllOf } from '../models/VnicFcQosPolicyAllOf';
import { VnicFcQosPolicyList } from '../models/VnicFcQosPolicyList';
import { VnicFcQosPolicyListAllOf } from '../models/VnicFcQosPolicyListAllOf';
import { VnicFcQosPolicyRelationship } from '../models/VnicFcQosPolicyRelationship';
import { VnicFcQosPolicyResponse } from '../models/VnicFcQosPolicyResponse';
import { VnicFcQueueSettings } from '../models/VnicFcQueueSettings';
import { VnicFcQueueSettingsAllOf } from '../models/VnicFcQueueSettingsAllOf';
import { VnicFlogiSettings } from '../models/VnicFlogiSettings';
import { VnicFlogiSettingsAllOf } from '../models/VnicFlogiSettingsAllOf';
import { VnicLanConnectivityPolicy } from '../models/VnicLanConnectivityPolicy';
import { VnicLanConnectivityPolicyAllOf } from '../models/VnicLanConnectivityPolicyAllOf';
import { VnicLanConnectivityPolicyList } from '../models/VnicLanConnectivityPolicyList';
import { VnicLanConnectivityPolicyListAllOf } from '../models/VnicLanConnectivityPolicyListAllOf';
import { VnicLanConnectivityPolicyRelationship } from '../models/VnicLanConnectivityPolicyRelationship';
import { VnicLanConnectivityPolicyResponse } from '../models/VnicLanConnectivityPolicyResponse';
import { VnicNvgreSettings } from '../models/VnicNvgreSettings';
import { VnicNvgreSettingsAllOf } from '../models/VnicNvgreSettingsAllOf';
import { VnicPlacementSettings } from '../models/VnicPlacementSettings';
import { VnicPlacementSettingsAllOf } from '../models/VnicPlacementSettingsAllOf';
import { VnicPlogiSettings } from '../models/VnicPlogiSettings';
import { VnicPlogiSettingsAllOf } from '../models/VnicPlogiSettingsAllOf';
import { VnicRoceSettings } from '../models/VnicRoceSettings';
import { VnicRoceSettingsAllOf } from '../models/VnicRoceSettingsAllOf';
import { VnicSanConnectivityPolicy } from '../models/VnicSanConnectivityPolicy';
import { VnicSanConnectivityPolicyAllOf } from '../models/VnicSanConnectivityPolicyAllOf';
import { VnicSanConnectivityPolicyList } from '../models/VnicSanConnectivityPolicyList';
import { VnicSanConnectivityPolicyListAllOf } from '../models/VnicSanConnectivityPolicyListAllOf';
import { VnicSanConnectivityPolicyRelationship } from '../models/VnicSanConnectivityPolicyRelationship';
import { VnicSanConnectivityPolicyResponse } from '../models/VnicSanConnectivityPolicyResponse';
import { VnicScsiQueueSettings } from '../models/VnicScsiQueueSettings';
import { VnicScsiQueueSettingsAllOf } from '../models/VnicScsiQueueSettingsAllOf';
import { VnicTcpOffloadSettings } from '../models/VnicTcpOffloadSettings';
import { VnicTcpOffloadSettingsAllOf } from '../models/VnicTcpOffloadSettingsAllOf';
import { VnicUsnicSettings } from '../models/VnicUsnicSettings';
import { VnicUsnicSettingsAllOf } from '../models/VnicUsnicSettingsAllOf';
import { VnicVlanSettings } from '../models/VnicVlanSettings';
import { VnicVlanSettingsAllOf } from '../models/VnicVlanSettingsAllOf';
import { VnicVmqSettings } from '../models/VnicVmqSettings';
import { VnicVmqSettingsAllOf } from '../models/VnicVmqSettingsAllOf';
import { VnicVsanSettings } from '../models/VnicVsanSettings';
import { VnicVsanSettingsAllOf } from '../models/VnicVsanSettingsAllOf';
import { VnicVxlanSettings } from '../models/VnicVxlanSettings';
import { VnicVxlanSettingsAllOf } from '../models/VnicVxlanSettingsAllOf';
import { WorkflowAbstractWorkerTask } from '../models/WorkflowAbstractWorkerTask';
import { WorkflowAbstractWorkerTaskAllOf } from '../models/WorkflowAbstractWorkerTaskAllOf';
import { WorkflowApi } from '../models/WorkflowApi';
import { WorkflowApiAllOf } from '../models/WorkflowApiAllOf';
import { WorkflowArrayDataType } from '../models/WorkflowArrayDataType';
import { WorkflowArrayDataTypeAllOf } from '../models/WorkflowArrayDataTypeAllOf';
import { WorkflowArrayItem } from '../models/WorkflowArrayItem';
import { WorkflowBaseDataType } from '../models/WorkflowBaseDataType';
import { WorkflowBaseDataTypeAllOf } from '../models/WorkflowBaseDataTypeAllOf';
import { WorkflowBatchApiExecutor } from '../models/WorkflowBatchApiExecutor';
import { WorkflowBatchApiExecutorAllOf } from '../models/WorkflowBatchApiExecutorAllOf';
import { WorkflowBatchApiExecutorList } from '../models/WorkflowBatchApiExecutorList';
import { WorkflowBatchApiExecutorListAllOf } from '../models/WorkflowBatchApiExecutorListAllOf';
import { WorkflowBatchApiExecutorResponse } from '../models/WorkflowBatchApiExecutorResponse';
import { WorkflowBuildTaskMeta } from '../models/WorkflowBuildTaskMeta';
import { WorkflowBuildTaskMetaAllOf } from '../models/WorkflowBuildTaskMetaAllOf';
import { WorkflowBuildTaskMetaList } from '../models/WorkflowBuildTaskMetaList';
import { WorkflowBuildTaskMetaListAllOf } from '../models/WorkflowBuildTaskMetaListAllOf';
import { WorkflowBuildTaskMetaOwner } from '../models/WorkflowBuildTaskMetaOwner';
import { WorkflowBuildTaskMetaOwnerAllOf } from '../models/WorkflowBuildTaskMetaOwnerAllOf';
import { WorkflowBuildTaskMetaOwnerList } from '../models/WorkflowBuildTaskMetaOwnerList';
import { WorkflowBuildTaskMetaOwnerListAllOf } from '../models/WorkflowBuildTaskMetaOwnerListAllOf';
import { WorkflowBuildTaskMetaOwnerResponse } from '../models/WorkflowBuildTaskMetaOwnerResponse';
import { WorkflowBuildTaskMetaResponse } from '../models/WorkflowBuildTaskMetaResponse';
import { WorkflowCatalog } from '../models/WorkflowCatalog';
import { WorkflowCatalogAllOf } from '../models/WorkflowCatalogAllOf';
import { WorkflowCatalogList } from '../models/WorkflowCatalogList';
import { WorkflowCatalogListAllOf } from '../models/WorkflowCatalogListAllOf';
import { WorkflowCatalogRelationship } from '../models/WorkflowCatalogRelationship';
import { WorkflowCatalogResponse } from '../models/WorkflowCatalogResponse';
import { WorkflowCliCommand } from '../models/WorkflowCliCommand';
import { WorkflowCliCommandAllOf } from '../models/WorkflowCliCommandAllOf';
import { WorkflowConstraints } from '../models/WorkflowConstraints';
import { WorkflowConstraintsAllOf } from '../models/WorkflowConstraintsAllOf';
import { WorkflowControlTask } from '../models/WorkflowControlTask';
import { WorkflowCustomDataProperty } from '../models/WorkflowCustomDataProperty';
import { WorkflowCustomDataPropertyAllOf } from '../models/WorkflowCustomDataPropertyAllOf';
import { WorkflowCustomDataType } from '../models/WorkflowCustomDataType';
import { WorkflowCustomDataTypeAllOf } from '../models/WorkflowCustomDataTypeAllOf';
import { WorkflowCustomDataTypeDefinition } from '../models/WorkflowCustomDataTypeDefinition';
import { WorkflowCustomDataTypeDefinitionAllOf } from '../models/WorkflowCustomDataTypeDefinitionAllOf';
import { WorkflowCustomDataTypeDefinitionList } from '../models/WorkflowCustomDataTypeDefinitionList';
import { WorkflowCustomDataTypeDefinitionListAllOf } from '../models/WorkflowCustomDataTypeDefinitionListAllOf';
import { WorkflowCustomDataTypeDefinitionResponse } from '../models/WorkflowCustomDataTypeDefinitionResponse';
import { WorkflowDecisionCase } from '../models/WorkflowDecisionCase';
import { WorkflowDecisionCaseAllOf } from '../models/WorkflowDecisionCaseAllOf';
import { WorkflowDecisionTask } from '../models/WorkflowDecisionTask';
import { WorkflowDecisionTaskAllOf } from '../models/WorkflowDecisionTaskAllOf';
import { WorkflowDefaultValue } from '../models/WorkflowDefaultValue';
import { WorkflowDefaultValueAllOf } from '../models/WorkflowDefaultValueAllOf';
import { WorkflowDynamicWorkflowActionTaskList } from '../models/WorkflowDynamicWorkflowActionTaskList';
import { WorkflowDynamicWorkflowActionTaskListAllOf } from '../models/WorkflowDynamicWorkflowActionTaskListAllOf';
import { WorkflowEndTask } from '../models/WorkflowEndTask';
import { WorkflowEnumEntry } from '../models/WorkflowEnumEntry';
import { WorkflowEnumEntryAllOf } from '../models/WorkflowEnumEntryAllOf';
import { WorkflowExpectPrompt } from '../models/WorkflowExpectPrompt';
import { WorkflowExpectPromptAllOf } from '../models/WorkflowExpectPromptAllOf';
import { WorkflowFailureEndTask } from '../models/WorkflowFailureEndTask';
import { WorkflowInternalProperties } from '../models/WorkflowInternalProperties';
import { WorkflowInternalPropertiesAllOf } from '../models/WorkflowInternalPropertiesAllOf';
import { WorkflowMessage } from '../models/WorkflowMessage';
import { WorkflowMessageAllOf } from '../models/WorkflowMessageAllOf';
import { WorkflowMoReferenceDataType } from '../models/WorkflowMoReferenceDataType';
import { WorkflowMoReferenceDataTypeAllOf } from '../models/WorkflowMoReferenceDataTypeAllOf';
import { WorkflowMoReferenceProperty } from '../models/WorkflowMoReferenceProperty';
import { WorkflowMoReferencePropertyAllOf } from '../models/WorkflowMoReferencePropertyAllOf';
import { WorkflowPendingDynamicWorkflowInfo } from '../models/WorkflowPendingDynamicWorkflowInfo';
import { WorkflowPendingDynamicWorkflowInfoAllOf } from '../models/WorkflowPendingDynamicWorkflowInfoAllOf';
import { WorkflowPendingDynamicWorkflowInfoList } from '../models/WorkflowPendingDynamicWorkflowInfoList';
import { WorkflowPendingDynamicWorkflowInfoListAllOf } from '../models/WorkflowPendingDynamicWorkflowInfoListAllOf';
import { WorkflowPendingDynamicWorkflowInfoRelationship } from '../models/WorkflowPendingDynamicWorkflowInfoRelationship';
import { WorkflowPendingDynamicWorkflowInfoResponse } from '../models/WorkflowPendingDynamicWorkflowInfoResponse';
import { WorkflowPrimitiveArrayItem } from '../models/WorkflowPrimitiveArrayItem';
import { WorkflowPrimitiveArrayItemAllOf } from '../models/WorkflowPrimitiveArrayItemAllOf';
import { WorkflowPrimitiveDataProperty } from '../models/WorkflowPrimitiveDataProperty';
import { WorkflowPrimitiveDataPropertyAllOf } from '../models/WorkflowPrimitiveDataPropertyAllOf';
import { WorkflowPrimitiveDataType } from '../models/WorkflowPrimitiveDataType';
import { WorkflowPrimitiveDataTypeAllOf } from '../models/WorkflowPrimitiveDataTypeAllOf';
import { WorkflowProperties } from '../models/WorkflowProperties';
import { WorkflowPropertiesAllOf } from '../models/WorkflowPropertiesAllOf';
import { WorkflowStartTask } from '../models/WorkflowStartTask';
import { WorkflowStartTaskAllOf } from '../models/WorkflowStartTaskAllOf';
import { WorkflowSubWorkflowTask } from '../models/WorkflowSubWorkflowTask';
import { WorkflowSubWorkflowTaskAllOf } from '../models/WorkflowSubWorkflowTaskAllOf';
import { WorkflowSuccessEndTask } from '../models/WorkflowSuccessEndTask';
import { WorkflowTargetDataType } from '../models/WorkflowTargetDataType';
import { WorkflowTargetDataTypeAllOf } from '../models/WorkflowTargetDataTypeAllOf';
import { WorkflowTargetProperty } from '../models/WorkflowTargetProperty';
import { WorkflowTargetPropertyAllOf } from '../models/WorkflowTargetPropertyAllOf';
import { WorkflowTaskConstraints } from '../models/WorkflowTaskConstraints';
import { WorkflowTaskConstraintsAllOf } from '../models/WorkflowTaskConstraintsAllOf';
import { WorkflowTaskDefinition } from '../models/WorkflowTaskDefinition';
import { WorkflowTaskDefinitionAllOf } from '../models/WorkflowTaskDefinitionAllOf';
import { WorkflowTaskDefinitionList } from '../models/WorkflowTaskDefinitionList';
import { WorkflowTaskDefinitionListAllOf } from '../models/WorkflowTaskDefinitionListAllOf';
import { WorkflowTaskDefinitionRelationship } from '../models/WorkflowTaskDefinitionRelationship';
import { WorkflowTaskDefinitionResponse } from '../models/WorkflowTaskDefinitionResponse';
import { WorkflowTaskInfo } from '../models/WorkflowTaskInfo';
import { WorkflowTaskInfoAllOf } from '../models/WorkflowTaskInfoAllOf';
import { WorkflowTaskInfoList } from '../models/WorkflowTaskInfoList';
import { WorkflowTaskInfoListAllOf } from '../models/WorkflowTaskInfoListAllOf';
import { WorkflowTaskInfoRelationship } from '../models/WorkflowTaskInfoRelationship';
import { WorkflowTaskInfoResponse } from '../models/WorkflowTaskInfoResponse';
import { WorkflowTaskMeta } from '../models/WorkflowTaskMeta';
import { WorkflowTaskMetaAllOf } from '../models/WorkflowTaskMetaAllOf';
import { WorkflowTaskMetaList } from '../models/WorkflowTaskMetaList';
import { WorkflowTaskMetaListAllOf } from '../models/WorkflowTaskMetaListAllOf';
import { WorkflowTaskMetaResponse } from '../models/WorkflowTaskMetaResponse';
import { WorkflowTaskRetryInfo } from '../models/WorkflowTaskRetryInfo';
import { WorkflowTaskRetryInfoAllOf } from '../models/WorkflowTaskRetryInfoAllOf';
import { WorkflowValidationError } from '../models/WorkflowValidationError';
import { WorkflowValidationErrorAllOf } from '../models/WorkflowValidationErrorAllOf';
import { WorkflowValidationInformation } from '../models/WorkflowValidationInformation';
import { WorkflowValidationInformationAllOf } from '../models/WorkflowValidationInformationAllOf';
import { WorkflowWaitTask } from '../models/WorkflowWaitTask';
import { WorkflowWaitTaskAllOf } from '../models/WorkflowWaitTaskAllOf';
import { WorkflowWaitTaskPrompt } from '../models/WorkflowWaitTaskPrompt';
import { WorkflowWaitTaskPromptAllOf } from '../models/WorkflowWaitTaskPromptAllOf';
import { WorkflowWebApi } from '../models/WorkflowWebApi';
import { WorkflowWebApiAllOf } from '../models/WorkflowWebApiAllOf';
import { WorkflowWorkerTask } from '../models/WorkflowWorkerTask';
import { WorkflowWorkerTaskAllOf } from '../models/WorkflowWorkerTaskAllOf';
import { WorkflowWorkflowDefinition } from '../models/WorkflowWorkflowDefinition';
import { WorkflowWorkflowDefinitionAllOf } from '../models/WorkflowWorkflowDefinitionAllOf';
import { WorkflowWorkflowDefinitionList } from '../models/WorkflowWorkflowDefinitionList';
import { WorkflowWorkflowDefinitionListAllOf } from '../models/WorkflowWorkflowDefinitionListAllOf';
import { WorkflowWorkflowDefinitionRelationship } from '../models/WorkflowWorkflowDefinitionRelationship';
import { WorkflowWorkflowDefinitionResponse } from '../models/WorkflowWorkflowDefinitionResponse';
import { WorkflowWorkflowInfo } from '../models/WorkflowWorkflowInfo';
import { WorkflowWorkflowInfoAllOf } from '../models/WorkflowWorkflowInfoAllOf';
import { WorkflowWorkflowInfoList } from '../models/WorkflowWorkflowInfoList';
import { WorkflowWorkflowInfoListAllOf } from '../models/WorkflowWorkflowInfoListAllOf';
import { WorkflowWorkflowInfoProperties } from '../models/WorkflowWorkflowInfoProperties';
import { WorkflowWorkflowInfoPropertiesAllOf } from '../models/WorkflowWorkflowInfoPropertiesAllOf';
import { WorkflowWorkflowInfoRelationship } from '../models/WorkflowWorkflowInfoRelationship';
import { WorkflowWorkflowInfoResponse } from '../models/WorkflowWorkflowInfoResponse';
import { WorkflowWorkflowMeta } from '../models/WorkflowWorkflowMeta';
import { WorkflowWorkflowMetaAllOf } from '../models/WorkflowWorkflowMetaAllOf';
import { WorkflowWorkflowMetaList } from '../models/WorkflowWorkflowMetaList';
import { WorkflowWorkflowMetaListAllOf } from '../models/WorkflowWorkflowMetaListAllOf';
import { WorkflowWorkflowMetaResponse } from '../models/WorkflowWorkflowMetaResponse';
import { WorkflowWorkflowProperties } from '../models/WorkflowWorkflowProperties';
import { WorkflowWorkflowPropertiesAllOf } from '../models/WorkflowWorkflowPropertiesAllOf';
import { WorkflowWorkflowTask } from '../models/WorkflowWorkflowTask';
import { WorkflowWorkflowTaskAllOf } from '../models/WorkflowWorkflowTaskAllOf';
import { WorkflowXmlApi } from '../models/WorkflowXmlApi';
import { X509Certificate } from '../models/X509Certificate';
import { X509CertificateAllOf } from '../models/X509CertificateAllOf';
import { ObservableAaaApi } from './ObservableAPI';


import { AaaApiRequestFactory, AaaApiResponseProcessor} from "../apis/AaaApi";
export class PromiseAaaApi {
    private api: ObservableAaaApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AaaApiRequestFactory,
        responseProcessor?: AaaApiResponseProcessor
    ) {
        this.api = new ObservableAaaApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'aaa.AuditRecord' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAaaAuditRecordByMoid(moid: string, options?: Configuration): Promise<AaaAuditRecord> {
    	const result = this.api.getAaaAuditRecordByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'aaa.AuditRecord' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAaaAuditRecordList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AaaAuditRecordResponse> {
    	const result = this.api.getAaaAuditRecordList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableAdapterApi } from './ObservableAPI';


import { AdapterApiRequestFactory, AdapterApiResponseProcessor} from "../apis/AdapterApi";
export class PromiseAdapterApi {
    private api: ObservableAdapterApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AdapterApiRequestFactory,
        responseProcessor?: AdapterApiResponseProcessor
    ) {
        this.api = new ObservableAdapterApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'adapter.ConfigPolicy' resource.
     * @param adapterConfigPolicy The &#39;adapter.ConfigPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createAdapterConfigPolicy(adapterConfigPolicy: AdapterConfigPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<AdapterConfigPolicy> {
    	const result = this.api.createAdapterConfigPolicy(adapterConfigPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'adapter.ConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteAdapterConfigPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteAdapterConfigPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.ConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAdapterConfigPolicyByMoid(moid: string, options?: Configuration): Promise<AdapterConfigPolicy> {
    	const result = this.api.getAdapterConfigPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.ConfigPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAdapterConfigPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AdapterConfigPolicyResponse> {
    	const result = this.api.getAdapterConfigPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.ExtEthInterface' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAdapterExtEthInterfaceByMoid(moid: string, options?: Configuration): Promise<AdapterExtEthInterface> {
    	const result = this.api.getAdapterExtEthInterfaceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.ExtEthInterface' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAdapterExtEthInterfaceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AdapterExtEthInterfaceResponse> {
    	const result = this.api.getAdapterExtEthInterfaceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.HostEthInterface' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAdapterHostEthInterfaceByMoid(moid: string, options?: Configuration): Promise<AdapterHostEthInterface> {
    	const result = this.api.getAdapterHostEthInterfaceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.HostEthInterface' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAdapterHostEthInterfaceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AdapterHostEthInterfaceResponse> {
    	const result = this.api.getAdapterHostEthInterfaceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.HostFcInterface' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAdapterHostFcInterfaceByMoid(moid: string, options?: Configuration): Promise<AdapterHostFcInterface> {
    	const result = this.api.getAdapterHostFcInterfaceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.HostFcInterface' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAdapterHostFcInterfaceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AdapterHostFcInterfaceResponse> {
    	const result = this.api.getAdapterHostFcInterfaceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.HostIscsiInterface' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAdapterHostIscsiInterfaceByMoid(moid: string, options?: Configuration): Promise<AdapterHostIscsiInterface> {
    	const result = this.api.getAdapterHostIscsiInterfaceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.HostIscsiInterface' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAdapterHostIscsiInterfaceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AdapterHostIscsiInterfaceResponse> {
    	const result = this.api.getAdapterHostIscsiInterfaceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAdapterUnitByMoid(moid: string, options?: Configuration): Promise<AdapterUnit> {
    	const result = this.api.getAdapterUnitByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'adapter.Unit' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAdapterUnitList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AdapterUnitResponse> {
    	const result = this.api.getAdapterUnitList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'adapter.ConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param adapterConfigPolicy The &#39;adapter.ConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchAdapterConfigPolicy(moid: string, adapterConfigPolicy: AdapterConfigPolicy, ifMatch?: string, options?: Configuration): Promise<AdapterConfigPolicy> {
    	const result = this.api.patchAdapterConfigPolicy(moid, adapterConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'adapter.ConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param adapterConfigPolicy The &#39;adapter.ConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateAdapterConfigPolicy(moid: string, adapterConfigPolicy: AdapterConfigPolicy, ifMatch?: string, options?: Configuration): Promise<AdapterConfigPolicy> {
    	const result = this.api.updateAdapterConfigPolicy(moid, adapterConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableApplianceApi } from './ObservableAPI';


import { ApplianceApiRequestFactory, ApplianceApiResponseProcessor} from "../apis/ApplianceApi";
export class PromiseApplianceApi {
    private api: ObservableApplianceApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ApplianceApiRequestFactory,
        responseProcessor?: ApplianceApiResponseProcessor
    ) {
        this.api = new ObservableApplianceApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'appliance.Backup' resource.
     * @param applianceBackup The &#39;appliance.Backup&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createApplianceBackup(applianceBackup: ApplianceBackup, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ApplianceBackup> {
    	const result = this.api.createApplianceBackup(applianceBackup, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'appliance.BackupPolicy' resource.
     * @param applianceBackupPolicy The &#39;appliance.BackupPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createApplianceBackupPolicy(applianceBackupPolicy: ApplianceBackupPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ApplianceBackupPolicy> {
    	const result = this.api.createApplianceBackupPolicy(applianceBackupPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'appliance.DataExportPolicy' resource.
     * @param applianceDataExportPolicy The &#39;appliance.DataExportPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createApplianceDataExportPolicy(applianceDataExportPolicy: ApplianceDataExportPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ApplianceDataExportPolicy> {
    	const result = this.api.createApplianceDataExportPolicy(applianceDataExportPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'appliance.DeviceClaim' resource.
     * @param applianceDeviceClaim The &#39;appliance.DeviceClaim&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createApplianceDeviceClaim(applianceDeviceClaim: ApplianceDeviceClaim, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ApplianceDeviceClaim> {
    	const result = this.api.createApplianceDeviceClaim(applianceDeviceClaim, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'appliance.DiagSetting' resource.
     * @param applianceDiagSetting The &#39;appliance.DiagSetting&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createApplianceDiagSetting(applianceDiagSetting: ApplianceDiagSetting, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ApplianceDiagSetting> {
    	const result = this.api.createApplianceDiagSetting(applianceDiagSetting, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'appliance.Restore' resource.
     * @param applianceRestore The &#39;appliance.Restore&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createApplianceRestore(applianceRestore: ApplianceRestore, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ApplianceRestore> {
    	const result = this.api.createApplianceRestore(applianceRestore, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'appliance.Backup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteApplianceBackup(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteApplianceBackup(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'appliance.Restore' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteApplianceRestore(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteApplianceRestore(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.Backup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceBackupByMoid(moid: string, options?: Configuration): Promise<ApplianceBackup> {
    	const result = this.api.getApplianceBackupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.Backup' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceBackupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceBackupResponse> {
    	const result = this.api.getApplianceBackupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.BackupPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceBackupPolicyByMoid(moid: string, options?: Configuration): Promise<ApplianceBackupPolicy> {
    	const result = this.api.getApplianceBackupPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.BackupPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceBackupPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceBackupPolicyResponse> {
    	const result = this.api.getApplianceBackupPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.CertificateSetting' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceCertificateSettingByMoid(moid: string, options?: Configuration): Promise<ApplianceCertificateSetting> {
    	const result = this.api.getApplianceCertificateSettingByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.CertificateSetting' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceCertificateSettingList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceCertificateSettingResponse> {
    	const result = this.api.getApplianceCertificateSettingList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.DataExportPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceDataExportPolicyByMoid(moid: string, options?: Configuration): Promise<ApplianceDataExportPolicy> {
    	const result = this.api.getApplianceDataExportPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.DataExportPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceDataExportPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceDataExportPolicyResponse> {
    	const result = this.api.getApplianceDataExportPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.DeviceClaim' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceDeviceClaimByMoid(moid: string, options?: Configuration): Promise<ApplianceDeviceClaim> {
    	const result = this.api.getApplianceDeviceClaimByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.DeviceClaim' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceDeviceClaimList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceDeviceClaimResponse> {
    	const result = this.api.getApplianceDeviceClaimList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.DiagSetting' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceDiagSettingByMoid(moid: string, options?: Configuration): Promise<ApplianceDiagSetting> {
    	const result = this.api.getApplianceDiagSettingByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.DiagSetting' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceDiagSettingList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceDiagSettingResponse> {
    	const result = this.api.getApplianceDiagSettingList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.ImageBundle' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceImageBundleByMoid(moid: string, options?: Configuration): Promise<ApplianceImageBundle> {
    	const result = this.api.getApplianceImageBundleByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.ImageBundle' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceImageBundleList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceImageBundleResponse> {
    	const result = this.api.getApplianceImageBundleList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.NodeInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceNodeInfoByMoid(moid: string, options?: Configuration): Promise<ApplianceNodeInfo> {
    	const result = this.api.getApplianceNodeInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.NodeInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceNodeInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceNodeInfoResponse> {
    	const result = this.api.getApplianceNodeInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.ReleaseNote' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceReleaseNoteByMoid(moid: string, options?: Configuration): Promise<ApplianceReleaseNote> {
    	const result = this.api.getApplianceReleaseNoteByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.ReleaseNote' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceReleaseNoteList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceReleaseNoteResponse> {
    	const result = this.api.getApplianceReleaseNoteList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.Restore' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceRestoreByMoid(moid: string, options?: Configuration): Promise<ApplianceRestore> {
    	const result = this.api.getApplianceRestoreByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.Restore' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceRestoreList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceRestoreResponse> {
    	const result = this.api.getApplianceRestoreList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.SetupInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceSetupInfoByMoid(moid: string, options?: Configuration): Promise<ApplianceSetupInfo> {
    	const result = this.api.getApplianceSetupInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.SetupInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceSetupInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceSetupInfoResponse> {
    	const result = this.api.getApplianceSetupInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.SystemInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceSystemInfoByMoid(moid: string, options?: Configuration): Promise<ApplianceSystemInfo> {
    	const result = this.api.getApplianceSystemInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.SystemInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceSystemInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceSystemInfoResponse> {
    	const result = this.api.getApplianceSystemInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.Upgrade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceUpgradeByMoid(moid: string, options?: Configuration): Promise<ApplianceUpgrade> {
    	const result = this.api.getApplianceUpgradeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.Upgrade' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceUpgradeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceUpgradeResponse> {
    	const result = this.api.getApplianceUpgradeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.UpgradePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getApplianceUpgradePolicyByMoid(moid: string, options?: Configuration): Promise<ApplianceUpgradePolicy> {
    	const result = this.api.getApplianceUpgradePolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'appliance.UpgradePolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getApplianceUpgradePolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ApplianceUpgradePolicyResponse> {
    	const result = this.api.getApplianceUpgradePolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.BackupPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceBackupPolicy The &#39;appliance.BackupPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchApplianceBackupPolicy(moid: string, applianceBackupPolicy: ApplianceBackupPolicy, ifMatch?: string, options?: Configuration): Promise<ApplianceBackupPolicy> {
    	const result = this.api.patchApplianceBackupPolicy(moid, applianceBackupPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.CertificateSetting' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceCertificateSetting The &#39;appliance.CertificateSetting&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchApplianceCertificateSetting(moid: string, applianceCertificateSetting: ApplianceCertificateSetting, ifMatch?: string, options?: Configuration): Promise<ApplianceCertificateSetting> {
    	const result = this.api.patchApplianceCertificateSetting(moid, applianceCertificateSetting, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.DataExportPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceDataExportPolicy The &#39;appliance.DataExportPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchApplianceDataExportPolicy(moid: string, applianceDataExportPolicy: ApplianceDataExportPolicy, ifMatch?: string, options?: Configuration): Promise<ApplianceDataExportPolicy> {
    	const result = this.api.patchApplianceDataExportPolicy(moid, applianceDataExportPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.DiagSetting' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceDiagSetting The &#39;appliance.DiagSetting&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchApplianceDiagSetting(moid: string, applianceDiagSetting: ApplianceDiagSetting, ifMatch?: string, options?: Configuration): Promise<ApplianceDiagSetting> {
    	const result = this.api.patchApplianceDiagSetting(moid, applianceDiagSetting, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.SetupInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceSetupInfo The &#39;appliance.SetupInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchApplianceSetupInfo(moid: string, applianceSetupInfo: ApplianceSetupInfo, ifMatch?: string, options?: Configuration): Promise<ApplianceSetupInfo> {
    	const result = this.api.patchApplianceSetupInfo(moid, applianceSetupInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.Upgrade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceUpgrade The &#39;appliance.Upgrade&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchApplianceUpgrade(moid: string, applianceUpgrade: ApplianceUpgrade, ifMatch?: string, options?: Configuration): Promise<ApplianceUpgrade> {
    	const result = this.api.patchApplianceUpgrade(moid, applianceUpgrade, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.UpgradePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceUpgradePolicy The &#39;appliance.UpgradePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchApplianceUpgradePolicy(moid: string, applianceUpgradePolicy: ApplianceUpgradePolicy, ifMatch?: string, options?: Configuration): Promise<ApplianceUpgradePolicy> {
    	const result = this.api.patchApplianceUpgradePolicy(moid, applianceUpgradePolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.BackupPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceBackupPolicy The &#39;appliance.BackupPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateApplianceBackupPolicy(moid: string, applianceBackupPolicy: ApplianceBackupPolicy, ifMatch?: string, options?: Configuration): Promise<ApplianceBackupPolicy> {
    	const result = this.api.updateApplianceBackupPolicy(moid, applianceBackupPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.CertificateSetting' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceCertificateSetting The &#39;appliance.CertificateSetting&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateApplianceCertificateSetting(moid: string, applianceCertificateSetting: ApplianceCertificateSetting, ifMatch?: string, options?: Configuration): Promise<ApplianceCertificateSetting> {
    	const result = this.api.updateApplianceCertificateSetting(moid, applianceCertificateSetting, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.DataExportPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceDataExportPolicy The &#39;appliance.DataExportPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateApplianceDataExportPolicy(moid: string, applianceDataExportPolicy: ApplianceDataExportPolicy, ifMatch?: string, options?: Configuration): Promise<ApplianceDataExportPolicy> {
    	const result = this.api.updateApplianceDataExportPolicy(moid, applianceDataExportPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.DiagSetting' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceDiagSetting The &#39;appliance.DiagSetting&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateApplianceDiagSetting(moid: string, applianceDiagSetting: ApplianceDiagSetting, ifMatch?: string, options?: Configuration): Promise<ApplianceDiagSetting> {
    	const result = this.api.updateApplianceDiagSetting(moid, applianceDiagSetting, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.SetupInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceSetupInfo The &#39;appliance.SetupInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateApplianceSetupInfo(moid: string, applianceSetupInfo: ApplianceSetupInfo, ifMatch?: string, options?: Configuration): Promise<ApplianceSetupInfo> {
    	const result = this.api.updateApplianceSetupInfo(moid, applianceSetupInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.Upgrade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceUpgrade The &#39;appliance.Upgrade&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateApplianceUpgrade(moid: string, applianceUpgrade: ApplianceUpgrade, ifMatch?: string, options?: Configuration): Promise<ApplianceUpgrade> {
    	const result = this.api.updateApplianceUpgrade(moid, applianceUpgrade, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'appliance.UpgradePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param applianceUpgradePolicy The &#39;appliance.UpgradePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateApplianceUpgradePolicy(moid: string, applianceUpgradePolicy: ApplianceUpgradePolicy, ifMatch?: string, options?: Configuration): Promise<ApplianceUpgradePolicy> {
    	const result = this.api.updateApplianceUpgradePolicy(moid, applianceUpgradePolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableAssetApi } from './ObservableAPI';


import { AssetApiRequestFactory, AssetApiResponseProcessor} from "../apis/AssetApi";
export class PromiseAssetApi {
    private api: ObservableAssetApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AssetApiRequestFactory,
        responseProcessor?: AssetApiResponseProcessor
    ) {
        this.api = new ObservableAssetApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'asset.DeviceClaim' resource.
     * @param assetDeviceClaim The &#39;asset.DeviceClaim&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createAssetDeviceClaim(assetDeviceClaim: AssetDeviceClaim, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<AssetDeviceClaim> {
    	const result = this.api.createAssetDeviceClaim(assetDeviceClaim, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'asset.ManagedDevice' resource.
     * @param assetManagedDevice The &#39;asset.ManagedDevice&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createAssetManagedDevice(assetManagedDevice: AssetManagedDevice, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<AssetManagedDevice> {
    	const result = this.api.createAssetManagedDevice(assetManagedDevice, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'asset.Target' resource.
     * @param assetTarget The &#39;asset.Target&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createAssetTarget(assetTarget: AssetTarget, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<AssetTarget> {
    	const result = this.api.createAssetTarget(assetTarget, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'asset.DeviceClaim' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteAssetDeviceClaim(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteAssetDeviceClaim(moid, options);
        return result.toPromise();
    }
	
    /**
     * Deletes the resource representing the device connector. All associated REST resources will be deleted. In particular, inventory and operational data associated with this device will be deleted.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteAssetDeviceRegistration(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteAssetDeviceRegistration(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'asset.ManagedDevice' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteAssetManagedDevice(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteAssetManagedDevice(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'asset.Target' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteAssetTarget(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteAssetTarget(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.ClusterMember' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAssetClusterMemberByMoid(moid: string, options?: Configuration): Promise<AssetClusterMember> {
    	const result = this.api.getAssetClusterMemberByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.ClusterMember' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAssetClusterMemberList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AssetClusterMemberResponse> {
    	const result = this.api.getAssetClusterMemberList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.DeviceConfiguration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAssetDeviceConfigurationByMoid(moid: string, options?: Configuration): Promise<AssetDeviceConfiguration> {
    	const result = this.api.getAssetDeviceConfigurationByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.DeviceConfiguration' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAssetDeviceConfigurationList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AssetDeviceConfigurationResponse> {
    	const result = this.api.getAssetDeviceConfigurationList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.DeviceConnectorManager' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAssetDeviceConnectorManagerByMoid(moid: string, options?: Configuration): Promise<AssetDeviceConnectorManager> {
    	const result = this.api.getAssetDeviceConnectorManagerByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.DeviceConnectorManager' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAssetDeviceConnectorManagerList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AssetDeviceConnectorManagerResponse> {
    	const result = this.api.getAssetDeviceConnectorManagerList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.DeviceContractInformation' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAssetDeviceContractInformationByMoid(moid: string, options?: Configuration): Promise<AssetDeviceContractInformation> {
    	const result = this.api.getAssetDeviceContractInformationByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.DeviceContractInformation' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAssetDeviceContractInformationList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AssetDeviceContractInformationResponse> {
    	const result = this.api.getAssetDeviceContractInformationList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.DeviceRegistration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAssetDeviceRegistrationByMoid(moid: string, options?: Configuration): Promise<AssetDeviceRegistration> {
    	const result = this.api.getAssetDeviceRegistrationByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.DeviceRegistration' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAssetDeviceRegistrationList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AssetDeviceRegistrationResponse> {
    	const result = this.api.getAssetDeviceRegistrationList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.ManagedDevice' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAssetManagedDeviceByMoid(moid: string, options?: Configuration): Promise<AssetManagedDevice> {
    	const result = this.api.getAssetManagedDeviceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.ManagedDevice' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAssetManagedDeviceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AssetManagedDeviceResponse> {
    	const result = this.api.getAssetManagedDeviceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.Target' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getAssetTargetByMoid(moid: string, options?: Configuration): Promise<AssetTarget> {
    	const result = this.api.getAssetTargetByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'asset.Target' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getAssetTargetList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<AssetTargetResponse> {
    	const result = this.api.getAssetTargetList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'asset.DeviceConfiguration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetDeviceConfiguration The &#39;asset.DeviceConfiguration&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchAssetDeviceConfiguration(moid: string, assetDeviceConfiguration: AssetDeviceConfiguration, ifMatch?: string, options?: Configuration): Promise<AssetDeviceConfiguration> {
    	const result = this.api.patchAssetDeviceConfiguration(moid, assetDeviceConfiguration, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'asset.DeviceContractInformation' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetDeviceContractInformation The &#39;asset.DeviceContractInformation&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchAssetDeviceContractInformation(moid: string, assetDeviceContractInformation: AssetDeviceContractInformation, ifMatch?: string, options?: Configuration): Promise<AssetDeviceContractInformation> {
    	const result = this.api.patchAssetDeviceContractInformation(moid, assetDeviceContractInformation, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Updates the resource representing the device connector. For example, this can be used to annotate the device connector resource with user-specified tags.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetDeviceRegistration The &#39;asset.DeviceRegistration&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchAssetDeviceRegistration(moid: string, assetDeviceRegistration: AssetDeviceRegistration, ifMatch?: string, options?: Configuration): Promise<AssetDeviceRegistration> {
    	const result = this.api.patchAssetDeviceRegistration(moid, assetDeviceRegistration, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'asset.ManagedDevice' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetManagedDevice The &#39;asset.ManagedDevice&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchAssetManagedDevice(moid: string, assetManagedDevice: AssetManagedDevice, ifMatch?: string, options?: Configuration): Promise<AssetManagedDevice> {
    	const result = this.api.patchAssetManagedDevice(moid, assetManagedDevice, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'asset.Target' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetTarget The &#39;asset.Target&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchAssetTarget(moid: string, assetTarget: AssetTarget, ifMatch?: string, options?: Configuration): Promise<AssetTarget> {
    	const result = this.api.patchAssetTarget(moid, assetTarget, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'asset.DeviceConfiguration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetDeviceConfiguration The &#39;asset.DeviceConfiguration&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateAssetDeviceConfiguration(moid: string, assetDeviceConfiguration: AssetDeviceConfiguration, ifMatch?: string, options?: Configuration): Promise<AssetDeviceConfiguration> {
    	const result = this.api.updateAssetDeviceConfiguration(moid, assetDeviceConfiguration, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'asset.DeviceContractInformation' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetDeviceContractInformation The &#39;asset.DeviceContractInformation&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateAssetDeviceContractInformation(moid: string, assetDeviceContractInformation: AssetDeviceContractInformation, ifMatch?: string, options?: Configuration): Promise<AssetDeviceContractInformation> {
    	const result = this.api.updateAssetDeviceContractInformation(moid, assetDeviceContractInformation, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Updates the resource representing the device connector. For example, this can be used to annotate the device connector resource with user-specified tags.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetDeviceRegistration The &#39;asset.DeviceRegistration&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateAssetDeviceRegistration(moid: string, assetDeviceRegistration: AssetDeviceRegistration, ifMatch?: string, options?: Configuration): Promise<AssetDeviceRegistration> {
    	const result = this.api.updateAssetDeviceRegistration(moid, assetDeviceRegistration, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'asset.ManagedDevice' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetManagedDevice The &#39;asset.ManagedDevice&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateAssetManagedDevice(moid: string, assetManagedDevice: AssetManagedDevice, ifMatch?: string, options?: Configuration): Promise<AssetManagedDevice> {
    	const result = this.api.updateAssetManagedDevice(moid, assetManagedDevice, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'asset.Target' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param assetTarget The &#39;asset.Target&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateAssetTarget(moid: string, assetTarget: AssetTarget, ifMatch?: string, options?: Configuration): Promise<AssetTarget> {
    	const result = this.api.updateAssetTarget(moid, assetTarget, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableBiosApi } from './ObservableAPI';


import { BiosApiRequestFactory, BiosApiResponseProcessor} from "../apis/BiosApi";
export class PromiseBiosApi {
    private api: ObservableBiosApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BiosApiRequestFactory,
        responseProcessor?: BiosApiResponseProcessor
    ) {
        this.api = new ObservableBiosApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'bios.Policy' resource.
     * @param biosPolicy The &#39;bios.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createBiosPolicy(biosPolicy: BiosPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<BiosPolicy> {
    	const result = this.api.createBiosPolicy(biosPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'bios.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteBiosPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteBiosPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'bios.BootMode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getBiosBootModeByMoid(moid: string, options?: Configuration): Promise<BiosBootMode> {
    	const result = this.api.getBiosBootModeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'bios.BootMode' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getBiosBootModeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<BiosBootModeResponse> {
    	const result = this.api.getBiosBootModeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'bios.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getBiosPolicyByMoid(moid: string, options?: Configuration): Promise<BiosPolicy> {
    	const result = this.api.getBiosPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'bios.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getBiosPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<BiosPolicyResponse> {
    	const result = this.api.getBiosPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'bios.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getBiosUnitByMoid(moid: string, options?: Configuration): Promise<BiosUnit> {
    	const result = this.api.getBiosUnitByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'bios.Unit' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getBiosUnitList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<BiosUnitResponse> {
    	const result = this.api.getBiosUnitList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'bios.BootMode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param biosBootMode The &#39;bios.BootMode&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchBiosBootMode(moid: string, biosBootMode: BiosBootMode, ifMatch?: string, options?: Configuration): Promise<BiosBootMode> {
    	const result = this.api.patchBiosBootMode(moid, biosBootMode, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'bios.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param biosPolicy The &#39;bios.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchBiosPolicy(moid: string, biosPolicy: BiosPolicy, ifMatch?: string, options?: Configuration): Promise<BiosPolicy> {
    	const result = this.api.patchBiosPolicy(moid, biosPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'bios.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param biosUnit The &#39;bios.Unit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchBiosUnit(moid: string, biosUnit: BiosUnit, ifMatch?: string, options?: Configuration): Promise<BiosUnit> {
    	const result = this.api.patchBiosUnit(moid, biosUnit, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'bios.BootMode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param biosBootMode The &#39;bios.BootMode&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateBiosBootMode(moid: string, biosBootMode: BiosBootMode, ifMatch?: string, options?: Configuration): Promise<BiosBootMode> {
    	const result = this.api.updateBiosBootMode(moid, biosBootMode, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'bios.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param biosPolicy The &#39;bios.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateBiosPolicy(moid: string, biosPolicy: BiosPolicy, ifMatch?: string, options?: Configuration): Promise<BiosPolicy> {
    	const result = this.api.updateBiosPolicy(moid, biosPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'bios.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param biosUnit The &#39;bios.Unit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateBiosUnit(moid: string, biosUnit: BiosUnit, ifMatch?: string, options?: Configuration): Promise<BiosUnit> {
    	const result = this.api.updateBiosUnit(moid, biosUnit, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableBootApi } from './ObservableAPI';


import { BootApiRequestFactory, BootApiResponseProcessor} from "../apis/BootApi";
export class PromiseBootApi {
    private api: ObservableBootApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BootApiRequestFactory,
        responseProcessor?: BootApiResponseProcessor
    ) {
        this.api = new ObservableBootApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'boot.PrecisionPolicy' resource.
     * @param bootPrecisionPolicy The &#39;boot.PrecisionPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createBootPrecisionPolicy(bootPrecisionPolicy: BootPrecisionPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<BootPrecisionPolicy> {
    	const result = this.api.createBootPrecisionPolicy(bootPrecisionPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'boot.PrecisionPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteBootPrecisionPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteBootPrecisionPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'boot.DeviceBootMode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getBootDeviceBootModeByMoid(moid: string, options?: Configuration): Promise<BootDeviceBootMode> {
    	const result = this.api.getBootDeviceBootModeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'boot.DeviceBootMode' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getBootDeviceBootModeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<BootDeviceBootModeResponse> {
    	const result = this.api.getBootDeviceBootModeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'boot.PrecisionPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getBootPrecisionPolicyByMoid(moid: string, options?: Configuration): Promise<BootPrecisionPolicy> {
    	const result = this.api.getBootPrecisionPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'boot.PrecisionPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getBootPrecisionPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<BootPrecisionPolicyResponse> {
    	const result = this.api.getBootPrecisionPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'boot.DeviceBootMode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param bootDeviceBootMode The &#39;boot.DeviceBootMode&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchBootDeviceBootMode(moid: string, bootDeviceBootMode: BootDeviceBootMode, ifMatch?: string, options?: Configuration): Promise<BootDeviceBootMode> {
    	const result = this.api.patchBootDeviceBootMode(moid, bootDeviceBootMode, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'boot.PrecisionPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param bootPrecisionPolicy The &#39;boot.PrecisionPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchBootPrecisionPolicy(moid: string, bootPrecisionPolicy: BootPrecisionPolicy, ifMatch?: string, options?: Configuration): Promise<BootPrecisionPolicy> {
    	const result = this.api.patchBootPrecisionPolicy(moid, bootPrecisionPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'boot.DeviceBootMode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param bootDeviceBootMode The &#39;boot.DeviceBootMode&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateBootDeviceBootMode(moid: string, bootDeviceBootMode: BootDeviceBootMode, ifMatch?: string, options?: Configuration): Promise<BootDeviceBootMode> {
    	const result = this.api.updateBootDeviceBootMode(moid, bootDeviceBootMode, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'boot.PrecisionPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param bootPrecisionPolicy The &#39;boot.PrecisionPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateBootPrecisionPolicy(moid: string, bootPrecisionPolicy: BootPrecisionPolicy, ifMatch?: string, options?: Configuration): Promise<BootPrecisionPolicy> {
    	const result = this.api.updateBootPrecisionPolicy(moid, bootPrecisionPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableComputeApi } from './ObservableAPI';


import { ComputeApiRequestFactory, ComputeApiResponseProcessor} from "../apis/ComputeApi";
export class PromiseComputeApi {
    private api: ObservableComputeApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ComputeApiRequestFactory,
        responseProcessor?: ComputeApiResponseProcessor
    ) {
        this.api = new ObservableComputeApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'compute.Blade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getComputeBladeByMoid(moid: string, options?: Configuration): Promise<ComputeBlade> {
    	const result = this.api.getComputeBladeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'compute.Blade' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getComputeBladeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ComputeBladeResponse> {
    	const result = this.api.getComputeBladeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'compute.Board' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getComputeBoardByMoid(moid: string, options?: Configuration): Promise<ComputeBoard> {
    	const result = this.api.getComputeBoardByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'compute.Board' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getComputeBoardList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ComputeBoardResponse> {
    	const result = this.api.getComputeBoardList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'compute.PhysicalSummary' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getComputePhysicalSummaryByMoid(moid: string, options?: Configuration): Promise<ComputePhysicalSummary> {
    	const result = this.api.getComputePhysicalSummaryByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'compute.PhysicalSummary' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getComputePhysicalSummaryList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ComputePhysicalSummaryResponse> {
    	const result = this.api.getComputePhysicalSummaryList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'compute.RackUnit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getComputeRackUnitByMoid(moid: string, options?: Configuration): Promise<ComputeRackUnit> {
    	const result = this.api.getComputeRackUnitByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'compute.RackUnit' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getComputeRackUnitList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ComputeRackUnitResponse> {
    	const result = this.api.getComputeRackUnitList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'compute.ServerSetting' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getComputeServerSettingByMoid(moid: string, options?: Configuration): Promise<ComputeServerSetting> {
    	const result = this.api.getComputeServerSettingByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'compute.ServerSetting' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getComputeServerSettingList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ComputeServerSettingResponse> {
    	const result = this.api.getComputeServerSettingList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'compute.Blade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param computeBlade The &#39;compute.Blade&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchComputeBlade(moid: string, computeBlade: ComputeBlade, ifMatch?: string, options?: Configuration): Promise<ComputeBlade> {
    	const result = this.api.patchComputeBlade(moid, computeBlade, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'compute.Board' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param computeBoard The &#39;compute.Board&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchComputeBoard(moid: string, computeBoard: ComputeBoard, ifMatch?: string, options?: Configuration): Promise<ComputeBoard> {
    	const result = this.api.patchComputeBoard(moid, computeBoard, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'compute.RackUnit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param computeRackUnit The &#39;compute.RackUnit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchComputeRackUnit(moid: string, computeRackUnit: ComputeRackUnit, ifMatch?: string, options?: Configuration): Promise<ComputeRackUnit> {
    	const result = this.api.patchComputeRackUnit(moid, computeRackUnit, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'compute.ServerSetting' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param computeServerSetting The &#39;compute.ServerSetting&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchComputeServerSetting(moid: string, computeServerSetting: ComputeServerSetting, ifMatch?: string, options?: Configuration): Promise<ComputeServerSetting> {
    	const result = this.api.patchComputeServerSetting(moid, computeServerSetting, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'compute.Blade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param computeBlade The &#39;compute.Blade&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateComputeBlade(moid: string, computeBlade: ComputeBlade, ifMatch?: string, options?: Configuration): Promise<ComputeBlade> {
    	const result = this.api.updateComputeBlade(moid, computeBlade, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'compute.Board' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param computeBoard The &#39;compute.Board&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateComputeBoard(moid: string, computeBoard: ComputeBoard, ifMatch?: string, options?: Configuration): Promise<ComputeBoard> {
    	const result = this.api.updateComputeBoard(moid, computeBoard, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'compute.RackUnit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param computeRackUnit The &#39;compute.RackUnit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateComputeRackUnit(moid: string, computeRackUnit: ComputeRackUnit, ifMatch?: string, options?: Configuration): Promise<ComputeRackUnit> {
    	const result = this.api.updateComputeRackUnit(moid, computeRackUnit, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'compute.ServerSetting' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param computeServerSetting The &#39;compute.ServerSetting&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateComputeServerSetting(moid: string, computeServerSetting: ComputeServerSetting, ifMatch?: string, options?: Configuration): Promise<ComputeServerSetting> {
    	const result = this.api.updateComputeServerSetting(moid, computeServerSetting, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableCondApi } from './ObservableAPI';


import { CondApiRequestFactory, CondApiResponseProcessor} from "../apis/CondApi";
export class PromiseCondApi {
    private api: ObservableCondApi

    public constructor(
        configuration: Configuration,
        requestFactory?: CondApiRequestFactory,
        responseProcessor?: CondApiResponseProcessor
    ) {
        this.api = new ObservableCondApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'cond.Alarm' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getCondAlarmByMoid(moid: string, options?: Configuration): Promise<CondAlarm> {
    	const result = this.api.getCondAlarmByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'cond.Alarm' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getCondAlarmList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<CondAlarmResponse> {
    	const result = this.api.getCondAlarmList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'cond.HclStatus' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getCondHclStatusByMoid(moid: string, options?: Configuration): Promise<CondHclStatus> {
    	const result = this.api.getCondHclStatusByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'cond.HclStatusDetail' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getCondHclStatusDetailByMoid(moid: string, options?: Configuration): Promise<CondHclStatusDetail> {
    	const result = this.api.getCondHclStatusDetailByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'cond.HclStatusDetail' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getCondHclStatusDetailList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<CondHclStatusDetailResponse> {
    	const result = this.api.getCondHclStatusDetailList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'cond.HclStatusJob' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getCondHclStatusJobByMoid(moid: string, options?: Configuration): Promise<CondHclStatusJob> {
    	const result = this.api.getCondHclStatusJobByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'cond.HclStatusJob' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getCondHclStatusJobList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<CondHclStatusJobResponse> {
    	const result = this.api.getCondHclStatusJobList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'cond.HclStatus' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getCondHclStatusList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<CondHclStatusResponse> {
    	const result = this.api.getCondHclStatusList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableConnectorpackApi } from './ObservableAPI';


import { ConnectorpackApiRequestFactory, ConnectorpackApiResponseProcessor} from "../apis/ConnectorpackApi";
export class PromiseConnectorpackApi {
    private api: ObservableConnectorpackApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ConnectorpackApiRequestFactory,
        responseProcessor?: ConnectorpackApiResponseProcessor
    ) {
        this.api = new ObservableConnectorpackApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'connectorpack.ConnectorPackUpgrade' resource.
     * @param connectorpackConnectorPackUpgrade The &#39;connectorpack.ConnectorPackUpgrade&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createConnectorpackConnectorPackUpgrade(connectorpackConnectorPackUpgrade: ConnectorpackConnectorPackUpgrade, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ConnectorpackConnectorPackUpgrade> {
    	const result = this.api.createConnectorpackConnectorPackUpgrade(connectorpackConnectorPackUpgrade, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'connectorpack.ConnectorPackUpgrade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteConnectorpackConnectorPackUpgrade(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteConnectorpackConnectorPackUpgrade(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'connectorpack.ConnectorPackUpgrade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getConnectorpackConnectorPackUpgradeByMoid(moid: string, options?: Configuration): Promise<ConnectorpackConnectorPackUpgrade> {
    	const result = this.api.getConnectorpackConnectorPackUpgradeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'connectorpack.ConnectorPackUpgrade' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getConnectorpackConnectorPackUpgradeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ConnectorpackConnectorPackUpgradeResponse> {
    	const result = this.api.getConnectorpackConnectorPackUpgradeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'connectorpack.UpgradeImpact' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getConnectorpackUpgradeImpactByMoid(moid: string, options?: Configuration): Promise<ConnectorpackUpgradeImpact> {
    	const result = this.api.getConnectorpackUpgradeImpactByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'connectorpack.UpgradeImpact' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getConnectorpackUpgradeImpactList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ConnectorpackUpgradeImpactResponse> {
    	const result = this.api.getConnectorpackUpgradeImpactList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableDeviceconnectorApi } from './ObservableAPI';


import { DeviceconnectorApiRequestFactory, DeviceconnectorApiResponseProcessor} from "../apis/DeviceconnectorApi";
export class PromiseDeviceconnectorApi {
    private api: ObservableDeviceconnectorApi

    public constructor(
        configuration: Configuration,
        requestFactory?: DeviceconnectorApiRequestFactory,
        responseProcessor?: DeviceconnectorApiResponseProcessor
    ) {
        this.api = new ObservableDeviceconnectorApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'deviceconnector.Policy' resource.
     * @param deviceconnectorPolicy The &#39;deviceconnector.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createDeviceconnectorPolicy(deviceconnectorPolicy: DeviceconnectorPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<DeviceconnectorPolicy> {
    	const result = this.api.createDeviceconnectorPolicy(deviceconnectorPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'deviceconnector.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteDeviceconnectorPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteDeviceconnectorPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'deviceconnector.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getDeviceconnectorPolicyByMoid(moid: string, options?: Configuration): Promise<DeviceconnectorPolicy> {
    	const result = this.api.getDeviceconnectorPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'deviceconnector.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getDeviceconnectorPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<DeviceconnectorPolicyResponse> {
    	const result = this.api.getDeviceconnectorPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'deviceconnector.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param deviceconnectorPolicy The &#39;deviceconnector.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchDeviceconnectorPolicy(moid: string, deviceconnectorPolicy: DeviceconnectorPolicy, ifMatch?: string, options?: Configuration): Promise<DeviceconnectorPolicy> {
    	const result = this.api.patchDeviceconnectorPolicy(moid, deviceconnectorPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'deviceconnector.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param deviceconnectorPolicy The &#39;deviceconnector.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateDeviceconnectorPolicy(moid: string, deviceconnectorPolicy: DeviceconnectorPolicy, ifMatch?: string, options?: Configuration): Promise<DeviceconnectorPolicy> {
    	const result = this.api.updateDeviceconnectorPolicy(moid, deviceconnectorPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableEquipmentApi } from './ObservableAPI';


import { EquipmentApiRequestFactory, EquipmentApiResponseProcessor} from "../apis/EquipmentApi";
export class PromiseEquipmentApi {
    private api: ObservableEquipmentApi

    public constructor(
        configuration: Configuration,
        requestFactory?: EquipmentApiRequestFactory,
        responseProcessor?: EquipmentApiResponseProcessor
    ) {
        this.api = new ObservableEquipmentApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'equipment.Chassis' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentChassisByMoid(moid: string, options?: Configuration): Promise<EquipmentChassis> {
    	const result = this.api.getEquipmentChassisByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.Chassis' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentChassisList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentChassisResponse> {
    	const result = this.api.getEquipmentChassisList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.DeviceSummary' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentDeviceSummaryByMoid(moid: string, options?: Configuration): Promise<EquipmentDeviceSummary> {
    	const result = this.api.getEquipmentDeviceSummaryByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.DeviceSummary' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentDeviceSummaryList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentDeviceSummaryResponse> {
    	const result = this.api.getEquipmentDeviceSummaryList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.Fan' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentFanByMoid(moid: string, options?: Configuration): Promise<EquipmentFan> {
    	const result = this.api.getEquipmentFanByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.Fan' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentFanList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentFanResponse> {
    	const result = this.api.getEquipmentFanList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.FanModule' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentFanModuleByMoid(moid: string, options?: Configuration): Promise<EquipmentFanModule> {
    	const result = this.api.getEquipmentFanModuleByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.FanModule' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentFanModuleList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentFanModuleResponse> {
    	const result = this.api.getEquipmentFanModuleList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.Fex' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentFexByMoid(moid: string, options?: Configuration): Promise<EquipmentFex> {
    	const result = this.api.getEquipmentFexByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.Fex' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentFexList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentFexResponse> {
    	const result = this.api.getEquipmentFexList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.IoCard' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentIoCardByMoid(moid: string, options?: Configuration): Promise<EquipmentIoCard> {
    	const result = this.api.getEquipmentIoCardByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.IoCard' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentIoCardList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentIoCardResponse> {
    	const result = this.api.getEquipmentIoCardList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.IoExpander' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentIoExpanderByMoid(moid: string, options?: Configuration): Promise<EquipmentIoExpander> {
    	const result = this.api.getEquipmentIoExpanderByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.IoExpander' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentIoExpanderList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentIoExpanderResponse> {
    	const result = this.api.getEquipmentIoExpanderList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.LocatorLed' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentLocatorLedByMoid(moid: string, options?: Configuration): Promise<EquipmentLocatorLed> {
    	const result = this.api.getEquipmentLocatorLedByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.LocatorLed' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentLocatorLedList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentLocatorLedResponse> {
    	const result = this.api.getEquipmentLocatorLedList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.Psu' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentPsuByMoid(moid: string, options?: Configuration): Promise<EquipmentPsu> {
    	const result = this.api.getEquipmentPsuByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.Psu' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentPsuList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentPsuResponse> {
    	const result = this.api.getEquipmentPsuList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.RackEnclosure' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentRackEnclosureByMoid(moid: string, options?: Configuration): Promise<EquipmentRackEnclosure> {
    	const result = this.api.getEquipmentRackEnclosureByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.RackEnclosure' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentRackEnclosureList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentRackEnclosureResponse> {
    	const result = this.api.getEquipmentRackEnclosureList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.RackEnclosureSlot' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentRackEnclosureSlotByMoid(moid: string, options?: Configuration): Promise<EquipmentRackEnclosureSlot> {
    	const result = this.api.getEquipmentRackEnclosureSlotByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.RackEnclosureSlot' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentRackEnclosureSlotList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentRackEnclosureSlotResponse> {
    	const result = this.api.getEquipmentRackEnclosureSlotList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.SharedIoModule' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentSharedIoModuleByMoid(moid: string, options?: Configuration): Promise<EquipmentSharedIoModule> {
    	const result = this.api.getEquipmentSharedIoModuleByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.SharedIoModule' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentSharedIoModuleList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentSharedIoModuleResponse> {
    	const result = this.api.getEquipmentSharedIoModuleList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.SwitchCard' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentSwitchCardByMoid(moid: string, options?: Configuration): Promise<EquipmentSwitchCard> {
    	const result = this.api.getEquipmentSwitchCardByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.SwitchCard' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentSwitchCardList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentSwitchCardResponse> {
    	const result = this.api.getEquipmentSwitchCardList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.SystemIoController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentSystemIoControllerByMoid(moid: string, options?: Configuration): Promise<EquipmentSystemIoController> {
    	const result = this.api.getEquipmentSystemIoControllerByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.SystemIoController' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentSystemIoControllerList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentSystemIoControllerResponse> {
    	const result = this.api.getEquipmentSystemIoControllerList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.Tpm' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEquipmentTpmByMoid(moid: string, options?: Configuration): Promise<EquipmentTpm> {
    	const result = this.api.getEquipmentTpmByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'equipment.Tpm' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEquipmentTpmList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EquipmentTpmResponse> {
    	const result = this.api.getEquipmentTpmList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Chassis' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentChassis The &#39;equipment.Chassis&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentChassis(moid: string, equipmentChassis: EquipmentChassis, ifMatch?: string, options?: Configuration): Promise<EquipmentChassis> {
    	const result = this.api.patchEquipmentChassis(moid, equipmentChassis, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Fan' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentFan The &#39;equipment.Fan&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentFan(moid: string, equipmentFan: EquipmentFan, ifMatch?: string, options?: Configuration): Promise<EquipmentFan> {
    	const result = this.api.patchEquipmentFan(moid, equipmentFan, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.FanModule' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentFanModule The &#39;equipment.FanModule&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentFanModule(moid: string, equipmentFanModule: EquipmentFanModule, ifMatch?: string, options?: Configuration): Promise<EquipmentFanModule> {
    	const result = this.api.patchEquipmentFanModule(moid, equipmentFanModule, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Fex' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentFex The &#39;equipment.Fex&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentFex(moid: string, equipmentFex: EquipmentFex, ifMatch?: string, options?: Configuration): Promise<EquipmentFex> {
    	const result = this.api.patchEquipmentFex(moid, equipmentFex, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.IoCard' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentIoCard The &#39;equipment.IoCard&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentIoCard(moid: string, equipmentIoCard: EquipmentIoCard, ifMatch?: string, options?: Configuration): Promise<EquipmentIoCard> {
    	const result = this.api.patchEquipmentIoCard(moid, equipmentIoCard, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.IoExpander' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentIoExpander The &#39;equipment.IoExpander&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentIoExpander(moid: string, equipmentIoExpander: EquipmentIoExpander, ifMatch?: string, options?: Configuration): Promise<EquipmentIoExpander> {
    	const result = this.api.patchEquipmentIoExpander(moid, equipmentIoExpander, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.LocatorLed' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentLocatorLed The &#39;equipment.LocatorLed&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentLocatorLed(moid: string, equipmentLocatorLed: EquipmentLocatorLed, ifMatch?: string, options?: Configuration): Promise<EquipmentLocatorLed> {
    	const result = this.api.patchEquipmentLocatorLed(moid, equipmentLocatorLed, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Psu' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentPsu The &#39;equipment.Psu&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentPsu(moid: string, equipmentPsu: EquipmentPsu, ifMatch?: string, options?: Configuration): Promise<EquipmentPsu> {
    	const result = this.api.patchEquipmentPsu(moid, equipmentPsu, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.RackEnclosure' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentRackEnclosure The &#39;equipment.RackEnclosure&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentRackEnclosure(moid: string, equipmentRackEnclosure: EquipmentRackEnclosure, ifMatch?: string, options?: Configuration): Promise<EquipmentRackEnclosure> {
    	const result = this.api.patchEquipmentRackEnclosure(moid, equipmentRackEnclosure, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.RackEnclosureSlot' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentRackEnclosureSlot The &#39;equipment.RackEnclosureSlot&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentRackEnclosureSlot(moid: string, equipmentRackEnclosureSlot: EquipmentRackEnclosureSlot, ifMatch?: string, options?: Configuration): Promise<EquipmentRackEnclosureSlot> {
    	const result = this.api.patchEquipmentRackEnclosureSlot(moid, equipmentRackEnclosureSlot, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.SharedIoModule' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentSharedIoModule The &#39;equipment.SharedIoModule&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentSharedIoModule(moid: string, equipmentSharedIoModule: EquipmentSharedIoModule, ifMatch?: string, options?: Configuration): Promise<EquipmentSharedIoModule> {
    	const result = this.api.patchEquipmentSharedIoModule(moid, equipmentSharedIoModule, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.SwitchCard' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentSwitchCard The &#39;equipment.SwitchCard&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentSwitchCard(moid: string, equipmentSwitchCard: EquipmentSwitchCard, ifMatch?: string, options?: Configuration): Promise<EquipmentSwitchCard> {
    	const result = this.api.patchEquipmentSwitchCard(moid, equipmentSwitchCard, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.SystemIoController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentSystemIoController The &#39;equipment.SystemIoController&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentSystemIoController(moid: string, equipmentSystemIoController: EquipmentSystemIoController, ifMatch?: string, options?: Configuration): Promise<EquipmentSystemIoController> {
    	const result = this.api.patchEquipmentSystemIoController(moid, equipmentSystemIoController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Tpm' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentTpm The &#39;equipment.Tpm&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEquipmentTpm(moid: string, equipmentTpm: EquipmentTpm, ifMatch?: string, options?: Configuration): Promise<EquipmentTpm> {
    	const result = this.api.patchEquipmentTpm(moid, equipmentTpm, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Chassis' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentChassis The &#39;equipment.Chassis&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentChassis(moid: string, equipmentChassis: EquipmentChassis, ifMatch?: string, options?: Configuration): Promise<EquipmentChassis> {
    	const result = this.api.updateEquipmentChassis(moid, equipmentChassis, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Fan' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentFan The &#39;equipment.Fan&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentFan(moid: string, equipmentFan: EquipmentFan, ifMatch?: string, options?: Configuration): Promise<EquipmentFan> {
    	const result = this.api.updateEquipmentFan(moid, equipmentFan, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.FanModule' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentFanModule The &#39;equipment.FanModule&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentFanModule(moid: string, equipmentFanModule: EquipmentFanModule, ifMatch?: string, options?: Configuration): Promise<EquipmentFanModule> {
    	const result = this.api.updateEquipmentFanModule(moid, equipmentFanModule, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Fex' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentFex The &#39;equipment.Fex&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentFex(moid: string, equipmentFex: EquipmentFex, ifMatch?: string, options?: Configuration): Promise<EquipmentFex> {
    	const result = this.api.updateEquipmentFex(moid, equipmentFex, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.IoCard' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentIoCard The &#39;equipment.IoCard&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentIoCard(moid: string, equipmentIoCard: EquipmentIoCard, ifMatch?: string, options?: Configuration): Promise<EquipmentIoCard> {
    	const result = this.api.updateEquipmentIoCard(moid, equipmentIoCard, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.IoExpander' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentIoExpander The &#39;equipment.IoExpander&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentIoExpander(moid: string, equipmentIoExpander: EquipmentIoExpander, ifMatch?: string, options?: Configuration): Promise<EquipmentIoExpander> {
    	const result = this.api.updateEquipmentIoExpander(moid, equipmentIoExpander, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.LocatorLed' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentLocatorLed The &#39;equipment.LocatorLed&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentLocatorLed(moid: string, equipmentLocatorLed: EquipmentLocatorLed, ifMatch?: string, options?: Configuration): Promise<EquipmentLocatorLed> {
    	const result = this.api.updateEquipmentLocatorLed(moid, equipmentLocatorLed, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Psu' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentPsu The &#39;equipment.Psu&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentPsu(moid: string, equipmentPsu: EquipmentPsu, ifMatch?: string, options?: Configuration): Promise<EquipmentPsu> {
    	const result = this.api.updateEquipmentPsu(moid, equipmentPsu, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.RackEnclosure' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentRackEnclosure The &#39;equipment.RackEnclosure&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentRackEnclosure(moid: string, equipmentRackEnclosure: EquipmentRackEnclosure, ifMatch?: string, options?: Configuration): Promise<EquipmentRackEnclosure> {
    	const result = this.api.updateEquipmentRackEnclosure(moid, equipmentRackEnclosure, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.RackEnclosureSlot' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentRackEnclosureSlot The &#39;equipment.RackEnclosureSlot&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentRackEnclosureSlot(moid: string, equipmentRackEnclosureSlot: EquipmentRackEnclosureSlot, ifMatch?: string, options?: Configuration): Promise<EquipmentRackEnclosureSlot> {
    	const result = this.api.updateEquipmentRackEnclosureSlot(moid, equipmentRackEnclosureSlot, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.SharedIoModule' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentSharedIoModule The &#39;equipment.SharedIoModule&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentSharedIoModule(moid: string, equipmentSharedIoModule: EquipmentSharedIoModule, ifMatch?: string, options?: Configuration): Promise<EquipmentSharedIoModule> {
    	const result = this.api.updateEquipmentSharedIoModule(moid, equipmentSharedIoModule, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.SwitchCard' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentSwitchCard The &#39;equipment.SwitchCard&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentSwitchCard(moid: string, equipmentSwitchCard: EquipmentSwitchCard, ifMatch?: string, options?: Configuration): Promise<EquipmentSwitchCard> {
    	const result = this.api.updateEquipmentSwitchCard(moid, equipmentSwitchCard, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.SystemIoController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentSystemIoController The &#39;equipment.SystemIoController&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentSystemIoController(moid: string, equipmentSystemIoController: EquipmentSystemIoController, ifMatch?: string, options?: Configuration): Promise<EquipmentSystemIoController> {
    	const result = this.api.updateEquipmentSystemIoController(moid, equipmentSystemIoController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'equipment.Tpm' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param equipmentTpm The &#39;equipment.Tpm&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEquipmentTpm(moid: string, equipmentTpm: EquipmentTpm, ifMatch?: string, options?: Configuration): Promise<EquipmentTpm> {
    	const result = this.api.updateEquipmentTpm(moid, equipmentTpm, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableEtherApi } from './ObservableAPI';


import { EtherApiRequestFactory, EtherApiResponseProcessor} from "../apis/EtherApi";
export class PromiseEtherApi {
    private api: ObservableEtherApi

    public constructor(
        configuration: Configuration,
        requestFactory?: EtherApiRequestFactory,
        responseProcessor?: EtherApiResponseProcessor
    ) {
        this.api = new ObservableEtherApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'ether.PhysicalPort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getEtherPhysicalPortByMoid(moid: string, options?: Configuration): Promise<EtherPhysicalPort> {
    	const result = this.api.getEtherPhysicalPortByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ether.PhysicalPort' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getEtherPhysicalPortList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<EtherPhysicalPortResponse> {
    	const result = this.api.getEtherPhysicalPortList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ether.PhysicalPort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param etherPhysicalPort The &#39;ether.PhysicalPort&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchEtherPhysicalPort(moid: string, etherPhysicalPort: EtherPhysicalPort, ifMatch?: string, options?: Configuration): Promise<EtherPhysicalPort> {
    	const result = this.api.patchEtherPhysicalPort(moid, etherPhysicalPort, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ether.PhysicalPort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param etherPhysicalPort The &#39;ether.PhysicalPort&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateEtherPhysicalPort(moid: string, etherPhysicalPort: EtherPhysicalPort, ifMatch?: string, options?: Configuration): Promise<EtherPhysicalPort> {
    	const result = this.api.updateEtherPhysicalPort(moid, etherPhysicalPort, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableExternalsiteApi } from './ObservableAPI';


import { ExternalsiteApiRequestFactory, ExternalsiteApiResponseProcessor} from "../apis/ExternalsiteApi";
export class PromiseExternalsiteApi {
    private api: ObservableExternalsiteApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ExternalsiteApiRequestFactory,
        responseProcessor?: ExternalsiteApiResponseProcessor
    ) {
        this.api = new ObservableExternalsiteApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'externalsite.Authorization' resource.
     * @param externalsiteAuthorization The &#39;externalsite.Authorization&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createExternalsiteAuthorization(externalsiteAuthorization: ExternalsiteAuthorization, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ExternalsiteAuthorization> {
    	const result = this.api.createExternalsiteAuthorization(externalsiteAuthorization, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'externalsite.Authorization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getExternalsiteAuthorizationByMoid(moid: string, options?: Configuration): Promise<ExternalsiteAuthorization> {
    	const result = this.api.getExternalsiteAuthorizationByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'externalsite.Authorization' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getExternalsiteAuthorizationList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ExternalsiteAuthorizationResponse> {
    	const result = this.api.getExternalsiteAuthorizationList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'externalsite.Authorization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param externalsiteAuthorization The &#39;externalsite.Authorization&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchExternalsiteAuthorization(moid: string, externalsiteAuthorization: ExternalsiteAuthorization, ifMatch?: string, options?: Configuration): Promise<ExternalsiteAuthorization> {
    	const result = this.api.patchExternalsiteAuthorization(moid, externalsiteAuthorization, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'externalsite.Authorization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param externalsiteAuthorization The &#39;externalsite.Authorization&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateExternalsiteAuthorization(moid: string, externalsiteAuthorization: ExternalsiteAuthorization, ifMatch?: string, options?: Configuration): Promise<ExternalsiteAuthorization> {
    	const result = this.api.updateExternalsiteAuthorization(moid, externalsiteAuthorization, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableFaultApi } from './ObservableAPI';


import { FaultApiRequestFactory, FaultApiResponseProcessor} from "../apis/FaultApi";
export class PromiseFaultApi {
    private api: ObservableFaultApi

    public constructor(
        configuration: Configuration,
        requestFactory?: FaultApiRequestFactory,
        responseProcessor?: FaultApiResponseProcessor
    ) {
        this.api = new ObservableFaultApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'fault.Instance' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getFaultInstanceByMoid(moid: string, options?: Configuration): Promise<FaultInstance> {
    	const result = this.api.getFaultInstanceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'fault.Instance' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getFaultInstanceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<FaultInstanceResponse> {
    	const result = this.api.getFaultInstanceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'fault.Instance' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param faultInstance The &#39;fault.Instance&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchFaultInstance(moid: string, faultInstance: FaultInstance, ifMatch?: string, options?: Configuration): Promise<FaultInstance> {
    	const result = this.api.patchFaultInstance(moid, faultInstance, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'fault.Instance' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param faultInstance The &#39;fault.Instance&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateFaultInstance(moid: string, faultInstance: FaultInstance, ifMatch?: string, options?: Configuration): Promise<FaultInstance> {
    	const result = this.api.updateFaultInstance(moid, faultInstance, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableFcApi } from './ObservableAPI';


import { FcApiRequestFactory, FcApiResponseProcessor} from "../apis/FcApi";
export class PromiseFcApi {
    private api: ObservableFcApi

    public constructor(
        configuration: Configuration,
        requestFactory?: FcApiRequestFactory,
        responseProcessor?: FcApiResponseProcessor
    ) {
        this.api = new ObservableFcApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'fc.PhysicalPort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getFcPhysicalPortByMoid(moid: string, options?: Configuration): Promise<FcPhysicalPort> {
    	const result = this.api.getFcPhysicalPortByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'fc.PhysicalPort' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getFcPhysicalPortList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<FcPhysicalPortResponse> {
    	const result = this.api.getFcPhysicalPortList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'fc.PhysicalPort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param fcPhysicalPort The &#39;fc.PhysicalPort&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchFcPhysicalPort(moid: string, fcPhysicalPort: FcPhysicalPort, ifMatch?: string, options?: Configuration): Promise<FcPhysicalPort> {
    	const result = this.api.patchFcPhysicalPort(moid, fcPhysicalPort, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'fc.PhysicalPort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param fcPhysicalPort The &#39;fc.PhysicalPort&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateFcPhysicalPort(moid: string, fcPhysicalPort: FcPhysicalPort, ifMatch?: string, options?: Configuration): Promise<FcPhysicalPort> {
    	const result = this.api.updateFcPhysicalPort(moid, fcPhysicalPort, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableFeedbackApi } from './ObservableAPI';


import { FeedbackApiRequestFactory, FeedbackApiResponseProcessor} from "../apis/FeedbackApi";
export class PromiseFeedbackApi {
    private api: ObservableFeedbackApi

    public constructor(
        configuration: Configuration,
        requestFactory?: FeedbackApiRequestFactory,
        responseProcessor?: FeedbackApiResponseProcessor
    ) {
        this.api = new ObservableFeedbackApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'feedback.FeedbackPost' resource.
     * @param feedbackFeedbackPost The &#39;feedback.FeedbackPost&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createFeedbackFeedbackPost(feedbackFeedbackPost: FeedbackFeedbackPost, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<FeedbackFeedbackPost> {
    	const result = this.api.createFeedbackFeedbackPost(feedbackFeedbackPost, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableFirmwareApi } from './ObservableAPI';


import { FirmwareApiRequestFactory, FirmwareApiResponseProcessor} from "../apis/FirmwareApi";
export class PromiseFirmwareApi {
    private api: ObservableFirmwareApi

    public constructor(
        configuration: Configuration,
        requestFactory?: FirmwareApiRequestFactory,
        responseProcessor?: FirmwareApiResponseProcessor
    ) {
        this.api = new ObservableFirmwareApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'firmware.Distributable' resource.
     * @param firmwareDistributable The &#39;firmware.Distributable&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createFirmwareDistributable(firmwareDistributable: FirmwareDistributable, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<FirmwareDistributable> {
    	const result = this.api.createFirmwareDistributable(firmwareDistributable, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'firmware.DriverDistributable' resource.
     * @param firmwareDriverDistributable The &#39;firmware.DriverDistributable&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createFirmwareDriverDistributable(firmwareDriverDistributable: FirmwareDriverDistributable, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<FirmwareDriverDistributable> {
    	const result = this.api.createFirmwareDriverDistributable(firmwareDriverDistributable, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'firmware.Eula' resource.
     * @param firmwareEula The &#39;firmware.Eula&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createFirmwareEula(firmwareEula: FirmwareEula, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<FirmwareEula> {
    	const result = this.api.createFirmwareEula(firmwareEula, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'firmware.ServerConfigurationUtilityDistributable' resource.
     * @param firmwareServerConfigurationUtilityDistributable The &#39;firmware.ServerConfigurationUtilityDistributable&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createFirmwareServerConfigurationUtilityDistributable(firmwareServerConfigurationUtilityDistributable: FirmwareServerConfigurationUtilityDistributable, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<FirmwareServerConfigurationUtilityDistributable> {
    	const result = this.api.createFirmwareServerConfigurationUtilityDistributable(firmwareServerConfigurationUtilityDistributable, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'firmware.Upgrade' resource.
     * @param firmwareUpgrade The &#39;firmware.Upgrade&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createFirmwareUpgrade(firmwareUpgrade: FirmwareUpgrade, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<FirmwareUpgrade> {
    	const result = this.api.createFirmwareUpgrade(firmwareUpgrade, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'firmware.Distributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteFirmwareDistributable(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteFirmwareDistributable(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'firmware.DriverDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteFirmwareDriverDistributable(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteFirmwareDriverDistributable(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'firmware.ServerConfigurationUtilityDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteFirmwareServerConfigurationUtilityDistributable(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteFirmwareServerConfigurationUtilityDistributable(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'firmware.Upgrade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteFirmwareUpgrade(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteFirmwareUpgrade(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.Distributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getFirmwareDistributableByMoid(moid: string, options?: Configuration): Promise<FirmwareDistributable> {
    	const result = this.api.getFirmwareDistributableByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.Distributable' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getFirmwareDistributableList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<FirmwareDistributableResponse> {
    	const result = this.api.getFirmwareDistributableList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.DriverDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getFirmwareDriverDistributableByMoid(moid: string, options?: Configuration): Promise<FirmwareDriverDistributable> {
    	const result = this.api.getFirmwareDriverDistributableByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.DriverDistributable' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getFirmwareDriverDistributableList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<FirmwareDriverDistributableResponse> {
    	const result = this.api.getFirmwareDriverDistributableList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.Eula' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getFirmwareEulaByMoid(moid: string, options?: Configuration): Promise<FirmwareEula> {
    	const result = this.api.getFirmwareEulaByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.Eula' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getFirmwareEulaList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<FirmwareEulaResponse> {
    	const result = this.api.getFirmwareEulaList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.RunningFirmware' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getFirmwareRunningFirmwareByMoid(moid: string, options?: Configuration): Promise<FirmwareRunningFirmware> {
    	const result = this.api.getFirmwareRunningFirmwareByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.RunningFirmware' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getFirmwareRunningFirmwareList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<FirmwareRunningFirmwareResponse> {
    	const result = this.api.getFirmwareRunningFirmwareList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.ServerConfigurationUtilityDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getFirmwareServerConfigurationUtilityDistributableByMoid(moid: string, options?: Configuration): Promise<FirmwareServerConfigurationUtilityDistributable> {
    	const result = this.api.getFirmwareServerConfigurationUtilityDistributableByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.ServerConfigurationUtilityDistributable' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getFirmwareServerConfigurationUtilityDistributableList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<FirmwareServerConfigurationUtilityDistributableResponse> {
    	const result = this.api.getFirmwareServerConfigurationUtilityDistributableList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.Upgrade' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getFirmwareUpgradeByMoid(moid: string, options?: Configuration): Promise<FirmwareUpgrade> {
    	const result = this.api.getFirmwareUpgradeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.Upgrade' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getFirmwareUpgradeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<FirmwareUpgradeResponse> {
    	const result = this.api.getFirmwareUpgradeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.UpgradeStatus' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getFirmwareUpgradeStatusByMoid(moid: string, options?: Configuration): Promise<FirmwareUpgradeStatus> {
    	const result = this.api.getFirmwareUpgradeStatusByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'firmware.UpgradeStatus' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getFirmwareUpgradeStatusList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<FirmwareUpgradeStatusResponse> {
    	const result = this.api.getFirmwareUpgradeStatusList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'firmware.Distributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param firmwareDistributable The &#39;firmware.Distributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchFirmwareDistributable(moid: string, firmwareDistributable: FirmwareDistributable, ifMatch?: string, options?: Configuration): Promise<FirmwareDistributable> {
    	const result = this.api.patchFirmwareDistributable(moid, firmwareDistributable, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'firmware.DriverDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param firmwareDriverDistributable The &#39;firmware.DriverDistributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchFirmwareDriverDistributable(moid: string, firmwareDriverDistributable: FirmwareDriverDistributable, ifMatch?: string, options?: Configuration): Promise<FirmwareDriverDistributable> {
    	const result = this.api.patchFirmwareDriverDistributable(moid, firmwareDriverDistributable, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'firmware.RunningFirmware' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param firmwareRunningFirmware The &#39;firmware.RunningFirmware&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchFirmwareRunningFirmware(moid: string, firmwareRunningFirmware: FirmwareRunningFirmware, ifMatch?: string, options?: Configuration): Promise<FirmwareRunningFirmware> {
    	const result = this.api.patchFirmwareRunningFirmware(moid, firmwareRunningFirmware, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'firmware.ServerConfigurationUtilityDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param firmwareServerConfigurationUtilityDistributable The &#39;firmware.ServerConfigurationUtilityDistributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchFirmwareServerConfigurationUtilityDistributable(moid: string, firmwareServerConfigurationUtilityDistributable: FirmwareServerConfigurationUtilityDistributable, ifMatch?: string, options?: Configuration): Promise<FirmwareServerConfigurationUtilityDistributable> {
    	const result = this.api.patchFirmwareServerConfigurationUtilityDistributable(moid, firmwareServerConfigurationUtilityDistributable, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'firmware.Distributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param firmwareDistributable The &#39;firmware.Distributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateFirmwareDistributable(moid: string, firmwareDistributable: FirmwareDistributable, ifMatch?: string, options?: Configuration): Promise<FirmwareDistributable> {
    	const result = this.api.updateFirmwareDistributable(moid, firmwareDistributable, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'firmware.DriverDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param firmwareDriverDistributable The &#39;firmware.DriverDistributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateFirmwareDriverDistributable(moid: string, firmwareDriverDistributable: FirmwareDriverDistributable, ifMatch?: string, options?: Configuration): Promise<FirmwareDriverDistributable> {
    	const result = this.api.updateFirmwareDriverDistributable(moid, firmwareDriverDistributable, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'firmware.RunningFirmware' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param firmwareRunningFirmware The &#39;firmware.RunningFirmware&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateFirmwareRunningFirmware(moid: string, firmwareRunningFirmware: FirmwareRunningFirmware, ifMatch?: string, options?: Configuration): Promise<FirmwareRunningFirmware> {
    	const result = this.api.updateFirmwareRunningFirmware(moid, firmwareRunningFirmware, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'firmware.ServerConfigurationUtilityDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param firmwareServerConfigurationUtilityDistributable The &#39;firmware.ServerConfigurationUtilityDistributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateFirmwareServerConfigurationUtilityDistributable(moid: string, firmwareServerConfigurationUtilityDistributable: FirmwareServerConfigurationUtilityDistributable, ifMatch?: string, options?: Configuration): Promise<FirmwareServerConfigurationUtilityDistributable> {
    	const result = this.api.updateFirmwareServerConfigurationUtilityDistributable(moid, firmwareServerConfigurationUtilityDistributable, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableForecastApi } from './ObservableAPI';


import { ForecastApiRequestFactory, ForecastApiResponseProcessor} from "../apis/ForecastApi";
export class PromiseForecastApi {
    private api: ObservableForecastApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ForecastApiRequestFactory,
        responseProcessor?: ForecastApiResponseProcessor
    ) {
        this.api = new ObservableForecastApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'forecast.Catalog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getForecastCatalogByMoid(moid: string, options?: Configuration): Promise<ForecastCatalog> {
    	const result = this.api.getForecastCatalogByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'forecast.Catalog' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getForecastCatalogList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ForecastCatalogResponse> {
    	const result = this.api.getForecastCatalogList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'forecast.Definition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getForecastDefinitionByMoid(moid: string, options?: Configuration): Promise<ForecastDefinition> {
    	const result = this.api.getForecastDefinitionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'forecast.Definition' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getForecastDefinitionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ForecastDefinitionResponse> {
    	const result = this.api.getForecastDefinitionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'forecast.Instance' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getForecastInstanceByMoid(moid: string, options?: Configuration): Promise<ForecastInstance> {
    	const result = this.api.getForecastInstanceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'forecast.Instance' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getForecastInstanceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ForecastInstanceResponse> {
    	const result = this.api.getForecastInstanceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableGraphicsApi } from './ObservableAPI';


import { GraphicsApiRequestFactory, GraphicsApiResponseProcessor} from "../apis/GraphicsApi";
export class PromiseGraphicsApi {
    private api: ObservableGraphicsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: GraphicsApiRequestFactory,
        responseProcessor?: GraphicsApiResponseProcessor
    ) {
        this.api = new ObservableGraphicsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'graphics.Card' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getGraphicsCardByMoid(moid: string, options?: Configuration): Promise<GraphicsCard> {
    	const result = this.api.getGraphicsCardByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'graphics.Card' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getGraphicsCardList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<GraphicsCardResponse> {
    	const result = this.api.getGraphicsCardList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'graphics.Controller' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getGraphicsControllerByMoid(moid: string, options?: Configuration): Promise<GraphicsController> {
    	const result = this.api.getGraphicsControllerByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'graphics.Controller' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getGraphicsControllerList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<GraphicsControllerResponse> {
    	const result = this.api.getGraphicsControllerList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'graphics.Card' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param graphicsCard The &#39;graphics.Card&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchGraphicsCard(moid: string, graphicsCard: GraphicsCard, ifMatch?: string, options?: Configuration): Promise<GraphicsCard> {
    	const result = this.api.patchGraphicsCard(moid, graphicsCard, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'graphics.Controller' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param graphicsController The &#39;graphics.Controller&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchGraphicsController(moid: string, graphicsController: GraphicsController, ifMatch?: string, options?: Configuration): Promise<GraphicsController> {
    	const result = this.api.patchGraphicsController(moid, graphicsController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'graphics.Card' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param graphicsCard The &#39;graphics.Card&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateGraphicsCard(moid: string, graphicsCard: GraphicsCard, ifMatch?: string, options?: Configuration): Promise<GraphicsCard> {
    	const result = this.api.updateGraphicsCard(moid, graphicsCard, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'graphics.Controller' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param graphicsController The &#39;graphics.Controller&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateGraphicsController(moid: string, graphicsController: GraphicsController, ifMatch?: string, options?: Configuration): Promise<GraphicsController> {
    	const result = this.api.updateGraphicsController(moid, graphicsController, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableHclApi } from './ObservableAPI';


import { HclApiRequestFactory, HclApiResponseProcessor} from "../apis/HclApi";
export class PromiseHclApi {
    private api: ObservableHclApi

    public constructor(
        configuration: Configuration,
        requestFactory?: HclApiRequestFactory,
        responseProcessor?: HclApiResponseProcessor
    ) {
        this.api = new ObservableHclApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'hcl.CompatibilityStatus' resource.
     * @param hclCompatibilityStatus The &#39;hcl.CompatibilityStatus&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHclCompatibilityStatus(hclCompatibilityStatus: HclCompatibilityStatus, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HclCompatibilityStatus> {
    	const result = this.api.createHclCompatibilityStatus(hclCompatibilityStatus, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hcl.HyperflexSoftwareCompatibilityInfo' resource.
     * @param hclHyperflexSoftwareCompatibilityInfo The &#39;hcl.HyperflexSoftwareCompatibilityInfo&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHclHyperflexSoftwareCompatibilityInfo(hclHyperflexSoftwareCompatibilityInfo: HclHyperflexSoftwareCompatibilityInfo, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HclHyperflexSoftwareCompatibilityInfo> {
    	const result = this.api.createHclHyperflexSoftwareCompatibilityInfo(hclHyperflexSoftwareCompatibilityInfo, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hcl.SupportedDriverName' resource.
     * @param hclSupportedDriverName The &#39;hcl.SupportedDriverName&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHclSupportedDriverName(hclSupportedDriverName: HclSupportedDriverName, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HclSupportedDriverName> {
    	const result = this.api.createHclSupportedDriverName(hclSupportedDriverName, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hcl.HyperflexSoftwareCompatibilityInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHclHyperflexSoftwareCompatibilityInfo(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHclHyperflexSoftwareCompatibilityInfo(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.DriverImage' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHclDriverImageByMoid(moid: string, options?: Configuration): Promise<HclDriverImage> {
    	const result = this.api.getHclDriverImageByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.DriverImage' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHclDriverImageList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HclDriverImageResponse> {
    	const result = this.api.getHclDriverImageList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.ExemptedCatalog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHclExemptedCatalogByMoid(moid: string, options?: Configuration): Promise<HclExemptedCatalog> {
    	const result = this.api.getHclExemptedCatalogByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.ExemptedCatalog' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHclExemptedCatalogList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HclExemptedCatalogResponse> {
    	const result = this.api.getHclExemptedCatalogList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.HyperflexSoftwareCompatibilityInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHclHyperflexSoftwareCompatibilityInfoByMoid(moid: string, options?: Configuration): Promise<HclHyperflexSoftwareCompatibilityInfo> {
    	const result = this.api.getHclHyperflexSoftwareCompatibilityInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.HyperflexSoftwareCompatibilityInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHclHyperflexSoftwareCompatibilityInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HclHyperflexSoftwareCompatibilityInfoResponse> {
    	const result = this.api.getHclHyperflexSoftwareCompatibilityInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.OperatingSystem' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHclOperatingSystemByMoid(moid: string, options?: Configuration): Promise<HclOperatingSystem> {
    	const result = this.api.getHclOperatingSystemByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.OperatingSystem' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHclOperatingSystemList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HclOperatingSystemResponse> {
    	const result = this.api.getHclOperatingSystemList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.OperatingSystemVendor' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHclOperatingSystemVendorByMoid(moid: string, options?: Configuration): Promise<HclOperatingSystemVendor> {
    	const result = this.api.getHclOperatingSystemVendorByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.OperatingSystemVendor' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHclOperatingSystemVendorList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HclOperatingSystemVendorResponse> {
    	const result = this.api.getHclOperatingSystemVendorList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.ServiceStatus' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHclServiceStatusByMoid(moid: string, options?: Configuration): Promise<HclServiceStatus> {
    	const result = this.api.getHclServiceStatusByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hcl.ServiceStatus' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHclServiceStatusList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HclServiceStatusResponse> {
    	const result = this.api.getHclServiceStatusList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hcl.HyperflexSoftwareCompatibilityInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hclHyperflexSoftwareCompatibilityInfo The &#39;hcl.HyperflexSoftwareCompatibilityInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHclHyperflexSoftwareCompatibilityInfo(moid: string, hclHyperflexSoftwareCompatibilityInfo: HclHyperflexSoftwareCompatibilityInfo, ifMatch?: string, options?: Configuration): Promise<HclHyperflexSoftwareCompatibilityInfo> {
    	const result = this.api.patchHclHyperflexSoftwareCompatibilityInfo(moid, hclHyperflexSoftwareCompatibilityInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hcl.HyperflexSoftwareCompatibilityInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hclHyperflexSoftwareCompatibilityInfo The &#39;hcl.HyperflexSoftwareCompatibilityInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHclHyperflexSoftwareCompatibilityInfo(moid: string, hclHyperflexSoftwareCompatibilityInfo: HclHyperflexSoftwareCompatibilityInfo, ifMatch?: string, options?: Configuration): Promise<HclHyperflexSoftwareCompatibilityInfo> {
    	const result = this.api.updateHclHyperflexSoftwareCompatibilityInfo(moid, hclHyperflexSoftwareCompatibilityInfo, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableHyperflexApi } from './ObservableAPI';


import { HyperflexApiRequestFactory, HyperflexApiResponseProcessor} from "../apis/HyperflexApi";
export class PromiseHyperflexApi {
    private api: ObservableHyperflexApi

    public constructor(
        configuration: Configuration,
        requestFactory?: HyperflexApiRequestFactory,
        responseProcessor?: HyperflexApiResponseProcessor
    ) {
        this.api = new ObservableHyperflexApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'hyperflex.AppCatalog' resource.
     * @param hyperflexAppCatalog The &#39;hyperflex.AppCatalog&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexAppCatalog(hyperflexAppCatalog: HyperflexAppCatalog, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexAppCatalog> {
    	const result = this.api.createHyperflexAppCatalog(hyperflexAppCatalog, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.AutoSupportPolicy' resource.
     * @param hyperflexAutoSupportPolicy The &#39;hyperflex.AutoSupportPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexAutoSupportPolicy(hyperflexAutoSupportPolicy: HyperflexAutoSupportPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexAutoSupportPolicy> {
    	const result = this.api.createHyperflexAutoSupportPolicy(hyperflexAutoSupportPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.CapabilityInfo' resource.
     * @param hyperflexCapabilityInfo The &#39;hyperflex.CapabilityInfo&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexCapabilityInfo(hyperflexCapabilityInfo: HyperflexCapabilityInfo, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexCapabilityInfo> {
    	const result = this.api.createHyperflexCapabilityInfo(hyperflexCapabilityInfo, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.ClusterNetworkPolicy' resource.
     * @param hyperflexClusterNetworkPolicy The &#39;hyperflex.ClusterNetworkPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexClusterNetworkPolicy(hyperflexClusterNetworkPolicy: HyperflexClusterNetworkPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexClusterNetworkPolicy> {
    	const result = this.api.createHyperflexClusterNetworkPolicy(hyperflexClusterNetworkPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.ClusterProfile' resource.
     * @param hyperflexClusterProfile The &#39;hyperflex.ClusterProfile&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexClusterProfile(hyperflexClusterProfile: HyperflexClusterProfile, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexClusterProfile> {
    	const result = this.api.createHyperflexClusterProfile(hyperflexClusterProfile, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.ClusterStoragePolicy' resource.
     * @param hyperflexClusterStoragePolicy The &#39;hyperflex.ClusterStoragePolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexClusterStoragePolicy(hyperflexClusterStoragePolicy: HyperflexClusterStoragePolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexClusterStoragePolicy> {
    	const result = this.api.createHyperflexClusterStoragePolicy(hyperflexClusterStoragePolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.ExtFcStoragePolicy' resource.
     * @param hyperflexExtFcStoragePolicy The &#39;hyperflex.ExtFcStoragePolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexExtFcStoragePolicy(hyperflexExtFcStoragePolicy: HyperflexExtFcStoragePolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexExtFcStoragePolicy> {
    	const result = this.api.createHyperflexExtFcStoragePolicy(hyperflexExtFcStoragePolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.ExtIscsiStoragePolicy' resource.
     * @param hyperflexExtIscsiStoragePolicy The &#39;hyperflex.ExtIscsiStoragePolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexExtIscsiStoragePolicy(hyperflexExtIscsiStoragePolicy: HyperflexExtIscsiStoragePolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexExtIscsiStoragePolicy> {
    	const result = this.api.createHyperflexExtIscsiStoragePolicy(hyperflexExtIscsiStoragePolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.FeatureLimitExternal' resource.
     * @param hyperflexFeatureLimitExternal The &#39;hyperflex.FeatureLimitExternal&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexFeatureLimitExternal(hyperflexFeatureLimitExternal: HyperflexFeatureLimitExternal, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexFeatureLimitExternal> {
    	const result = this.api.createHyperflexFeatureLimitExternal(hyperflexFeatureLimitExternal, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.FeatureLimitInternal' resource.
     * @param hyperflexFeatureLimitInternal The &#39;hyperflex.FeatureLimitInternal&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexFeatureLimitInternal(hyperflexFeatureLimitInternal: HyperflexFeatureLimitInternal, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexFeatureLimitInternal> {
    	const result = this.api.createHyperflexFeatureLimitInternal(hyperflexFeatureLimitInternal, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.HxdpVersion' resource.
     * @param hyperflexHxdpVersion The &#39;hyperflex.HxdpVersion&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexHxdpVersion(hyperflexHxdpVersion: HyperflexHxdpVersion, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexHxdpVersion> {
    	const result = this.api.createHyperflexHxdpVersion(hyperflexHxdpVersion, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.LocalCredentialPolicy' resource.
     * @param hyperflexLocalCredentialPolicy The &#39;hyperflex.LocalCredentialPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexLocalCredentialPolicy(hyperflexLocalCredentialPolicy: HyperflexLocalCredentialPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexLocalCredentialPolicy> {
    	const result = this.api.createHyperflexLocalCredentialPolicy(hyperflexLocalCredentialPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.NodeConfigPolicy' resource.
     * @param hyperflexNodeConfigPolicy The &#39;hyperflex.NodeConfigPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexNodeConfigPolicy(hyperflexNodeConfigPolicy: HyperflexNodeConfigPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexNodeConfigPolicy> {
    	const result = this.api.createHyperflexNodeConfigPolicy(hyperflexNodeConfigPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.NodeProfile' resource.
     * @param hyperflexNodeProfile The &#39;hyperflex.NodeProfile&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexNodeProfile(hyperflexNodeProfile: HyperflexNodeProfile, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexNodeProfile> {
    	const result = this.api.createHyperflexNodeProfile(hyperflexNodeProfile, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.ProxySettingPolicy' resource.
     * @param hyperflexProxySettingPolicy The &#39;hyperflex.ProxySettingPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexProxySettingPolicy(hyperflexProxySettingPolicy: HyperflexProxySettingPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexProxySettingPolicy> {
    	const result = this.api.createHyperflexProxySettingPolicy(hyperflexProxySettingPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.ServerFirmwareVersion' resource.
     * @param hyperflexServerFirmwareVersion The &#39;hyperflex.ServerFirmwareVersion&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexServerFirmwareVersion(hyperflexServerFirmwareVersion: HyperflexServerFirmwareVersion, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexServerFirmwareVersion> {
    	const result = this.api.createHyperflexServerFirmwareVersion(hyperflexServerFirmwareVersion, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.ServerModel' resource.
     * @param hyperflexServerModel The &#39;hyperflex.ServerModel&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexServerModel(hyperflexServerModel: HyperflexServerModel, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexServerModel> {
    	const result = this.api.createHyperflexServerModel(hyperflexServerModel, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.SoftwareVersionPolicy' resource.
     * @param hyperflexSoftwareVersionPolicy The &#39;hyperflex.SoftwareVersionPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexSoftwareVersionPolicy(hyperflexSoftwareVersionPolicy: HyperflexSoftwareVersionPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexSoftwareVersionPolicy> {
    	const result = this.api.createHyperflexSoftwareVersionPolicy(hyperflexSoftwareVersionPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.SysConfigPolicy' resource.
     * @param hyperflexSysConfigPolicy The &#39;hyperflex.SysConfigPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexSysConfigPolicy(hyperflexSysConfigPolicy: HyperflexSysConfigPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexSysConfigPolicy> {
    	const result = this.api.createHyperflexSysConfigPolicy(hyperflexSysConfigPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.UcsmConfigPolicy' resource.
     * @param hyperflexUcsmConfigPolicy The &#39;hyperflex.UcsmConfigPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexUcsmConfigPolicy(hyperflexUcsmConfigPolicy: HyperflexUcsmConfigPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexUcsmConfigPolicy> {
    	const result = this.api.createHyperflexUcsmConfigPolicy(hyperflexUcsmConfigPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'hyperflex.VcenterConfigPolicy' resource.
     * @param hyperflexVcenterConfigPolicy The &#39;hyperflex.VcenterConfigPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createHyperflexVcenterConfigPolicy(hyperflexVcenterConfigPolicy: HyperflexVcenterConfigPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<HyperflexVcenterConfigPolicy> {
    	const result = this.api.createHyperflexVcenterConfigPolicy(hyperflexVcenterConfigPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.AppCatalog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexAppCatalog(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexAppCatalog(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.AutoSupportPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexAutoSupportPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexAutoSupportPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.CapabilityInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexCapabilityInfo(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexCapabilityInfo(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.ClusterNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexClusterNetworkPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexClusterNetworkPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.ClusterProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexClusterProfile(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexClusterProfile(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.ClusterStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexClusterStoragePolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexClusterStoragePolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.ExtFcStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexExtFcStoragePolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexExtFcStoragePolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.ExtIscsiStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexExtIscsiStoragePolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexExtIscsiStoragePolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.FeatureLimitExternal' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexFeatureLimitExternal(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexFeatureLimitExternal(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.FeatureLimitInternal' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexFeatureLimitInternal(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexFeatureLimitInternal(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.HxdpVersion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexHxdpVersion(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexHxdpVersion(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.LocalCredentialPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexLocalCredentialPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexLocalCredentialPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.NodeConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexNodeConfigPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexNodeConfigPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.NodeProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexNodeProfile(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexNodeProfile(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.ProxySettingPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexProxySettingPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexProxySettingPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.ServerFirmwareVersion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexServerFirmwareVersion(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexServerFirmwareVersion(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.ServerModel' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexServerModel(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexServerModel(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.SoftwareVersionPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexSoftwareVersionPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexSoftwareVersionPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.SysConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexSysConfigPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexSysConfigPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.UcsmConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexUcsmConfigPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexUcsmConfigPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'hyperflex.VcenterConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteHyperflexVcenterConfigPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteHyperflexVcenterConfigPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.Alarm' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexAlarmByMoid(moid: string, options?: Configuration): Promise<HyperflexAlarm> {
    	const result = this.api.getHyperflexAlarmByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.Alarm' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexAlarmList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexAlarmResponse> {
    	const result = this.api.getHyperflexAlarmList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.AppCatalog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexAppCatalogByMoid(moid: string, options?: Configuration): Promise<HyperflexAppCatalog> {
    	const result = this.api.getHyperflexAppCatalogByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.AppCatalog' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexAppCatalogList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexAppCatalogResponse> {
    	const result = this.api.getHyperflexAppCatalogList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.AutoSupportPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexAutoSupportPolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexAutoSupportPolicy> {
    	const result = this.api.getHyperflexAutoSupportPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.AutoSupportPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexAutoSupportPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexAutoSupportPolicyResponse> {
    	const result = this.api.getHyperflexAutoSupportPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.CapabilityInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexCapabilityInfoByMoid(moid: string, options?: Configuration): Promise<HyperflexCapabilityInfo> {
    	const result = this.api.getHyperflexCapabilityInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.CapabilityInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexCapabilityInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexCapabilityInfoResponse> {
    	const result = this.api.getHyperflexCapabilityInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.Cluster' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexClusterByMoid(moid: string, options?: Configuration): Promise<HyperflexCluster> {
    	const result = this.api.getHyperflexClusterByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.Cluster' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexClusterList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexClusterResponse> {
    	const result = this.api.getHyperflexClusterList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ClusterNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexClusterNetworkPolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexClusterNetworkPolicy> {
    	const result = this.api.getHyperflexClusterNetworkPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ClusterNetworkPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexClusterNetworkPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexClusterNetworkPolicyResponse> {
    	const result = this.api.getHyperflexClusterNetworkPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ClusterProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexClusterProfileByMoid(moid: string, options?: Configuration): Promise<HyperflexClusterProfile> {
    	const result = this.api.getHyperflexClusterProfileByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ClusterProfile' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexClusterProfileList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexClusterProfileResponse> {
    	const result = this.api.getHyperflexClusterProfileList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ClusterStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexClusterStoragePolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexClusterStoragePolicy> {
    	const result = this.api.getHyperflexClusterStoragePolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ClusterStoragePolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexClusterStoragePolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexClusterStoragePolicyResponse> {
    	const result = this.api.getHyperflexClusterStoragePolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ConfigResult' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexConfigResultByMoid(moid: string, options?: Configuration): Promise<HyperflexConfigResult> {
    	const result = this.api.getHyperflexConfigResultByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ConfigResultEntry' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexConfigResultEntryByMoid(moid: string, options?: Configuration): Promise<HyperflexConfigResultEntry> {
    	const result = this.api.getHyperflexConfigResultEntryByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ConfigResultEntry' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexConfigResultEntryList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexConfigResultEntryResponse> {
    	const result = this.api.getHyperflexConfigResultEntryList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ConfigResult' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexConfigResultList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexConfigResultResponse> {
    	const result = this.api.getHyperflexConfigResultList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ExtFcStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexExtFcStoragePolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexExtFcStoragePolicy> {
    	const result = this.api.getHyperflexExtFcStoragePolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ExtFcStoragePolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexExtFcStoragePolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexExtFcStoragePolicyResponse> {
    	const result = this.api.getHyperflexExtFcStoragePolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ExtIscsiStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexExtIscsiStoragePolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexExtIscsiStoragePolicy> {
    	const result = this.api.getHyperflexExtIscsiStoragePolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ExtIscsiStoragePolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexExtIscsiStoragePolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexExtIscsiStoragePolicyResponse> {
    	const result = this.api.getHyperflexExtIscsiStoragePolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.FeatureLimitExternal' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexFeatureLimitExternalByMoid(moid: string, options?: Configuration): Promise<HyperflexFeatureLimitExternal> {
    	const result = this.api.getHyperflexFeatureLimitExternalByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.FeatureLimitExternal' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexFeatureLimitExternalList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexFeatureLimitExternalResponse> {
    	const result = this.api.getHyperflexFeatureLimitExternalList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.FeatureLimitInternal' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexFeatureLimitInternalByMoid(moid: string, options?: Configuration): Promise<HyperflexFeatureLimitInternal> {
    	const result = this.api.getHyperflexFeatureLimitInternalByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.FeatureLimitInternal' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexFeatureLimitInternalList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexFeatureLimitInternalResponse> {
    	const result = this.api.getHyperflexFeatureLimitInternalList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.Health' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexHealthByMoid(moid: string, options?: Configuration): Promise<HyperflexHealth> {
    	const result = this.api.getHyperflexHealthByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.Health' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexHealthList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexHealthResponse> {
    	const result = this.api.getHyperflexHealthList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.HxdpVersion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexHxdpVersionByMoid(moid: string, options?: Configuration): Promise<HyperflexHxdpVersion> {
    	const result = this.api.getHyperflexHxdpVersionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.HxdpVersion' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexHxdpVersionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexHxdpVersionResponse> {
    	const result = this.api.getHyperflexHxdpVersionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.LocalCredentialPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexLocalCredentialPolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexLocalCredentialPolicy> {
    	const result = this.api.getHyperflexLocalCredentialPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.LocalCredentialPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexLocalCredentialPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexLocalCredentialPolicyResponse> {
    	const result = this.api.getHyperflexLocalCredentialPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.Node' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexNodeByMoid(moid: string, options?: Configuration): Promise<HyperflexNode> {
    	const result = this.api.getHyperflexNodeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.NodeConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexNodeConfigPolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexNodeConfigPolicy> {
    	const result = this.api.getHyperflexNodeConfigPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.NodeConfigPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexNodeConfigPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexNodeConfigPolicyResponse> {
    	const result = this.api.getHyperflexNodeConfigPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.Node' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexNodeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexNodeResponse> {
    	const result = this.api.getHyperflexNodeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.NodeProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexNodeProfileByMoid(moid: string, options?: Configuration): Promise<HyperflexNodeProfile> {
    	const result = this.api.getHyperflexNodeProfileByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.NodeProfile' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexNodeProfileList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexNodeProfileResponse> {
    	const result = this.api.getHyperflexNodeProfileList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ProxySettingPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexProxySettingPolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexProxySettingPolicy> {
    	const result = this.api.getHyperflexProxySettingPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ProxySettingPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexProxySettingPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexProxySettingPolicyResponse> {
    	const result = this.api.getHyperflexProxySettingPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ServerFirmwareVersion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexServerFirmwareVersionByMoid(moid: string, options?: Configuration): Promise<HyperflexServerFirmwareVersion> {
    	const result = this.api.getHyperflexServerFirmwareVersionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ServerFirmwareVersion' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexServerFirmwareVersionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexServerFirmwareVersionResponse> {
    	const result = this.api.getHyperflexServerFirmwareVersionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ServerModel' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexServerModelByMoid(moid: string, options?: Configuration): Promise<HyperflexServerModel> {
    	const result = this.api.getHyperflexServerModelByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.ServerModel' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexServerModelList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexServerModelResponse> {
    	const result = this.api.getHyperflexServerModelList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.SoftwareVersionPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexSoftwareVersionPolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexSoftwareVersionPolicy> {
    	const result = this.api.getHyperflexSoftwareVersionPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.SoftwareVersionPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexSoftwareVersionPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexSoftwareVersionPolicyResponse> {
    	const result = this.api.getHyperflexSoftwareVersionPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.SysConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexSysConfigPolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexSysConfigPolicy> {
    	const result = this.api.getHyperflexSysConfigPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.SysConfigPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexSysConfigPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexSysConfigPolicyResponse> {
    	const result = this.api.getHyperflexSysConfigPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.UcsmConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexUcsmConfigPolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexUcsmConfigPolicy> {
    	const result = this.api.getHyperflexUcsmConfigPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.UcsmConfigPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexUcsmConfigPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexUcsmConfigPolicyResponse> {
    	const result = this.api.getHyperflexUcsmConfigPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.VcenterConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getHyperflexVcenterConfigPolicyByMoid(moid: string, options?: Configuration): Promise<HyperflexVcenterConfigPolicy> {
    	const result = this.api.getHyperflexVcenterConfigPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'hyperflex.VcenterConfigPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getHyperflexVcenterConfigPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<HyperflexVcenterConfigPolicyResponse> {
    	const result = this.api.getHyperflexVcenterConfigPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.AppCatalog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexAppCatalog The &#39;hyperflex.AppCatalog&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexAppCatalog(moid: string, hyperflexAppCatalog: HyperflexAppCatalog, ifMatch?: string, options?: Configuration): Promise<HyperflexAppCatalog> {
    	const result = this.api.patchHyperflexAppCatalog(moid, hyperflexAppCatalog, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.AutoSupportPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexAutoSupportPolicy The &#39;hyperflex.AutoSupportPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexAutoSupportPolicy(moid: string, hyperflexAutoSupportPolicy: HyperflexAutoSupportPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexAutoSupportPolicy> {
    	const result = this.api.patchHyperflexAutoSupportPolicy(moid, hyperflexAutoSupportPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.CapabilityInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexCapabilityInfo The &#39;hyperflex.CapabilityInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexCapabilityInfo(moid: string, hyperflexCapabilityInfo: HyperflexCapabilityInfo, ifMatch?: string, options?: Configuration): Promise<HyperflexCapabilityInfo> {
    	const result = this.api.patchHyperflexCapabilityInfo(moid, hyperflexCapabilityInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.Cluster' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexCluster The &#39;hyperflex.Cluster&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexCluster(moid: string, hyperflexCluster: HyperflexCluster, ifMatch?: string, options?: Configuration): Promise<HyperflexCluster> {
    	const result = this.api.patchHyperflexCluster(moid, hyperflexCluster, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ClusterNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexClusterNetworkPolicy The &#39;hyperflex.ClusterNetworkPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexClusterNetworkPolicy(moid: string, hyperflexClusterNetworkPolicy: HyperflexClusterNetworkPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexClusterNetworkPolicy> {
    	const result = this.api.patchHyperflexClusterNetworkPolicy(moid, hyperflexClusterNetworkPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ClusterProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexClusterProfile The &#39;hyperflex.ClusterProfile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexClusterProfile(moid: string, hyperflexClusterProfile: HyperflexClusterProfile, ifMatch?: string, options?: Configuration): Promise<HyperflexClusterProfile> {
    	const result = this.api.patchHyperflexClusterProfile(moid, hyperflexClusterProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ClusterStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexClusterStoragePolicy The &#39;hyperflex.ClusterStoragePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexClusterStoragePolicy(moid: string, hyperflexClusterStoragePolicy: HyperflexClusterStoragePolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexClusterStoragePolicy> {
    	const result = this.api.patchHyperflexClusterStoragePolicy(moid, hyperflexClusterStoragePolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ExtFcStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexExtFcStoragePolicy The &#39;hyperflex.ExtFcStoragePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexExtFcStoragePolicy(moid: string, hyperflexExtFcStoragePolicy: HyperflexExtFcStoragePolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexExtFcStoragePolicy> {
    	const result = this.api.patchHyperflexExtFcStoragePolicy(moid, hyperflexExtFcStoragePolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ExtIscsiStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexExtIscsiStoragePolicy The &#39;hyperflex.ExtIscsiStoragePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexExtIscsiStoragePolicy(moid: string, hyperflexExtIscsiStoragePolicy: HyperflexExtIscsiStoragePolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexExtIscsiStoragePolicy> {
    	const result = this.api.patchHyperflexExtIscsiStoragePolicy(moid, hyperflexExtIscsiStoragePolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.FeatureLimitExternal' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexFeatureLimitExternal The &#39;hyperflex.FeatureLimitExternal&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexFeatureLimitExternal(moid: string, hyperflexFeatureLimitExternal: HyperflexFeatureLimitExternal, ifMatch?: string, options?: Configuration): Promise<HyperflexFeatureLimitExternal> {
    	const result = this.api.patchHyperflexFeatureLimitExternal(moid, hyperflexFeatureLimitExternal, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.FeatureLimitInternal' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexFeatureLimitInternal The &#39;hyperflex.FeatureLimitInternal&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexFeatureLimitInternal(moid: string, hyperflexFeatureLimitInternal: HyperflexFeatureLimitInternal, ifMatch?: string, options?: Configuration): Promise<HyperflexFeatureLimitInternal> {
    	const result = this.api.patchHyperflexFeatureLimitInternal(moid, hyperflexFeatureLimitInternal, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.HxdpVersion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexHxdpVersion The &#39;hyperflex.HxdpVersion&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexHxdpVersion(moid: string, hyperflexHxdpVersion: HyperflexHxdpVersion, ifMatch?: string, options?: Configuration): Promise<HyperflexHxdpVersion> {
    	const result = this.api.patchHyperflexHxdpVersion(moid, hyperflexHxdpVersion, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.LocalCredentialPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexLocalCredentialPolicy The &#39;hyperflex.LocalCredentialPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexLocalCredentialPolicy(moid: string, hyperflexLocalCredentialPolicy: HyperflexLocalCredentialPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexLocalCredentialPolicy> {
    	const result = this.api.patchHyperflexLocalCredentialPolicy(moid, hyperflexLocalCredentialPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.NodeConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexNodeConfigPolicy The &#39;hyperflex.NodeConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexNodeConfigPolicy(moid: string, hyperflexNodeConfigPolicy: HyperflexNodeConfigPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexNodeConfigPolicy> {
    	const result = this.api.patchHyperflexNodeConfigPolicy(moid, hyperflexNodeConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.NodeProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexNodeProfile The &#39;hyperflex.NodeProfile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexNodeProfile(moid: string, hyperflexNodeProfile: HyperflexNodeProfile, ifMatch?: string, options?: Configuration): Promise<HyperflexNodeProfile> {
    	const result = this.api.patchHyperflexNodeProfile(moid, hyperflexNodeProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ProxySettingPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexProxySettingPolicy The &#39;hyperflex.ProxySettingPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexProxySettingPolicy(moid: string, hyperflexProxySettingPolicy: HyperflexProxySettingPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexProxySettingPolicy> {
    	const result = this.api.patchHyperflexProxySettingPolicy(moid, hyperflexProxySettingPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ServerFirmwareVersion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexServerFirmwareVersion The &#39;hyperflex.ServerFirmwareVersion&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexServerFirmwareVersion(moid: string, hyperflexServerFirmwareVersion: HyperflexServerFirmwareVersion, ifMatch?: string, options?: Configuration): Promise<HyperflexServerFirmwareVersion> {
    	const result = this.api.patchHyperflexServerFirmwareVersion(moid, hyperflexServerFirmwareVersion, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ServerModel' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexServerModel The &#39;hyperflex.ServerModel&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexServerModel(moid: string, hyperflexServerModel: HyperflexServerModel, ifMatch?: string, options?: Configuration): Promise<HyperflexServerModel> {
    	const result = this.api.patchHyperflexServerModel(moid, hyperflexServerModel, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.SoftwareVersionPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexSoftwareVersionPolicy The &#39;hyperflex.SoftwareVersionPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexSoftwareVersionPolicy(moid: string, hyperflexSoftwareVersionPolicy: HyperflexSoftwareVersionPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexSoftwareVersionPolicy> {
    	const result = this.api.patchHyperflexSoftwareVersionPolicy(moid, hyperflexSoftwareVersionPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.SysConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexSysConfigPolicy The &#39;hyperflex.SysConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexSysConfigPolicy(moid: string, hyperflexSysConfigPolicy: HyperflexSysConfigPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexSysConfigPolicy> {
    	const result = this.api.patchHyperflexSysConfigPolicy(moid, hyperflexSysConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.UcsmConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexUcsmConfigPolicy The &#39;hyperflex.UcsmConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexUcsmConfigPolicy(moid: string, hyperflexUcsmConfigPolicy: HyperflexUcsmConfigPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexUcsmConfigPolicy> {
    	const result = this.api.patchHyperflexUcsmConfigPolicy(moid, hyperflexUcsmConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.VcenterConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexVcenterConfigPolicy The &#39;hyperflex.VcenterConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchHyperflexVcenterConfigPolicy(moid: string, hyperflexVcenterConfigPolicy: HyperflexVcenterConfigPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexVcenterConfigPolicy> {
    	const result = this.api.patchHyperflexVcenterConfigPolicy(moid, hyperflexVcenterConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.AppCatalog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexAppCatalog The &#39;hyperflex.AppCatalog&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexAppCatalog(moid: string, hyperflexAppCatalog: HyperflexAppCatalog, ifMatch?: string, options?: Configuration): Promise<HyperflexAppCatalog> {
    	const result = this.api.updateHyperflexAppCatalog(moid, hyperflexAppCatalog, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.AutoSupportPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexAutoSupportPolicy The &#39;hyperflex.AutoSupportPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexAutoSupportPolicy(moid: string, hyperflexAutoSupportPolicy: HyperflexAutoSupportPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexAutoSupportPolicy> {
    	const result = this.api.updateHyperflexAutoSupportPolicy(moid, hyperflexAutoSupportPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.CapabilityInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexCapabilityInfo The &#39;hyperflex.CapabilityInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexCapabilityInfo(moid: string, hyperflexCapabilityInfo: HyperflexCapabilityInfo, ifMatch?: string, options?: Configuration): Promise<HyperflexCapabilityInfo> {
    	const result = this.api.updateHyperflexCapabilityInfo(moid, hyperflexCapabilityInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.Cluster' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexCluster The &#39;hyperflex.Cluster&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexCluster(moid: string, hyperflexCluster: HyperflexCluster, ifMatch?: string, options?: Configuration): Promise<HyperflexCluster> {
    	const result = this.api.updateHyperflexCluster(moid, hyperflexCluster, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ClusterNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexClusterNetworkPolicy The &#39;hyperflex.ClusterNetworkPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexClusterNetworkPolicy(moid: string, hyperflexClusterNetworkPolicy: HyperflexClusterNetworkPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexClusterNetworkPolicy> {
    	const result = this.api.updateHyperflexClusterNetworkPolicy(moid, hyperflexClusterNetworkPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ClusterProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexClusterProfile The &#39;hyperflex.ClusterProfile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexClusterProfile(moid: string, hyperflexClusterProfile: HyperflexClusterProfile, ifMatch?: string, options?: Configuration): Promise<HyperflexClusterProfile> {
    	const result = this.api.updateHyperflexClusterProfile(moid, hyperflexClusterProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ClusterStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexClusterStoragePolicy The &#39;hyperflex.ClusterStoragePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexClusterStoragePolicy(moid: string, hyperflexClusterStoragePolicy: HyperflexClusterStoragePolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexClusterStoragePolicy> {
    	const result = this.api.updateHyperflexClusterStoragePolicy(moid, hyperflexClusterStoragePolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ExtFcStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexExtFcStoragePolicy The &#39;hyperflex.ExtFcStoragePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexExtFcStoragePolicy(moid: string, hyperflexExtFcStoragePolicy: HyperflexExtFcStoragePolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexExtFcStoragePolicy> {
    	const result = this.api.updateHyperflexExtFcStoragePolicy(moid, hyperflexExtFcStoragePolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ExtIscsiStoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexExtIscsiStoragePolicy The &#39;hyperflex.ExtIscsiStoragePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexExtIscsiStoragePolicy(moid: string, hyperflexExtIscsiStoragePolicy: HyperflexExtIscsiStoragePolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexExtIscsiStoragePolicy> {
    	const result = this.api.updateHyperflexExtIscsiStoragePolicy(moid, hyperflexExtIscsiStoragePolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.FeatureLimitExternal' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexFeatureLimitExternal The &#39;hyperflex.FeatureLimitExternal&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexFeatureLimitExternal(moid: string, hyperflexFeatureLimitExternal: HyperflexFeatureLimitExternal, ifMatch?: string, options?: Configuration): Promise<HyperflexFeatureLimitExternal> {
    	const result = this.api.updateHyperflexFeatureLimitExternal(moid, hyperflexFeatureLimitExternal, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.FeatureLimitInternal' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexFeatureLimitInternal The &#39;hyperflex.FeatureLimitInternal&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexFeatureLimitInternal(moid: string, hyperflexFeatureLimitInternal: HyperflexFeatureLimitInternal, ifMatch?: string, options?: Configuration): Promise<HyperflexFeatureLimitInternal> {
    	const result = this.api.updateHyperflexFeatureLimitInternal(moid, hyperflexFeatureLimitInternal, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.HxdpVersion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexHxdpVersion The &#39;hyperflex.HxdpVersion&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexHxdpVersion(moid: string, hyperflexHxdpVersion: HyperflexHxdpVersion, ifMatch?: string, options?: Configuration): Promise<HyperflexHxdpVersion> {
    	const result = this.api.updateHyperflexHxdpVersion(moid, hyperflexHxdpVersion, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.LocalCredentialPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexLocalCredentialPolicy The &#39;hyperflex.LocalCredentialPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexLocalCredentialPolicy(moid: string, hyperflexLocalCredentialPolicy: HyperflexLocalCredentialPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexLocalCredentialPolicy> {
    	const result = this.api.updateHyperflexLocalCredentialPolicy(moid, hyperflexLocalCredentialPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.NodeConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexNodeConfigPolicy The &#39;hyperflex.NodeConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexNodeConfigPolicy(moid: string, hyperflexNodeConfigPolicy: HyperflexNodeConfigPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexNodeConfigPolicy> {
    	const result = this.api.updateHyperflexNodeConfigPolicy(moid, hyperflexNodeConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.NodeProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexNodeProfile The &#39;hyperflex.NodeProfile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexNodeProfile(moid: string, hyperflexNodeProfile: HyperflexNodeProfile, ifMatch?: string, options?: Configuration): Promise<HyperflexNodeProfile> {
    	const result = this.api.updateHyperflexNodeProfile(moid, hyperflexNodeProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ProxySettingPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexProxySettingPolicy The &#39;hyperflex.ProxySettingPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexProxySettingPolicy(moid: string, hyperflexProxySettingPolicy: HyperflexProxySettingPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexProxySettingPolicy> {
    	const result = this.api.updateHyperflexProxySettingPolicy(moid, hyperflexProxySettingPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ServerFirmwareVersion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexServerFirmwareVersion The &#39;hyperflex.ServerFirmwareVersion&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexServerFirmwareVersion(moid: string, hyperflexServerFirmwareVersion: HyperflexServerFirmwareVersion, ifMatch?: string, options?: Configuration): Promise<HyperflexServerFirmwareVersion> {
    	const result = this.api.updateHyperflexServerFirmwareVersion(moid, hyperflexServerFirmwareVersion, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.ServerModel' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexServerModel The &#39;hyperflex.ServerModel&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexServerModel(moid: string, hyperflexServerModel: HyperflexServerModel, ifMatch?: string, options?: Configuration): Promise<HyperflexServerModel> {
    	const result = this.api.updateHyperflexServerModel(moid, hyperflexServerModel, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.SoftwareVersionPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexSoftwareVersionPolicy The &#39;hyperflex.SoftwareVersionPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexSoftwareVersionPolicy(moid: string, hyperflexSoftwareVersionPolicy: HyperflexSoftwareVersionPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexSoftwareVersionPolicy> {
    	const result = this.api.updateHyperflexSoftwareVersionPolicy(moid, hyperflexSoftwareVersionPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.SysConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexSysConfigPolicy The &#39;hyperflex.SysConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexSysConfigPolicy(moid: string, hyperflexSysConfigPolicy: HyperflexSysConfigPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexSysConfigPolicy> {
    	const result = this.api.updateHyperflexSysConfigPolicy(moid, hyperflexSysConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.UcsmConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexUcsmConfigPolicy The &#39;hyperflex.UcsmConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexUcsmConfigPolicy(moid: string, hyperflexUcsmConfigPolicy: HyperflexUcsmConfigPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexUcsmConfigPolicy> {
    	const result = this.api.updateHyperflexUcsmConfigPolicy(moid, hyperflexUcsmConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'hyperflex.VcenterConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param hyperflexVcenterConfigPolicy The &#39;hyperflex.VcenterConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateHyperflexVcenterConfigPolicy(moid: string, hyperflexVcenterConfigPolicy: HyperflexVcenterConfigPolicy, ifMatch?: string, options?: Configuration): Promise<HyperflexVcenterConfigPolicy> {
    	const result = this.api.updateHyperflexVcenterConfigPolicy(moid, hyperflexVcenterConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableIaasApi } from './ObservableAPI';


import { IaasApiRequestFactory, IaasApiResponseProcessor} from "../apis/IaasApi";
export class PromiseIaasApi {
    private api: ObservableIaasApi

    public constructor(
        configuration: Configuration,
        requestFactory?: IaasApiRequestFactory,
        responseProcessor?: IaasApiResponseProcessor
    ) {
        this.api = new ObservableIaasApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Delete a 'iaas.UcsdInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIaasUcsdInfo(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIaasUcsdInfo(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.ConnectorPack' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIaasConnectorPackByMoid(moid: string, options?: Configuration): Promise<IaasConnectorPack> {
    	const result = this.api.getIaasConnectorPackByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.ConnectorPack' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIaasConnectorPackList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IaasConnectorPackResponse> {
    	const result = this.api.getIaasConnectorPackList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.DeviceStatus' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIaasDeviceStatusByMoid(moid: string, options?: Configuration): Promise<IaasDeviceStatus> {
    	const result = this.api.getIaasDeviceStatusByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.DeviceStatus' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIaasDeviceStatusList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IaasDeviceStatusResponse> {
    	const result = this.api.getIaasDeviceStatusList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.LicenseInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIaasLicenseInfoByMoid(moid: string, options?: Configuration): Promise<IaasLicenseInfo> {
    	const result = this.api.getIaasLicenseInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.LicenseInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIaasLicenseInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IaasLicenseInfoResponse> {
    	const result = this.api.getIaasLicenseInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.MostRunTasks' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIaasMostRunTasksByMoid(moid: string, options?: Configuration): Promise<IaasMostRunTasks> {
    	const result = this.api.getIaasMostRunTasksByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.MostRunTasks' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIaasMostRunTasksList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IaasMostRunTasksResponse> {
    	const result = this.api.getIaasMostRunTasksList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.UcsdInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIaasUcsdInfoByMoid(moid: string, options?: Configuration): Promise<IaasUcsdInfo> {
    	const result = this.api.getIaasUcsdInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.UcsdInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIaasUcsdInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IaasUcsdInfoResponse> {
    	const result = this.api.getIaasUcsdInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.UcsdManagedInfra' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIaasUcsdManagedInfraByMoid(moid: string, options?: Configuration): Promise<IaasUcsdManagedInfra> {
    	const result = this.api.getIaasUcsdManagedInfraByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iaas.UcsdManagedInfra' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIaasUcsdManagedInfraList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IaasUcsdManagedInfraResponse> {
    	const result = this.api.getIaasUcsdManagedInfraList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iaas.UcsdInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iaasUcsdInfo The &#39;iaas.UcsdInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIaasUcsdInfo(moid: string, iaasUcsdInfo: IaasUcsdInfo, ifMatch?: string, options?: Configuration): Promise<IaasUcsdInfo> {
    	const result = this.api.patchIaasUcsdInfo(moid, iaasUcsdInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iaas.UcsdInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iaasUcsdInfo The &#39;iaas.UcsdInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIaasUcsdInfo(moid: string, iaasUcsdInfo: IaasUcsdInfo, ifMatch?: string, options?: Configuration): Promise<IaasUcsdInfo> {
    	const result = this.api.updateIaasUcsdInfo(moid, iaasUcsdInfo, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableIamApi } from './ObservableAPI';


import { IamApiRequestFactory, IamApiResponseProcessor} from "../apis/IamApi";
export class PromiseIamApi {
    private api: ObservableIamApi

    public constructor(
        configuration: Configuration,
        requestFactory?: IamApiRequestFactory,
        responseProcessor?: IamApiResponseProcessor
    ) {
        this.api = new ObservableIamApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'iam.Account' resource.
     * @param iamAccount The &#39;iam.Account&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamAccount(iamAccount: IamAccount, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamAccount> {
    	const result = this.api.createIamAccount(iamAccount, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.AccountExperience' resource.
     * @param iamAccountExperience The &#39;iam.AccountExperience&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamAccountExperience(iamAccountExperience: IamAccountExperience, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamAccountExperience> {
    	const result = this.api.createIamAccountExperience(iamAccountExperience, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.ApiKey' resource.
     * @param iamApiKey The &#39;iam.ApiKey&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamApiKey(iamApiKey: IamApiKey, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamApiKey> {
    	const result = this.api.createIamApiKey(iamApiKey, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.AppRegistration' resource.
     * @param iamAppRegistration The &#39;iam.AppRegistration&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamAppRegistration(iamAppRegistration: IamAppRegistration, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamAppRegistration> {
    	const result = this.api.createIamAppRegistration(iamAppRegistration, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.Certificate' resource.
     * @param iamCertificate The &#39;iam.Certificate&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamCertificate(iamCertificate: IamCertificate, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamCertificate> {
    	const result = this.api.createIamCertificate(iamCertificate, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.CertificateRequest' resource.
     * @param iamCertificateRequest The &#39;iam.CertificateRequest&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamCertificateRequest(iamCertificateRequest: IamCertificateRequest, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamCertificateRequest> {
    	const result = this.api.createIamCertificateRequest(iamCertificateRequest, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.EndPointUser' resource.
     * @param iamEndPointUser The &#39;iam.EndPointUser&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamEndPointUser(iamEndPointUser: IamEndPointUser, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamEndPointUser> {
    	const result = this.api.createIamEndPointUser(iamEndPointUser, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.EndPointUserPolicy' resource.
     * @param iamEndPointUserPolicy The &#39;iam.EndPointUserPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamEndPointUserPolicy(iamEndPointUserPolicy: IamEndPointUserPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamEndPointUserPolicy> {
    	const result = this.api.createIamEndPointUserPolicy(iamEndPointUserPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.EndPointUserRole' resource.
     * @param iamEndPointUserRole The &#39;iam.EndPointUserRole&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamEndPointUserRole(iamEndPointUserRole: IamEndPointUserRole, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamEndPointUserRole> {
    	const result = this.api.createIamEndPointUserRole(iamEndPointUserRole, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.Idp' resource.
     * @param iamIdp The &#39;iam.Idp&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamIdp(iamIdp: IamIdp, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamIdp> {
    	const result = this.api.createIamIdp(iamIdp, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.LdapGroup' resource.
     * @param iamLdapGroup The &#39;iam.LdapGroup&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamLdapGroup(iamLdapGroup: IamLdapGroup, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamLdapGroup> {
    	const result = this.api.createIamLdapGroup(iamLdapGroup, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.LdapPolicy' resource.
     * @param iamLdapPolicy The &#39;iam.LdapPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamLdapPolicy(iamLdapPolicy: IamLdapPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamLdapPolicy> {
    	const result = this.api.createIamLdapPolicy(iamLdapPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.LdapProvider' resource.
     * @param iamLdapProvider The &#39;iam.LdapProvider&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamLdapProvider(iamLdapProvider: IamLdapProvider, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamLdapProvider> {
    	const result = this.api.createIamLdapProvider(iamLdapProvider, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.Permission' resource.
     * @param iamPermission The &#39;iam.Permission&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamPermission(iamPermission: IamPermission, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamPermission> {
    	const result = this.api.createIamPermission(iamPermission, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.PrivateKeySpec' resource.
     * @param iamPrivateKeySpec The &#39;iam.PrivateKeySpec&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamPrivateKeySpec(iamPrivateKeySpec: IamPrivateKeySpec, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamPrivateKeySpec> {
    	const result = this.api.createIamPrivateKeySpec(iamPrivateKeySpec, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.Qualifier' resource.
     * @param iamQualifier The &#39;iam.Qualifier&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamQualifier(iamQualifier: IamQualifier, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamQualifier> {
    	const result = this.api.createIamQualifier(iamQualifier, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.ResourceRoles' resource.
     * @param iamResourceRoles The &#39;iam.ResourceRoles&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamResourceRoles(iamResourceRoles: IamResourceRoles, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamResourceRoles> {
    	const result = this.api.createIamResourceRoles(iamResourceRoles, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.SessionLimits' resource.
     * @param iamSessionLimits The &#39;iam.SessionLimits&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamSessionLimits(iamSessionLimits: IamSessionLimits, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamSessionLimits> {
    	const result = this.api.createIamSessionLimits(iamSessionLimits, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.TrustPoint' resource.
     * @param iamTrustPoint The &#39;iam.TrustPoint&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamTrustPoint(iamTrustPoint: IamTrustPoint, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamTrustPoint> {
    	const result = this.api.createIamTrustPoint(iamTrustPoint, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.User' resource.
     * @param iamUser The &#39;iam.User&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamUser(iamUser: IamUser, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamUser> {
    	const result = this.api.createIamUser(iamUser, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'iam.UserGroup' resource.
     * @param iamUserGroup The &#39;iam.UserGroup&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIamUserGroup(iamUserGroup: IamUserGroup, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IamUserGroup> {
    	const result = this.api.createIamUserGroup(iamUserGroup, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.Account' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamAccount(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamAccount(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.ApiKey' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamApiKey(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamApiKey(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.AppRegistration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamAppRegistration(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamAppRegistration(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.Certificate' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamCertificate(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamCertificate(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.CertificateRequest' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamCertificateRequest(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamCertificateRequest(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.EndPointUser' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamEndPointUser(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamEndPointUser(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.EndPointUserPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamEndPointUserPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamEndPointUserPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.EndPointUserRole' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamEndPointUserRole(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamEndPointUserRole(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.Idp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamIdp(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamIdp(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.LdapGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamLdapGroup(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamLdapGroup(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.LdapPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamLdapPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamLdapPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.LdapProvider' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamLdapProvider(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamLdapProvider(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.OAuthToken' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamOAuthToken(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamOAuthToken(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.Permission' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamPermission(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamPermission(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.PrivateKeySpec' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamPrivateKeySpec(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamPrivateKeySpec(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.Qualifier' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamQualifier(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamQualifier(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.ResourceRoles' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamResourceRoles(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamResourceRoles(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.Session' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamSession(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamSession(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.SessionLimits' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamSessionLimits(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamSessionLimits(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.TrustPoint' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamTrustPoint(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamTrustPoint(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.User' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamUser(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamUser(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'iam.UserGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIamUserGroup(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIamUserGroup(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Account' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamAccountByMoid(moid: string, options?: Configuration): Promise<IamAccount> {
    	const result = this.api.getIamAccountByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.AccountExperience' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamAccountExperienceByMoid(moid: string, options?: Configuration): Promise<IamAccountExperience> {
    	const result = this.api.getIamAccountExperienceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.AccountExperience' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamAccountExperienceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamAccountExperienceResponse> {
    	const result = this.api.getIamAccountExperienceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Account' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamAccountList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamAccountResponse> {
    	const result = this.api.getIamAccountList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ApiKey' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamApiKeyByMoid(moid: string, options?: Configuration): Promise<IamApiKey> {
    	const result = this.api.getIamApiKeyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ApiKey' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamApiKeyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamApiKeyResponse> {
    	const result = this.api.getIamApiKeyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.AppRegistration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamAppRegistrationByMoid(moid: string, options?: Configuration): Promise<IamAppRegistration> {
    	const result = this.api.getIamAppRegistrationByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.AppRegistration' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamAppRegistrationList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamAppRegistrationResponse> {
    	const result = this.api.getIamAppRegistrationList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Certificate' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamCertificateByMoid(moid: string, options?: Configuration): Promise<IamCertificate> {
    	const result = this.api.getIamCertificateByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Certificate' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamCertificateList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamCertificateResponse> {
    	const result = this.api.getIamCertificateList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.CertificateRequest' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamCertificateRequestByMoid(moid: string, options?: Configuration): Promise<IamCertificateRequest> {
    	const result = this.api.getIamCertificateRequestByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.CertificateRequest' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamCertificateRequestList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamCertificateRequestResponse> {
    	const result = this.api.getIamCertificateRequestList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.DomainGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamDomainGroupByMoid(moid: string, options?: Configuration): Promise<IamDomainGroup> {
    	const result = this.api.getIamDomainGroupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.DomainGroup' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamDomainGroupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamDomainGroupResponse> {
    	const result = this.api.getIamDomainGroupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointPrivilege' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamEndPointPrivilegeByMoid(moid: string, options?: Configuration): Promise<IamEndPointPrivilege> {
    	const result = this.api.getIamEndPointPrivilegeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointPrivilege' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamEndPointPrivilegeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamEndPointPrivilegeResponse> {
    	const result = this.api.getIamEndPointPrivilegeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointRole' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamEndPointRoleByMoid(moid: string, options?: Configuration): Promise<IamEndPointRole> {
    	const result = this.api.getIamEndPointRoleByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointRole' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamEndPointRoleList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamEndPointRoleResponse> {
    	const result = this.api.getIamEndPointRoleList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointUser' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamEndPointUserByMoid(moid: string, options?: Configuration): Promise<IamEndPointUser> {
    	const result = this.api.getIamEndPointUserByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointUser' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamEndPointUserList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamEndPointUserResponse> {
    	const result = this.api.getIamEndPointUserList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointUserPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamEndPointUserPolicyByMoid(moid: string, options?: Configuration): Promise<IamEndPointUserPolicy> {
    	const result = this.api.getIamEndPointUserPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointUserPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamEndPointUserPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamEndPointUserPolicyResponse> {
    	const result = this.api.getIamEndPointUserPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointUserRole' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamEndPointUserRoleByMoid(moid: string, options?: Configuration): Promise<IamEndPointUserRole> {
    	const result = this.api.getIamEndPointUserRoleByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.EndPointUserRole' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamEndPointUserRoleList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamEndPointUserRoleResponse> {
    	const result = this.api.getIamEndPointUserRoleList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Idp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamIdpByMoid(moid: string, options?: Configuration): Promise<IamIdp> {
    	const result = this.api.getIamIdpByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Idp' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamIdpList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamIdpResponse> {
    	const result = this.api.getIamIdpList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.IdpReference' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamIdpReferenceByMoid(moid: string, options?: Configuration): Promise<IamIdpReference> {
    	const result = this.api.getIamIdpReferenceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.IdpReference' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamIdpReferenceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamIdpReferenceResponse> {
    	const result = this.api.getIamIdpReferenceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.LdapGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamLdapGroupByMoid(moid: string, options?: Configuration): Promise<IamLdapGroup> {
    	const result = this.api.getIamLdapGroupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.LdapGroup' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamLdapGroupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamLdapGroupResponse> {
    	const result = this.api.getIamLdapGroupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.LdapPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamLdapPolicyByMoid(moid: string, options?: Configuration): Promise<IamLdapPolicy> {
    	const result = this.api.getIamLdapPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.LdapPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamLdapPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamLdapPolicyResponse> {
    	const result = this.api.getIamLdapPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.LdapProvider' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamLdapProviderByMoid(moid: string, options?: Configuration): Promise<IamLdapProvider> {
    	const result = this.api.getIamLdapProviderByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.LdapProvider' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamLdapProviderList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamLdapProviderResponse> {
    	const result = this.api.getIamLdapProviderList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.OAuthToken' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamOAuthTokenByMoid(moid: string, options?: Configuration): Promise<IamOAuthToken> {
    	const result = this.api.getIamOAuthTokenByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.OAuthToken' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamOAuthTokenList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamOAuthTokenResponse> {
    	const result = this.api.getIamOAuthTokenList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Permission' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamPermissionByMoid(moid: string, options?: Configuration): Promise<IamPermission> {
    	const result = this.api.getIamPermissionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Permission' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamPermissionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamPermissionResponse> {
    	const result = this.api.getIamPermissionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.PrivateKeySpec' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamPrivateKeySpecByMoid(moid: string, options?: Configuration): Promise<IamPrivateKeySpec> {
    	const result = this.api.getIamPrivateKeySpecByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.PrivateKeySpec' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamPrivateKeySpecList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamPrivateKeySpecResponse> {
    	const result = this.api.getIamPrivateKeySpecList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Privilege' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamPrivilegeByMoid(moid: string, options?: Configuration): Promise<IamPrivilege> {
    	const result = this.api.getIamPrivilegeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Privilege' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamPrivilegeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamPrivilegeResponse> {
    	const result = this.api.getIamPrivilegeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.PrivilegeSet' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamPrivilegeSetByMoid(moid: string, options?: Configuration): Promise<IamPrivilegeSet> {
    	const result = this.api.getIamPrivilegeSetByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.PrivilegeSet' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamPrivilegeSetList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamPrivilegeSetResponse> {
    	const result = this.api.getIamPrivilegeSetList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Qualifier' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamQualifierByMoid(moid: string, options?: Configuration): Promise<IamQualifier> {
    	const result = this.api.getIamQualifierByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Qualifier' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamQualifierList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamQualifierResponse> {
    	const result = this.api.getIamQualifierList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ResourceLimits' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamResourceLimitsByMoid(moid: string, options?: Configuration): Promise<IamResourceLimits> {
    	const result = this.api.getIamResourceLimitsByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ResourceLimits' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamResourceLimitsList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamResourceLimitsResponse> {
    	const result = this.api.getIamResourceLimitsList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ResourcePermission' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamResourcePermissionByMoid(moid: string, options?: Configuration): Promise<IamResourcePermission> {
    	const result = this.api.getIamResourcePermissionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ResourcePermission' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamResourcePermissionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamResourcePermissionResponse> {
    	const result = this.api.getIamResourcePermissionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ResourceRoles' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamResourceRolesByMoid(moid: string, options?: Configuration): Promise<IamResourceRoles> {
    	const result = this.api.getIamResourceRolesByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ResourceRoles' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamResourceRolesList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamResourceRolesResponse> {
    	const result = this.api.getIamResourceRolesList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Role' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamRoleByMoid(moid: string, options?: Configuration): Promise<IamRole> {
    	const result = this.api.getIamRoleByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Role' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamRoleList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamRoleResponse> {
    	const result = this.api.getIamRoleList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.SecurityHolder' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamSecurityHolderByMoid(moid: string, options?: Configuration): Promise<IamSecurityHolder> {
    	const result = this.api.getIamSecurityHolderByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.SecurityHolder' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamSecurityHolderList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamSecurityHolderResponse> {
    	const result = this.api.getIamSecurityHolderList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ServiceProvider' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamServiceProviderByMoid(moid: string, options?: Configuration): Promise<IamServiceProvider> {
    	const result = this.api.getIamServiceProviderByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.ServiceProvider' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamServiceProviderList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamServiceProviderResponse> {
    	const result = this.api.getIamServiceProviderList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Session' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamSessionByMoid(moid: string, options?: Configuration): Promise<IamSession> {
    	const result = this.api.getIamSessionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.SessionLimits' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamSessionLimitsByMoid(moid: string, options?: Configuration): Promise<IamSessionLimits> {
    	const result = this.api.getIamSessionLimitsByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.SessionLimits' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamSessionLimitsList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamSessionLimitsResponse> {
    	const result = this.api.getIamSessionLimitsList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.Session' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamSessionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamSessionResponse> {
    	const result = this.api.getIamSessionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.System' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamSystemByMoid(moid: string, options?: Configuration): Promise<IamSystem> {
    	const result = this.api.getIamSystemByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.System' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamSystemList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamSystemResponse> {
    	const result = this.api.getIamSystemList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.TrustPoint' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamTrustPointByMoid(moid: string, options?: Configuration): Promise<IamTrustPoint> {
    	const result = this.api.getIamTrustPointByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.TrustPoint' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamTrustPointList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamTrustPointResponse> {
    	const result = this.api.getIamTrustPointList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.User' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamUserByMoid(moid: string, options?: Configuration): Promise<IamUser> {
    	const result = this.api.getIamUserByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.UserGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamUserGroupByMoid(moid: string, options?: Configuration): Promise<IamUserGroup> {
    	const result = this.api.getIamUserGroupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.UserGroup' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamUserGroupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamUserGroupResponse> {
    	const result = this.api.getIamUserGroupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.User' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamUserList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamUserResponse> {
    	const result = this.api.getIamUserList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.UserPreference' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIamUserPreferenceByMoid(moid: string, options?: Configuration): Promise<IamUserPreference> {
    	const result = this.api.getIamUserPreferenceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'iam.UserPreference' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIamUserPreferenceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IamUserPreferenceResponse> {
    	const result = this.api.getIamUserPreferenceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Account' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamAccount The &#39;iam.Account&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamAccount(moid: string, iamAccount: IamAccount, ifMatch?: string, options?: Configuration): Promise<IamAccount> {
    	const result = this.api.patchIamAccount(moid, iamAccount, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.ApiKey' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamApiKey The &#39;iam.ApiKey&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamApiKey(moid: string, iamApiKey: IamApiKey, ifMatch?: string, options?: Configuration): Promise<IamApiKey> {
    	const result = this.api.patchIamApiKey(moid, iamApiKey, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.AppRegistration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamAppRegistration The &#39;iam.AppRegistration&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamAppRegistration(moid: string, iamAppRegistration: IamAppRegistration, ifMatch?: string, options?: Configuration): Promise<IamAppRegistration> {
    	const result = this.api.patchIamAppRegistration(moid, iamAppRegistration, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Certificate' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamCertificate The &#39;iam.Certificate&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamCertificate(moid: string, iamCertificate: IamCertificate, ifMatch?: string, options?: Configuration): Promise<IamCertificate> {
    	const result = this.api.patchIamCertificate(moid, iamCertificate, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.CertificateRequest' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamCertificateRequest The &#39;iam.CertificateRequest&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamCertificateRequest(moid: string, iamCertificateRequest: IamCertificateRequest, ifMatch?: string, options?: Configuration): Promise<IamCertificateRequest> {
    	const result = this.api.patchIamCertificateRequest(moid, iamCertificateRequest, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.EndPointUser' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamEndPointUser The &#39;iam.EndPointUser&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamEndPointUser(moid: string, iamEndPointUser: IamEndPointUser, ifMatch?: string, options?: Configuration): Promise<IamEndPointUser> {
    	const result = this.api.patchIamEndPointUser(moid, iamEndPointUser, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.EndPointUserPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamEndPointUserPolicy The &#39;iam.EndPointUserPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamEndPointUserPolicy(moid: string, iamEndPointUserPolicy: IamEndPointUserPolicy, ifMatch?: string, options?: Configuration): Promise<IamEndPointUserPolicy> {
    	const result = this.api.patchIamEndPointUserPolicy(moid, iamEndPointUserPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.EndPointUserRole' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamEndPointUserRole The &#39;iam.EndPointUserRole&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamEndPointUserRole(moid: string, iamEndPointUserRole: IamEndPointUserRole, ifMatch?: string, options?: Configuration): Promise<IamEndPointUserRole> {
    	const result = this.api.patchIamEndPointUserRole(moid, iamEndPointUserRole, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Idp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamIdp The &#39;iam.Idp&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamIdp(moid: string, iamIdp: IamIdp, ifMatch?: string, options?: Configuration): Promise<IamIdp> {
    	const result = this.api.patchIamIdp(moid, iamIdp, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.IdpReference' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamIdpReference The &#39;iam.IdpReference&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamIdpReference(moid: string, iamIdpReference: IamIdpReference, ifMatch?: string, options?: Configuration): Promise<IamIdpReference> {
    	const result = this.api.patchIamIdpReference(moid, iamIdpReference, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.LdapGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamLdapGroup The &#39;iam.LdapGroup&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamLdapGroup(moid: string, iamLdapGroup: IamLdapGroup, ifMatch?: string, options?: Configuration): Promise<IamLdapGroup> {
    	const result = this.api.patchIamLdapGroup(moid, iamLdapGroup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.LdapPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamLdapPolicy The &#39;iam.LdapPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamLdapPolicy(moid: string, iamLdapPolicy: IamLdapPolicy, ifMatch?: string, options?: Configuration): Promise<IamLdapPolicy> {
    	const result = this.api.patchIamLdapPolicy(moid, iamLdapPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.LdapProvider' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamLdapProvider The &#39;iam.LdapProvider&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamLdapProvider(moid: string, iamLdapProvider: IamLdapProvider, ifMatch?: string, options?: Configuration): Promise<IamLdapProvider> {
    	const result = this.api.patchIamLdapProvider(moid, iamLdapProvider, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.LocalUserPassword' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamLocalUserPassword The &#39;iam.LocalUserPassword&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamLocalUserPassword(moid: string, iamLocalUserPassword: IamLocalUserPassword, ifMatch?: string, options?: Configuration): Promise<IamLocalUserPassword> {
    	const result = this.api.patchIamLocalUserPassword(moid, iamLocalUserPassword, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Permission' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamPermission The &#39;iam.Permission&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamPermission(moid: string, iamPermission: IamPermission, ifMatch?: string, options?: Configuration): Promise<IamPermission> {
    	const result = this.api.patchIamPermission(moid, iamPermission, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.PrivateKeySpec' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamPrivateKeySpec The &#39;iam.PrivateKeySpec&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamPrivateKeySpec(moid: string, iamPrivateKeySpec: IamPrivateKeySpec, ifMatch?: string, options?: Configuration): Promise<IamPrivateKeySpec> {
    	const result = this.api.patchIamPrivateKeySpec(moid, iamPrivateKeySpec, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Qualifier' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamQualifier The &#39;iam.Qualifier&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamQualifier(moid: string, iamQualifier: IamQualifier, ifMatch?: string, options?: Configuration): Promise<IamQualifier> {
    	const result = this.api.patchIamQualifier(moid, iamQualifier, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.ResourceRoles' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamResourceRoles The &#39;iam.ResourceRoles&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamResourceRoles(moid: string, iamResourceRoles: IamResourceRoles, ifMatch?: string, options?: Configuration): Promise<IamResourceRoles> {
    	const result = this.api.patchIamResourceRoles(moid, iamResourceRoles, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.SessionLimits' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamSessionLimits The &#39;iam.SessionLimits&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamSessionLimits(moid: string, iamSessionLimits: IamSessionLimits, ifMatch?: string, options?: Configuration): Promise<IamSessionLimits> {
    	const result = this.api.patchIamSessionLimits(moid, iamSessionLimits, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.User' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamUser The &#39;iam.User&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamUser(moid: string, iamUser: IamUser, ifMatch?: string, options?: Configuration): Promise<IamUser> {
    	const result = this.api.patchIamUser(moid, iamUser, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.UserGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamUserGroup The &#39;iam.UserGroup&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamUserGroup(moid: string, iamUserGroup: IamUserGroup, ifMatch?: string, options?: Configuration): Promise<IamUserGroup> {
    	const result = this.api.patchIamUserGroup(moid, iamUserGroup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.UserPreference' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamUserPreference The &#39;iam.UserPreference&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIamUserPreference(moid: string, iamUserPreference: IamUserPreference, ifMatch?: string, options?: Configuration): Promise<IamUserPreference> {
    	const result = this.api.patchIamUserPreference(moid, iamUserPreference, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Account' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamAccount The &#39;iam.Account&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamAccount(moid: string, iamAccount: IamAccount, ifMatch?: string, options?: Configuration): Promise<IamAccount> {
    	const result = this.api.updateIamAccount(moid, iamAccount, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.ApiKey' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamApiKey The &#39;iam.ApiKey&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamApiKey(moid: string, iamApiKey: IamApiKey, ifMatch?: string, options?: Configuration): Promise<IamApiKey> {
    	const result = this.api.updateIamApiKey(moid, iamApiKey, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.AppRegistration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamAppRegistration The &#39;iam.AppRegistration&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamAppRegistration(moid: string, iamAppRegistration: IamAppRegistration, ifMatch?: string, options?: Configuration): Promise<IamAppRegistration> {
    	const result = this.api.updateIamAppRegistration(moid, iamAppRegistration, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Certificate' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamCertificate The &#39;iam.Certificate&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamCertificate(moid: string, iamCertificate: IamCertificate, ifMatch?: string, options?: Configuration): Promise<IamCertificate> {
    	const result = this.api.updateIamCertificate(moid, iamCertificate, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.CertificateRequest' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamCertificateRequest The &#39;iam.CertificateRequest&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamCertificateRequest(moid: string, iamCertificateRequest: IamCertificateRequest, ifMatch?: string, options?: Configuration): Promise<IamCertificateRequest> {
    	const result = this.api.updateIamCertificateRequest(moid, iamCertificateRequest, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.EndPointUser' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamEndPointUser The &#39;iam.EndPointUser&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamEndPointUser(moid: string, iamEndPointUser: IamEndPointUser, ifMatch?: string, options?: Configuration): Promise<IamEndPointUser> {
    	const result = this.api.updateIamEndPointUser(moid, iamEndPointUser, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.EndPointUserPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamEndPointUserPolicy The &#39;iam.EndPointUserPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamEndPointUserPolicy(moid: string, iamEndPointUserPolicy: IamEndPointUserPolicy, ifMatch?: string, options?: Configuration): Promise<IamEndPointUserPolicy> {
    	const result = this.api.updateIamEndPointUserPolicy(moid, iamEndPointUserPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.EndPointUserRole' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamEndPointUserRole The &#39;iam.EndPointUserRole&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamEndPointUserRole(moid: string, iamEndPointUserRole: IamEndPointUserRole, ifMatch?: string, options?: Configuration): Promise<IamEndPointUserRole> {
    	const result = this.api.updateIamEndPointUserRole(moid, iamEndPointUserRole, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Idp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamIdp The &#39;iam.Idp&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamIdp(moid: string, iamIdp: IamIdp, ifMatch?: string, options?: Configuration): Promise<IamIdp> {
    	const result = this.api.updateIamIdp(moid, iamIdp, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.IdpReference' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamIdpReference The &#39;iam.IdpReference&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamIdpReference(moid: string, iamIdpReference: IamIdpReference, ifMatch?: string, options?: Configuration): Promise<IamIdpReference> {
    	const result = this.api.updateIamIdpReference(moid, iamIdpReference, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.LdapGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamLdapGroup The &#39;iam.LdapGroup&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamLdapGroup(moid: string, iamLdapGroup: IamLdapGroup, ifMatch?: string, options?: Configuration): Promise<IamLdapGroup> {
    	const result = this.api.updateIamLdapGroup(moid, iamLdapGroup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.LdapPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamLdapPolicy The &#39;iam.LdapPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamLdapPolicy(moid: string, iamLdapPolicy: IamLdapPolicy, ifMatch?: string, options?: Configuration): Promise<IamLdapPolicy> {
    	const result = this.api.updateIamLdapPolicy(moid, iamLdapPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.LdapProvider' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamLdapProvider The &#39;iam.LdapProvider&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamLdapProvider(moid: string, iamLdapProvider: IamLdapProvider, ifMatch?: string, options?: Configuration): Promise<IamLdapProvider> {
    	const result = this.api.updateIamLdapProvider(moid, iamLdapProvider, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.LocalUserPassword' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamLocalUserPassword The &#39;iam.LocalUserPassword&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamLocalUserPassword(moid: string, iamLocalUserPassword: IamLocalUserPassword, ifMatch?: string, options?: Configuration): Promise<IamLocalUserPassword> {
    	const result = this.api.updateIamLocalUserPassword(moid, iamLocalUserPassword, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Permission' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamPermission The &#39;iam.Permission&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamPermission(moid: string, iamPermission: IamPermission, ifMatch?: string, options?: Configuration): Promise<IamPermission> {
    	const result = this.api.updateIamPermission(moid, iamPermission, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.PrivateKeySpec' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamPrivateKeySpec The &#39;iam.PrivateKeySpec&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamPrivateKeySpec(moid: string, iamPrivateKeySpec: IamPrivateKeySpec, ifMatch?: string, options?: Configuration): Promise<IamPrivateKeySpec> {
    	const result = this.api.updateIamPrivateKeySpec(moid, iamPrivateKeySpec, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.Qualifier' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamQualifier The &#39;iam.Qualifier&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamQualifier(moid: string, iamQualifier: IamQualifier, ifMatch?: string, options?: Configuration): Promise<IamQualifier> {
    	const result = this.api.updateIamQualifier(moid, iamQualifier, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.ResourceRoles' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamResourceRoles The &#39;iam.ResourceRoles&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamResourceRoles(moid: string, iamResourceRoles: IamResourceRoles, ifMatch?: string, options?: Configuration): Promise<IamResourceRoles> {
    	const result = this.api.updateIamResourceRoles(moid, iamResourceRoles, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.SessionLimits' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamSessionLimits The &#39;iam.SessionLimits&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamSessionLimits(moid: string, iamSessionLimits: IamSessionLimits, ifMatch?: string, options?: Configuration): Promise<IamSessionLimits> {
    	const result = this.api.updateIamSessionLimits(moid, iamSessionLimits, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.User' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamUser The &#39;iam.User&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamUser(moid: string, iamUser: IamUser, ifMatch?: string, options?: Configuration): Promise<IamUser> {
    	const result = this.api.updateIamUser(moid, iamUser, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.UserGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamUserGroup The &#39;iam.UserGroup&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamUserGroup(moid: string, iamUserGroup: IamUserGroup, ifMatch?: string, options?: Configuration): Promise<IamUserGroup> {
    	const result = this.api.updateIamUserGroup(moid, iamUserGroup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'iam.UserPreference' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param iamUserPreference The &#39;iam.UserPreference&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIamUserPreference(moid: string, iamUserPreference: IamUserPreference, ifMatch?: string, options?: Configuration): Promise<IamUserPreference> {
    	const result = this.api.updateIamUserPreference(moid, iamUserPreference, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableInventoryApi } from './ObservableAPI';


import { InventoryApiRequestFactory, InventoryApiResponseProcessor} from "../apis/InventoryApi";
export class PromiseInventoryApi {
    private api: ObservableInventoryApi

    public constructor(
        configuration: Configuration,
        requestFactory?: InventoryApiRequestFactory,
        responseProcessor?: InventoryApiResponseProcessor
    ) {
        this.api = new ObservableInventoryApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'inventory.Request' resource.
     * @param inventoryRequest The &#39;inventory.Request&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createInventoryRequest(inventoryRequest: InventoryRequest, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<InventoryRequest> {
    	const result = this.api.createInventoryRequest(inventoryRequest, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'inventory.DeviceInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getInventoryDeviceInfoByMoid(moid: string, options?: Configuration): Promise<InventoryDeviceInfo> {
    	const result = this.api.getInventoryDeviceInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'inventory.DeviceInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getInventoryDeviceInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<InventoryDeviceInfoResponse> {
    	const result = this.api.getInventoryDeviceInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'inventory.DnMoBinding' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getInventoryDnMoBindingByMoid(moid: string, options?: Configuration): Promise<InventoryDnMoBinding> {
    	const result = this.api.getInventoryDnMoBindingByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'inventory.DnMoBinding' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getInventoryDnMoBindingList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<InventoryDnMoBindingResponse> {
    	const result = this.api.getInventoryDnMoBindingList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'inventory.GenericInventory' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getInventoryGenericInventoryByMoid(moid: string, options?: Configuration): Promise<InventoryGenericInventory> {
    	const result = this.api.getInventoryGenericInventoryByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'inventory.GenericInventoryHolder' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getInventoryGenericInventoryHolderByMoid(moid: string, options?: Configuration): Promise<InventoryGenericInventoryHolder> {
    	const result = this.api.getInventoryGenericInventoryHolderByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'inventory.GenericInventoryHolder' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getInventoryGenericInventoryHolderList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<InventoryGenericInventoryHolderResponse> {
    	const result = this.api.getInventoryGenericInventoryHolderList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'inventory.GenericInventory' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getInventoryGenericInventoryList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<InventoryGenericInventoryResponse> {
    	const result = this.api.getInventoryGenericInventoryList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'inventory.GenericInventory' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param inventoryGenericInventory The &#39;inventory.GenericInventory&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchInventoryGenericInventory(moid: string, inventoryGenericInventory: InventoryGenericInventory, ifMatch?: string, options?: Configuration): Promise<InventoryGenericInventory> {
    	const result = this.api.patchInventoryGenericInventory(moid, inventoryGenericInventory, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'inventory.GenericInventoryHolder' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param inventoryGenericInventoryHolder The &#39;inventory.GenericInventoryHolder&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchInventoryGenericInventoryHolder(moid: string, inventoryGenericInventoryHolder: InventoryGenericInventoryHolder, ifMatch?: string, options?: Configuration): Promise<InventoryGenericInventoryHolder> {
    	const result = this.api.patchInventoryGenericInventoryHolder(moid, inventoryGenericInventoryHolder, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'inventory.GenericInventory' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param inventoryGenericInventory The &#39;inventory.GenericInventory&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateInventoryGenericInventory(moid: string, inventoryGenericInventory: InventoryGenericInventory, ifMatch?: string, options?: Configuration): Promise<InventoryGenericInventory> {
    	const result = this.api.updateInventoryGenericInventory(moid, inventoryGenericInventory, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'inventory.GenericInventoryHolder' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param inventoryGenericInventoryHolder The &#39;inventory.GenericInventoryHolder&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateInventoryGenericInventoryHolder(moid: string, inventoryGenericInventoryHolder: InventoryGenericInventoryHolder, ifMatch?: string, options?: Configuration): Promise<InventoryGenericInventoryHolder> {
    	const result = this.api.updateInventoryGenericInventoryHolder(moid, inventoryGenericInventoryHolder, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableIpmioverlanApi } from './ObservableAPI';


import { IpmioverlanApiRequestFactory, IpmioverlanApiResponseProcessor} from "../apis/IpmioverlanApi";
export class PromiseIpmioverlanApi {
    private api: ObservableIpmioverlanApi

    public constructor(
        configuration: Configuration,
        requestFactory?: IpmioverlanApiRequestFactory,
        responseProcessor?: IpmioverlanApiResponseProcessor
    ) {
        this.api = new ObservableIpmioverlanApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'ipmioverlan.Policy' resource.
     * @param ipmioverlanPolicy The &#39;ipmioverlan.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createIpmioverlanPolicy(ipmioverlanPolicy: IpmioverlanPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<IpmioverlanPolicy> {
    	const result = this.api.createIpmioverlanPolicy(ipmioverlanPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'ipmioverlan.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteIpmioverlanPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteIpmioverlanPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ipmioverlan.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getIpmioverlanPolicyByMoid(moid: string, options?: Configuration): Promise<IpmioverlanPolicy> {
    	const result = this.api.getIpmioverlanPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ipmioverlan.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getIpmioverlanPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<IpmioverlanPolicyResponse> {
    	const result = this.api.getIpmioverlanPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ipmioverlan.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param ipmioverlanPolicy The &#39;ipmioverlan.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchIpmioverlanPolicy(moid: string, ipmioverlanPolicy: IpmioverlanPolicy, ifMatch?: string, options?: Configuration): Promise<IpmioverlanPolicy> {
    	const result = this.api.patchIpmioverlanPolicy(moid, ipmioverlanPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ipmioverlan.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param ipmioverlanPolicy The &#39;ipmioverlan.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateIpmioverlanPolicy(moid: string, ipmioverlanPolicy: IpmioverlanPolicy, ifMatch?: string, options?: Configuration): Promise<IpmioverlanPolicy> {
    	const result = this.api.updateIpmioverlanPolicy(moid, ipmioverlanPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableKvmApi } from './ObservableAPI';


import { KvmApiRequestFactory, KvmApiResponseProcessor} from "../apis/KvmApi";
export class PromiseKvmApi {
    private api: ObservableKvmApi

    public constructor(
        configuration: Configuration,
        requestFactory?: KvmApiRequestFactory,
        responseProcessor?: KvmApiResponseProcessor
    ) {
        this.api = new ObservableKvmApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'kvm.Policy' resource.
     * @param kvmPolicy The &#39;kvm.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createKvmPolicy(kvmPolicy: KvmPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<KvmPolicy> {
    	const result = this.api.createKvmPolicy(kvmPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'kvm.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteKvmPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteKvmPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'kvm.KvmSession' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getKvmKvmSessionByMoid(moid: string, options?: Configuration): Promise<KvmKvmSession> {
    	const result = this.api.getKvmKvmSessionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'kvm.KvmSession' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getKvmKvmSessionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<KvmKvmSessionResponse> {
    	const result = this.api.getKvmKvmSessionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'kvm.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getKvmPolicyByMoid(moid: string, options?: Configuration): Promise<KvmPolicy> {
    	const result = this.api.getKvmPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'kvm.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getKvmPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<KvmPolicyResponse> {
    	const result = this.api.getKvmPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'kvm.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param kvmPolicy The &#39;kvm.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchKvmPolicy(moid: string, kvmPolicy: KvmPolicy, ifMatch?: string, options?: Configuration): Promise<KvmPolicy> {
    	const result = this.api.patchKvmPolicy(moid, kvmPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'kvm.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param kvmPolicy The &#39;kvm.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateKvmPolicy(moid: string, kvmPolicy: KvmPolicy, ifMatch?: string, options?: Configuration): Promise<KvmPolicy> {
    	const result = this.api.updateKvmPolicy(moid, kvmPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableLicenseApi } from './ObservableAPI';


import { LicenseApiRequestFactory, LicenseApiResponseProcessor} from "../apis/LicenseApi";
export class PromiseLicenseApi {
    private api: ObservableLicenseApi

    public constructor(
        configuration: Configuration,
        requestFactory?: LicenseApiRequestFactory,
        responseProcessor?: LicenseApiResponseProcessor
    ) {
        this.api = new ObservableLicenseApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'license.LicenseInfo' resource.
     * @param licenseLicenseInfo The &#39;license.LicenseInfo&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createLicenseLicenseInfo(licenseLicenseInfo: LicenseLicenseInfo, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<LicenseLicenseInfo> {
    	const result = this.api.createLicenseLicenseInfo(licenseLicenseInfo, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'license.AccountLicenseData' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getLicenseAccountLicenseDataByMoid(moid: string, options?: Configuration): Promise<LicenseAccountLicenseData> {
    	const result = this.api.getLicenseAccountLicenseDataByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'license.AccountLicenseData' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getLicenseAccountLicenseDataList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<LicenseAccountLicenseDataResponse> {
    	const result = this.api.getLicenseAccountLicenseDataList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'license.CustomerOp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getLicenseCustomerOpByMoid(moid: string, options?: Configuration): Promise<LicenseCustomerOp> {
    	const result = this.api.getLicenseCustomerOpByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'license.CustomerOp' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getLicenseCustomerOpList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<LicenseCustomerOpResponse> {
    	const result = this.api.getLicenseCustomerOpList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'license.LicenseInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getLicenseLicenseInfoByMoid(moid: string, options?: Configuration): Promise<LicenseLicenseInfo> {
    	const result = this.api.getLicenseLicenseInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'license.LicenseInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getLicenseLicenseInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<LicenseLicenseInfoResponse> {
    	const result = this.api.getLicenseLicenseInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'license.SmartlicenseToken' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getLicenseSmartlicenseTokenByMoid(moid: string, options?: Configuration): Promise<LicenseSmartlicenseToken> {
    	const result = this.api.getLicenseSmartlicenseTokenByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'license.SmartlicenseToken' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getLicenseSmartlicenseTokenList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<LicenseSmartlicenseTokenResponse> {
    	const result = this.api.getLicenseSmartlicenseTokenList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'license.AccountLicenseData' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param licenseAccountLicenseData The &#39;license.AccountLicenseData&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchLicenseAccountLicenseData(moid: string, licenseAccountLicenseData: LicenseAccountLicenseData, ifMatch?: string, options?: Configuration): Promise<LicenseAccountLicenseData> {
    	const result = this.api.patchLicenseAccountLicenseData(moid, licenseAccountLicenseData, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'license.CustomerOp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param licenseCustomerOp The &#39;license.CustomerOp&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchLicenseCustomerOp(moid: string, licenseCustomerOp: LicenseCustomerOp, ifMatch?: string, options?: Configuration): Promise<LicenseCustomerOp> {
    	const result = this.api.patchLicenseCustomerOp(moid, licenseCustomerOp, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'license.LicenseInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param licenseLicenseInfo The &#39;license.LicenseInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchLicenseLicenseInfo(moid: string, licenseLicenseInfo: LicenseLicenseInfo, ifMatch?: string, options?: Configuration): Promise<LicenseLicenseInfo> {
    	const result = this.api.patchLicenseLicenseInfo(moid, licenseLicenseInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'license.SmartlicenseToken' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param licenseSmartlicenseToken The &#39;license.SmartlicenseToken&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchLicenseSmartlicenseToken(moid: string, licenseSmartlicenseToken: LicenseSmartlicenseToken, ifMatch?: string, options?: Configuration): Promise<LicenseSmartlicenseToken> {
    	const result = this.api.patchLicenseSmartlicenseToken(moid, licenseSmartlicenseToken, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'license.AccountLicenseData' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param licenseAccountLicenseData The &#39;license.AccountLicenseData&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateLicenseAccountLicenseData(moid: string, licenseAccountLicenseData: LicenseAccountLicenseData, ifMatch?: string, options?: Configuration): Promise<LicenseAccountLicenseData> {
    	const result = this.api.updateLicenseAccountLicenseData(moid, licenseAccountLicenseData, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'license.CustomerOp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param licenseCustomerOp The &#39;license.CustomerOp&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateLicenseCustomerOp(moid: string, licenseCustomerOp: LicenseCustomerOp, ifMatch?: string, options?: Configuration): Promise<LicenseCustomerOp> {
    	const result = this.api.updateLicenseCustomerOp(moid, licenseCustomerOp, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'license.LicenseInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param licenseLicenseInfo The &#39;license.LicenseInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateLicenseLicenseInfo(moid: string, licenseLicenseInfo: LicenseLicenseInfo, ifMatch?: string, options?: Configuration): Promise<LicenseLicenseInfo> {
    	const result = this.api.updateLicenseLicenseInfo(moid, licenseLicenseInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'license.SmartlicenseToken' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param licenseSmartlicenseToken The &#39;license.SmartlicenseToken&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateLicenseSmartlicenseToken(moid: string, licenseSmartlicenseToken: LicenseSmartlicenseToken, ifMatch?: string, options?: Configuration): Promise<LicenseSmartlicenseToken> {
    	const result = this.api.updateLicenseSmartlicenseToken(moid, licenseSmartlicenseToken, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableLsApi } from './ObservableAPI';


import { LsApiRequestFactory, LsApiResponseProcessor} from "../apis/LsApi";
export class PromiseLsApi {
    private api: ObservableLsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: LsApiRequestFactory,
        responseProcessor?: LsApiResponseProcessor
    ) {
        this.api = new ObservableLsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'ls.ServiceProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getLsServiceProfileByMoid(moid: string, options?: Configuration): Promise<LsServiceProfile> {
    	const result = this.api.getLsServiceProfileByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ls.ServiceProfile' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getLsServiceProfileList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<LsServiceProfileResponse> {
    	const result = this.api.getLsServiceProfileList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ls.ServiceProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param lsServiceProfile The &#39;ls.ServiceProfile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchLsServiceProfile(moid: string, lsServiceProfile: LsServiceProfile, ifMatch?: string, options?: Configuration): Promise<LsServiceProfile> {
    	const result = this.api.patchLsServiceProfile(moid, lsServiceProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ls.ServiceProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param lsServiceProfile The &#39;ls.ServiceProfile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateLsServiceProfile(moid: string, lsServiceProfile: LsServiceProfile, ifMatch?: string, options?: Configuration): Promise<LsServiceProfile> {
    	const result = this.api.updateLsServiceProfile(moid, lsServiceProfile, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableManagementApi } from './ObservableAPI';


import { ManagementApiRequestFactory, ManagementApiResponseProcessor} from "../apis/ManagementApi";
export class PromiseManagementApi {
    private api: ObservableManagementApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ManagementApiRequestFactory,
        responseProcessor?: ManagementApiResponseProcessor
    ) {
        this.api = new ObservableManagementApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'management.Controller' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getManagementControllerByMoid(moid: string, options?: Configuration): Promise<ManagementController> {
    	const result = this.api.getManagementControllerByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'management.Controller' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getManagementControllerList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ManagementControllerResponse> {
    	const result = this.api.getManagementControllerList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'management.Entity' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getManagementEntityByMoid(moid: string, options?: Configuration): Promise<ManagementEntity> {
    	const result = this.api.getManagementEntityByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'management.Entity' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getManagementEntityList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ManagementEntityResponse> {
    	const result = this.api.getManagementEntityList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'management.Interface' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getManagementInterfaceByMoid(moid: string, options?: Configuration): Promise<ManagementInterface> {
    	const result = this.api.getManagementInterfaceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'management.Interface' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getManagementInterfaceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ManagementInterfaceResponse> {
    	const result = this.api.getManagementInterfaceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'management.Controller' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param managementController The &#39;management.Controller&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchManagementController(moid: string, managementController: ManagementController, ifMatch?: string, options?: Configuration): Promise<ManagementController> {
    	const result = this.api.patchManagementController(moid, managementController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'management.Entity' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param managementEntity The &#39;management.Entity&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchManagementEntity(moid: string, managementEntity: ManagementEntity, ifMatch?: string, options?: Configuration): Promise<ManagementEntity> {
    	const result = this.api.patchManagementEntity(moid, managementEntity, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'management.Interface' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param managementInterface The &#39;management.Interface&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchManagementInterface(moid: string, managementInterface: ManagementInterface, ifMatch?: string, options?: Configuration): Promise<ManagementInterface> {
    	const result = this.api.patchManagementInterface(moid, managementInterface, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'management.Controller' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param managementController The &#39;management.Controller&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateManagementController(moid: string, managementController: ManagementController, ifMatch?: string, options?: Configuration): Promise<ManagementController> {
    	const result = this.api.updateManagementController(moid, managementController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'management.Entity' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param managementEntity The &#39;management.Entity&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateManagementEntity(moid: string, managementEntity: ManagementEntity, ifMatch?: string, options?: Configuration): Promise<ManagementEntity> {
    	const result = this.api.updateManagementEntity(moid, managementEntity, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'management.Interface' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param managementInterface The &#39;management.Interface&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateManagementInterface(moid: string, managementInterface: ManagementInterface, ifMatch?: string, options?: Configuration): Promise<ManagementInterface> {
    	const result = this.api.updateManagementInterface(moid, managementInterface, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableMemoryApi } from './ObservableAPI';


import { MemoryApiRequestFactory, MemoryApiResponseProcessor} from "../apis/MemoryApi";
export class PromiseMemoryApi {
    private api: ObservableMemoryApi

    public constructor(
        configuration: Configuration,
        requestFactory?: MemoryApiRequestFactory,
        responseProcessor?: MemoryApiResponseProcessor
    ) {
        this.api = new ObservableMemoryApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'memory.PersistentMemoryPolicy' resource.
     * @param memoryPersistentMemoryPolicy The &#39;memory.PersistentMemoryPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createMemoryPersistentMemoryPolicy(memoryPersistentMemoryPolicy: MemoryPersistentMemoryPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryPolicy> {
    	const result = this.api.createMemoryPersistentMemoryPolicy(memoryPersistentMemoryPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'memory.PersistentMemoryPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteMemoryPersistentMemoryPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteMemoryPersistentMemoryPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.Array' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMemoryArrayByMoid(moid: string, options?: Configuration): Promise<MemoryArray> {
    	const result = this.api.getMemoryArrayByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.Array' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMemoryArrayList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MemoryArrayResponse> {
    	const result = this.api.getMemoryArrayList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryConfigResult' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMemoryPersistentMemoryConfigResultByMoid(moid: string, options?: Configuration): Promise<MemoryPersistentMemoryConfigResult> {
    	const result = this.api.getMemoryPersistentMemoryConfigResultByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryConfigResult' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMemoryPersistentMemoryConfigResultList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MemoryPersistentMemoryConfigResultResponse> {
    	const result = this.api.getMemoryPersistentMemoryConfigResultList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryConfiguration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMemoryPersistentMemoryConfigurationByMoid(moid: string, options?: Configuration): Promise<MemoryPersistentMemoryConfiguration> {
    	const result = this.api.getMemoryPersistentMemoryConfigurationByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryConfiguration' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMemoryPersistentMemoryConfigurationList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MemoryPersistentMemoryConfigurationResponse> {
    	const result = this.api.getMemoryPersistentMemoryConfigurationList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryNamespace' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMemoryPersistentMemoryNamespaceByMoid(moid: string, options?: Configuration): Promise<MemoryPersistentMemoryNamespace> {
    	const result = this.api.getMemoryPersistentMemoryNamespaceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryNamespaceConfigResult' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMemoryPersistentMemoryNamespaceConfigResultByMoid(moid: string, options?: Configuration): Promise<MemoryPersistentMemoryNamespaceConfigResult> {
    	const result = this.api.getMemoryPersistentMemoryNamespaceConfigResultByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryNamespaceConfigResult' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMemoryPersistentMemoryNamespaceConfigResultList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MemoryPersistentMemoryNamespaceConfigResultResponse> {
    	const result = this.api.getMemoryPersistentMemoryNamespaceConfigResultList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryNamespace' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMemoryPersistentMemoryNamespaceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MemoryPersistentMemoryNamespaceResponse> {
    	const result = this.api.getMemoryPersistentMemoryNamespaceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMemoryPersistentMemoryPolicyByMoid(moid: string, options?: Configuration): Promise<MemoryPersistentMemoryPolicy> {
    	const result = this.api.getMemoryPersistentMemoryPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMemoryPersistentMemoryPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MemoryPersistentMemoryPolicyResponse> {
    	const result = this.api.getMemoryPersistentMemoryPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryRegion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMemoryPersistentMemoryRegionByMoid(moid: string, options?: Configuration): Promise<MemoryPersistentMemoryRegion> {
    	const result = this.api.getMemoryPersistentMemoryRegionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryRegion' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMemoryPersistentMemoryRegionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MemoryPersistentMemoryRegionResponse> {
    	const result = this.api.getMemoryPersistentMemoryRegionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryUnit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMemoryPersistentMemoryUnitByMoid(moid: string, options?: Configuration): Promise<MemoryPersistentMemoryUnit> {
    	const result = this.api.getMemoryPersistentMemoryUnitByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.PersistentMemoryUnit' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMemoryPersistentMemoryUnitList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MemoryPersistentMemoryUnitResponse> {
    	const result = this.api.getMemoryPersistentMemoryUnitList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMemoryUnitByMoid(moid: string, options?: Configuration): Promise<MemoryUnit> {
    	const result = this.api.getMemoryUnitByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'memory.Unit' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMemoryUnitList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MemoryUnitResponse> {
    	const result = this.api.getMemoryUnitList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.Array' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryArray The &#39;memory.Array&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchMemoryArray(moid: string, memoryArray: MemoryArray, ifMatch?: string, options?: Configuration): Promise<MemoryArray> {
    	const result = this.api.patchMemoryArray(moid, memoryArray, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryConfigResult' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryConfigResult The &#39;memory.PersistentMemoryConfigResult&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchMemoryPersistentMemoryConfigResult(moid: string, memoryPersistentMemoryConfigResult: MemoryPersistentMemoryConfigResult, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryConfigResult> {
    	const result = this.api.patchMemoryPersistentMemoryConfigResult(moid, memoryPersistentMemoryConfigResult, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryConfiguration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryConfiguration The &#39;memory.PersistentMemoryConfiguration&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchMemoryPersistentMemoryConfiguration(moid: string, memoryPersistentMemoryConfiguration: MemoryPersistentMemoryConfiguration, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryConfiguration> {
    	const result = this.api.patchMemoryPersistentMemoryConfiguration(moid, memoryPersistentMemoryConfiguration, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryNamespace' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryNamespace The &#39;memory.PersistentMemoryNamespace&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchMemoryPersistentMemoryNamespace(moid: string, memoryPersistentMemoryNamespace: MemoryPersistentMemoryNamespace, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryNamespace> {
    	const result = this.api.patchMemoryPersistentMemoryNamespace(moid, memoryPersistentMemoryNamespace, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryNamespaceConfigResult' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryNamespaceConfigResult The &#39;memory.PersistentMemoryNamespaceConfigResult&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchMemoryPersistentMemoryNamespaceConfigResult(moid: string, memoryPersistentMemoryNamespaceConfigResult: MemoryPersistentMemoryNamespaceConfigResult, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryNamespaceConfigResult> {
    	const result = this.api.patchMemoryPersistentMemoryNamespaceConfigResult(moid, memoryPersistentMemoryNamespaceConfigResult, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryPolicy The &#39;memory.PersistentMemoryPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchMemoryPersistentMemoryPolicy(moid: string, memoryPersistentMemoryPolicy: MemoryPersistentMemoryPolicy, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryPolicy> {
    	const result = this.api.patchMemoryPersistentMemoryPolicy(moid, memoryPersistentMemoryPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryRegion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryRegion The &#39;memory.PersistentMemoryRegion&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchMemoryPersistentMemoryRegion(moid: string, memoryPersistentMemoryRegion: MemoryPersistentMemoryRegion, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryRegion> {
    	const result = this.api.patchMemoryPersistentMemoryRegion(moid, memoryPersistentMemoryRegion, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryUnit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryUnit The &#39;memory.PersistentMemoryUnit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchMemoryPersistentMemoryUnit(moid: string, memoryPersistentMemoryUnit: MemoryPersistentMemoryUnit, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryUnit> {
    	const result = this.api.patchMemoryPersistentMemoryUnit(moid, memoryPersistentMemoryUnit, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryUnit The &#39;memory.Unit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchMemoryUnit(moid: string, memoryUnit: MemoryUnit, ifMatch?: string, options?: Configuration): Promise<MemoryUnit> {
    	const result = this.api.patchMemoryUnit(moid, memoryUnit, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.Array' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryArray The &#39;memory.Array&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateMemoryArray(moid: string, memoryArray: MemoryArray, ifMatch?: string, options?: Configuration): Promise<MemoryArray> {
    	const result = this.api.updateMemoryArray(moid, memoryArray, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryConfigResult' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryConfigResult The &#39;memory.PersistentMemoryConfigResult&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateMemoryPersistentMemoryConfigResult(moid: string, memoryPersistentMemoryConfigResult: MemoryPersistentMemoryConfigResult, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryConfigResult> {
    	const result = this.api.updateMemoryPersistentMemoryConfigResult(moid, memoryPersistentMemoryConfigResult, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryConfiguration' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryConfiguration The &#39;memory.PersistentMemoryConfiguration&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateMemoryPersistentMemoryConfiguration(moid: string, memoryPersistentMemoryConfiguration: MemoryPersistentMemoryConfiguration, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryConfiguration> {
    	const result = this.api.updateMemoryPersistentMemoryConfiguration(moid, memoryPersistentMemoryConfiguration, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryNamespace' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryNamespace The &#39;memory.PersistentMemoryNamespace&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateMemoryPersistentMemoryNamespace(moid: string, memoryPersistentMemoryNamespace: MemoryPersistentMemoryNamespace, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryNamespace> {
    	const result = this.api.updateMemoryPersistentMemoryNamespace(moid, memoryPersistentMemoryNamespace, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryNamespaceConfigResult' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryNamespaceConfigResult The &#39;memory.PersistentMemoryNamespaceConfigResult&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateMemoryPersistentMemoryNamespaceConfigResult(moid: string, memoryPersistentMemoryNamespaceConfigResult: MemoryPersistentMemoryNamespaceConfigResult, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryNamespaceConfigResult> {
    	const result = this.api.updateMemoryPersistentMemoryNamespaceConfigResult(moid, memoryPersistentMemoryNamespaceConfigResult, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryPolicy The &#39;memory.PersistentMemoryPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateMemoryPersistentMemoryPolicy(moid: string, memoryPersistentMemoryPolicy: MemoryPersistentMemoryPolicy, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryPolicy> {
    	const result = this.api.updateMemoryPersistentMemoryPolicy(moid, memoryPersistentMemoryPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryRegion' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryRegion The &#39;memory.PersistentMemoryRegion&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateMemoryPersistentMemoryRegion(moid: string, memoryPersistentMemoryRegion: MemoryPersistentMemoryRegion, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryRegion> {
    	const result = this.api.updateMemoryPersistentMemoryRegion(moid, memoryPersistentMemoryRegion, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.PersistentMemoryUnit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryPersistentMemoryUnit The &#39;memory.PersistentMemoryUnit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateMemoryPersistentMemoryUnit(moid: string, memoryPersistentMemoryUnit: MemoryPersistentMemoryUnit, ifMatch?: string, options?: Configuration): Promise<MemoryPersistentMemoryUnit> {
    	const result = this.api.updateMemoryPersistentMemoryUnit(moid, memoryPersistentMemoryUnit, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'memory.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param memoryUnit The &#39;memory.Unit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateMemoryUnit(moid: string, memoryUnit: MemoryUnit, ifMatch?: string, options?: Configuration): Promise<MemoryUnit> {
    	const result = this.api.updateMemoryUnit(moid, memoryUnit, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableMetaApi } from './ObservableAPI';


import { MetaApiRequestFactory, MetaApiResponseProcessor} from "../apis/MetaApi";
export class PromiseMetaApi {
    private api: ObservableMetaApi

    public constructor(
        configuration: Configuration,
        requestFactory?: MetaApiRequestFactory,
        responseProcessor?: MetaApiResponseProcessor
    ) {
        this.api = new ObservableMetaApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Delete a 'meta.Definition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteMetaDefinition(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteMetaDefinition(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'meta.Definition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getMetaDefinitionByMoid(moid: string, options?: Configuration): Promise<MetaDefinition> {
    	const result = this.api.getMetaDefinitionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'meta.Definition' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getMetaDefinitionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<MetaDefinitionResponse> {
    	const result = this.api.getMetaDefinitionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableNetworkApi } from './ObservableAPI';


import { NetworkApiRequestFactory, NetworkApiResponseProcessor} from "../apis/NetworkApi";
export class PromiseNetworkApi {
    private api: ObservableNetworkApi

    public constructor(
        configuration: Configuration,
        requestFactory?: NetworkApiRequestFactory,
        responseProcessor?: NetworkApiResponseProcessor
    ) {
        this.api = new ObservableNetworkApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'network.Element' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNetworkElementByMoid(moid: string, options?: Configuration): Promise<NetworkElement> {
    	const result = this.api.getNetworkElementByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'network.Element' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNetworkElementList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NetworkElementResponse> {
    	const result = this.api.getNetworkElementList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'network.ElementSummary' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNetworkElementSummaryByMoid(moid: string, options?: Configuration): Promise<NetworkElementSummary> {
    	const result = this.api.getNetworkElementSummaryByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'network.ElementSummary' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNetworkElementSummaryList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NetworkElementSummaryResponse> {
    	const result = this.api.getNetworkElementSummaryList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'network.Element' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param networkElement The &#39;network.Element&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchNetworkElement(moid: string, networkElement: NetworkElement, ifMatch?: string, options?: Configuration): Promise<NetworkElement> {
    	const result = this.api.patchNetworkElement(moid, networkElement, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'network.Element' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param networkElement The &#39;network.Element&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateNetworkElement(moid: string, networkElement: NetworkElement, ifMatch?: string, options?: Configuration): Promise<NetworkElement> {
    	const result = this.api.updateNetworkElement(moid, networkElement, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableNetworkconfigApi } from './ObservableAPI';


import { NetworkconfigApiRequestFactory, NetworkconfigApiResponseProcessor} from "../apis/NetworkconfigApi";
export class PromiseNetworkconfigApi {
    private api: ObservableNetworkconfigApi

    public constructor(
        configuration: Configuration,
        requestFactory?: NetworkconfigApiRequestFactory,
        responseProcessor?: NetworkconfigApiResponseProcessor
    ) {
        this.api = new ObservableNetworkconfigApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'networkconfig.Policy' resource.
     * @param networkconfigPolicy The &#39;networkconfig.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createNetworkconfigPolicy(networkconfigPolicy: NetworkconfigPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<NetworkconfigPolicy> {
    	const result = this.api.createNetworkconfigPolicy(networkconfigPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'networkconfig.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteNetworkconfigPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteNetworkconfigPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'networkconfig.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNetworkconfigPolicyByMoid(moid: string, options?: Configuration): Promise<NetworkconfigPolicy> {
    	const result = this.api.getNetworkconfigPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'networkconfig.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNetworkconfigPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NetworkconfigPolicyResponse> {
    	const result = this.api.getNetworkconfigPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'networkconfig.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param networkconfigPolicy The &#39;networkconfig.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchNetworkconfigPolicy(moid: string, networkconfigPolicy: NetworkconfigPolicy, ifMatch?: string, options?: Configuration): Promise<NetworkconfigPolicy> {
    	const result = this.api.patchNetworkconfigPolicy(moid, networkconfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'networkconfig.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param networkconfigPolicy The &#39;networkconfig.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateNetworkconfigPolicy(moid: string, networkconfigPolicy: NetworkconfigPolicy, ifMatch?: string, options?: Configuration): Promise<NetworkconfigPolicy> {
    	const result = this.api.updateNetworkconfigPolicy(moid, networkconfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableNiaapiApi } from './ObservableAPI';


import { NiaapiApiRequestFactory, NiaapiApiResponseProcessor} from "../apis/NiaapiApi";
export class PromiseNiaapiApi {
    private api: ObservableNiaapiApi

    public constructor(
        configuration: Configuration,
        requestFactory?: NiaapiApiRequestFactory,
        responseProcessor?: NiaapiApiResponseProcessor
    ) {
        this.api = new ObservableNiaapiApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'niaapi.ApicCcoPost' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiApicCcoPostByMoid(moid: string, options?: Configuration): Promise<NiaapiApicCcoPost> {
    	const result = this.api.getNiaapiApicCcoPostByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicCcoPost' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiApicCcoPostList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiApicCcoPostResponse> {
    	const result = this.api.getNiaapiApicCcoPostList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicFieldNotice' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiApicFieldNoticeByMoid(moid: string, options?: Configuration): Promise<NiaapiApicFieldNotice> {
    	const result = this.api.getNiaapiApicFieldNoticeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicFieldNotice' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiApicFieldNoticeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiApicFieldNoticeResponse> {
    	const result = this.api.getNiaapiApicFieldNoticeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicHweol' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiApicHweolByMoid(moid: string, options?: Configuration): Promise<NiaapiApicHweol> {
    	const result = this.api.getNiaapiApicHweolByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicHweol' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiApicHweolList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiApicHweolResponse> {
    	const result = this.api.getNiaapiApicHweolList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicLatestMaintainedRelease' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiApicLatestMaintainedReleaseByMoid(moid: string, options?: Configuration): Promise<NiaapiApicLatestMaintainedRelease> {
    	const result = this.api.getNiaapiApicLatestMaintainedReleaseByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicLatestMaintainedRelease' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiApicLatestMaintainedReleaseList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiApicLatestMaintainedReleaseResponse> {
    	const result = this.api.getNiaapiApicLatestMaintainedReleaseList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicReleaseRecommend' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiApicReleaseRecommendByMoid(moid: string, options?: Configuration): Promise<NiaapiApicReleaseRecommend> {
    	const result = this.api.getNiaapiApicReleaseRecommendByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicReleaseRecommend' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiApicReleaseRecommendList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiApicReleaseRecommendResponse> {
    	const result = this.api.getNiaapiApicReleaseRecommendList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicSweol' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiApicSweolByMoid(moid: string, options?: Configuration): Promise<NiaapiApicSweol> {
    	const result = this.api.getNiaapiApicSweolByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.ApicSweol' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiApicSweolList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiApicSweolResponse> {
    	const result = this.api.getNiaapiApicSweolList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmCcoPost' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiDcnmCcoPostByMoid(moid: string, options?: Configuration): Promise<NiaapiDcnmCcoPost> {
    	const result = this.api.getNiaapiDcnmCcoPostByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmCcoPost' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiDcnmCcoPostList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiDcnmCcoPostResponse> {
    	const result = this.api.getNiaapiDcnmCcoPostList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmFieldNotice' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiDcnmFieldNoticeByMoid(moid: string, options?: Configuration): Promise<NiaapiDcnmFieldNotice> {
    	const result = this.api.getNiaapiDcnmFieldNoticeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmFieldNotice' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiDcnmFieldNoticeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiDcnmFieldNoticeResponse> {
    	const result = this.api.getNiaapiDcnmFieldNoticeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmHweol' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiDcnmHweolByMoid(moid: string, options?: Configuration): Promise<NiaapiDcnmHweol> {
    	const result = this.api.getNiaapiDcnmHweolByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmHweol' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiDcnmHweolList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiDcnmHweolResponse> {
    	const result = this.api.getNiaapiDcnmHweolList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmLatestMaintainedRelease' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiDcnmLatestMaintainedReleaseByMoid(moid: string, options?: Configuration): Promise<NiaapiDcnmLatestMaintainedRelease> {
    	const result = this.api.getNiaapiDcnmLatestMaintainedReleaseByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmLatestMaintainedRelease' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiDcnmLatestMaintainedReleaseList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiDcnmLatestMaintainedReleaseResponse> {
    	const result = this.api.getNiaapiDcnmLatestMaintainedReleaseList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmReleaseRecommend' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiDcnmReleaseRecommendByMoid(moid: string, options?: Configuration): Promise<NiaapiDcnmReleaseRecommend> {
    	const result = this.api.getNiaapiDcnmReleaseRecommendByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmReleaseRecommend' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiDcnmReleaseRecommendList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiDcnmReleaseRecommendResponse> {
    	const result = this.api.getNiaapiDcnmReleaseRecommendList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmSweol' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiDcnmSweolByMoid(moid: string, options?: Configuration): Promise<NiaapiDcnmSweol> {
    	const result = this.api.getNiaapiDcnmSweolByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.DcnmSweol' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiDcnmSweolList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiDcnmSweolResponse> {
    	const result = this.api.getNiaapiDcnmSweolList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.FileDownloader' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiFileDownloaderByMoid(moid: string, options?: Configuration): Promise<NiaapiFileDownloader> {
    	const result = this.api.getNiaapiFileDownloaderByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.FileDownloader' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiFileDownloaderList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiFileDownloaderResponse> {
    	const result = this.api.getNiaapiFileDownloaderList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.NiaMetadata' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiNiaMetadataByMoid(moid: string, options?: Configuration): Promise<NiaapiNiaMetadata> {
    	const result = this.api.getNiaapiNiaMetadataByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.NiaMetadata' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiNiaMetadataList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiNiaMetadataResponse> {
    	const result = this.api.getNiaapiNiaMetadataList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.VersionRegex' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiaapiVersionRegexByMoid(moid: string, options?: Configuration): Promise<NiaapiVersionRegex> {
    	const result = this.api.getNiaapiVersionRegexByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niaapi.VersionRegex' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiaapiVersionRegexList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiaapiVersionRegexResponse> {
    	const result = this.api.getNiaapiVersionRegexList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableNiatelemetryApi } from './ObservableAPI';


import { NiatelemetryApiRequestFactory, NiatelemetryApiResponseProcessor} from "../apis/NiatelemetryApi";
export class PromiseNiatelemetryApi {
    private api: ObservableNiatelemetryApi

    public constructor(
        configuration: Configuration,
        requestFactory?: NiatelemetryApiRequestFactory,
        responseProcessor?: NiatelemetryApiResponseProcessor
    ) {
        this.api = new ObservableNiatelemetryApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'niatelemetry.NiaFeatureUsage' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiatelemetryNiaFeatureUsageByMoid(moid: string, options?: Configuration): Promise<NiatelemetryNiaFeatureUsage> {
    	const result = this.api.getNiatelemetryNiaFeatureUsageByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niatelemetry.NiaFeatureUsage' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiatelemetryNiaFeatureUsageList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiatelemetryNiaFeatureUsageResponse> {
    	const result = this.api.getNiatelemetryNiaFeatureUsageList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niatelemetry.NiaInventory' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiatelemetryNiaInventoryByMoid(moid: string, options?: Configuration): Promise<NiatelemetryNiaInventory> {
    	const result = this.api.getNiatelemetryNiaInventoryByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niatelemetry.NiaInventory' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiatelemetryNiaInventoryList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiatelemetryNiaInventoryResponse> {
    	const result = this.api.getNiatelemetryNiaInventoryList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niatelemetry.NiaLicenseState' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNiatelemetryNiaLicenseStateByMoid(moid: string, options?: Configuration): Promise<NiatelemetryNiaLicenseState> {
    	const result = this.api.getNiatelemetryNiaLicenseStateByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'niatelemetry.NiaLicenseState' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNiatelemetryNiaLicenseStateList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NiatelemetryNiaLicenseStateResponse> {
    	const result = this.api.getNiatelemetryNiaLicenseStateList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableNtpApi } from './ObservableAPI';


import { NtpApiRequestFactory, NtpApiResponseProcessor} from "../apis/NtpApi";
export class PromiseNtpApi {
    private api: ObservableNtpApi

    public constructor(
        configuration: Configuration,
        requestFactory?: NtpApiRequestFactory,
        responseProcessor?: NtpApiResponseProcessor
    ) {
        this.api = new ObservableNtpApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'ntp.Policy' resource.
     * @param ntpPolicy The &#39;ntp.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createNtpPolicy(ntpPolicy: NtpPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<NtpPolicy> {
    	const result = this.api.createNtpPolicy(ntpPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'ntp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteNtpPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteNtpPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ntp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getNtpPolicyByMoid(moid: string, options?: Configuration): Promise<NtpPolicy> {
    	const result = this.api.getNtpPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ntp.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getNtpPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<NtpPolicyResponse> {
    	const result = this.api.getNtpPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ntp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param ntpPolicy The &#39;ntp.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchNtpPolicy(moid: string, ntpPolicy: NtpPolicy, ifMatch?: string, options?: Configuration): Promise<NtpPolicy> {
    	const result = this.api.patchNtpPolicy(moid, ntpPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ntp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param ntpPolicy The &#39;ntp.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateNtpPolicy(moid: string, ntpPolicy: NtpPolicy, ifMatch?: string, options?: Configuration): Promise<NtpPolicy> {
    	const result = this.api.updateNtpPolicy(moid, ntpPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableOrganizationApi } from './ObservableAPI';


import { OrganizationApiRequestFactory, OrganizationApiResponseProcessor} from "../apis/OrganizationApi";
export class PromiseOrganizationApi {
    private api: ObservableOrganizationApi

    public constructor(
        configuration: Configuration,
        requestFactory?: OrganizationApiRequestFactory,
        responseProcessor?: OrganizationApiResponseProcessor
    ) {
        this.api = new ObservableOrganizationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'organization.Organization' resource.
     * @param organizationOrganization The &#39;organization.Organization&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createOrganizationOrganization(organizationOrganization: OrganizationOrganization, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<OrganizationOrganization> {
    	const result = this.api.createOrganizationOrganization(organizationOrganization, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'organization.Organization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteOrganizationOrganization(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteOrganizationOrganization(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'organization.Organization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getOrganizationOrganizationByMoid(moid: string, options?: Configuration): Promise<OrganizationOrganization> {
    	const result = this.api.getOrganizationOrganizationByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'organization.Organization' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getOrganizationOrganizationList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<OrganizationOrganizationResponse> {
    	const result = this.api.getOrganizationOrganizationList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'organization.Organization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param organizationOrganization The &#39;organization.Organization&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchOrganizationOrganization(moid: string, organizationOrganization: OrganizationOrganization, ifMatch?: string, options?: Configuration): Promise<OrganizationOrganization> {
    	const result = this.api.patchOrganizationOrganization(moid, organizationOrganization, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'organization.Organization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param organizationOrganization The &#39;organization.Organization&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateOrganizationOrganization(moid: string, organizationOrganization: OrganizationOrganization, ifMatch?: string, options?: Configuration): Promise<OrganizationOrganization> {
    	const result = this.api.updateOrganizationOrganization(moid, organizationOrganization, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableOsApi } from './ObservableAPI';


import { OsApiRequestFactory, OsApiResponseProcessor} from "../apis/OsApi";
export class PromiseOsApi {
    private api: ObservableOsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: OsApiRequestFactory,
        responseProcessor?: OsApiResponseProcessor
    ) {
        this.api = new ObservableOsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'os.ConfigurationFile' resource.
     * @param osConfigurationFile The &#39;os.ConfigurationFile&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createOsConfigurationFile(osConfigurationFile: OsConfigurationFile, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<OsConfigurationFile> {
    	const result = this.api.createOsConfigurationFile(osConfigurationFile, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'os.Install' resource.
     * @param osInstall The &#39;os.Install&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createOsInstall(osInstall: OsInstall, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<OsInstall> {
    	const result = this.api.createOsInstall(osInstall, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'os.OsSupport' resource.
     * @param osOsSupport The &#39;os.OsSupport&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createOsOsSupport(osOsSupport: OsOsSupport, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<OsOsSupport> {
    	const result = this.api.createOsOsSupport(osOsSupport, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'os.TemplateFile' resource.
     * @param osTemplateFile The &#39;os.TemplateFile&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createOsTemplateFile(osTemplateFile: OsTemplateFile, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<OsTemplateFile> {
    	const result = this.api.createOsTemplateFile(osTemplateFile, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'os.ConfigurationFile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteOsConfigurationFile(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteOsConfigurationFile(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'os.Catalog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getOsCatalogByMoid(moid: string, options?: Configuration): Promise<OsCatalog> {
    	const result = this.api.getOsCatalogByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'os.Catalog' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getOsCatalogList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<OsCatalogResponse> {
    	const result = this.api.getOsCatalogList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'os.ConfigurationFile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getOsConfigurationFileByMoid(moid: string, options?: Configuration): Promise<OsConfigurationFile> {
    	const result = this.api.getOsConfigurationFileByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'os.ConfigurationFile' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getOsConfigurationFileList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<OsConfigurationFileResponse> {
    	const result = this.api.getOsConfigurationFileList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'os.Install' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getOsInstallByMoid(moid: string, options?: Configuration): Promise<OsInstall> {
    	const result = this.api.getOsInstallByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'os.Install' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getOsInstallList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<OsInstallResponse> {
    	const result = this.api.getOsInstallList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservablePciApi } from './ObservableAPI';


import { PciApiRequestFactory, PciApiResponseProcessor} from "../apis/PciApi";
export class PromisePciApi {
    private api: ObservablePciApi

    public constructor(
        configuration: Configuration,
        requestFactory?: PciApiRequestFactory,
        responseProcessor?: PciApiResponseProcessor
    ) {
        this.api = new ObservablePciApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'pci.CoprocessorCard' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getPciCoprocessorCardByMoid(moid: string, options?: Configuration): Promise<PciCoprocessorCard> {
    	const result = this.api.getPciCoprocessorCardByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'pci.CoprocessorCard' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getPciCoprocessorCardList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<PciCoprocessorCardResponse> {
    	const result = this.api.getPciCoprocessorCardList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'pci.Device' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getPciDeviceByMoid(moid: string, options?: Configuration): Promise<PciDevice> {
    	const result = this.api.getPciDeviceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'pci.Device' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getPciDeviceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<PciDeviceResponse> {
    	const result = this.api.getPciDeviceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'pci.Link' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getPciLinkByMoid(moid: string, options?: Configuration): Promise<PciLink> {
    	const result = this.api.getPciLinkByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'pci.Link' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getPciLinkList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<PciLinkResponse> {
    	const result = this.api.getPciLinkList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'pci.Switch' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getPciSwitchByMoid(moid: string, options?: Configuration): Promise<PciSwitch> {
    	const result = this.api.getPciSwitchByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'pci.Switch' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getPciSwitchList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<PciSwitchResponse> {
    	const result = this.api.getPciSwitchList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'pci.Device' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param pciDevice The &#39;pci.Device&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchPciDevice(moid: string, pciDevice: PciDevice, ifMatch?: string, options?: Configuration): Promise<PciDevice> {
    	const result = this.api.patchPciDevice(moid, pciDevice, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'pci.Link' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param pciLink The &#39;pci.Link&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchPciLink(moid: string, pciLink: PciLink, ifMatch?: string, options?: Configuration): Promise<PciLink> {
    	const result = this.api.patchPciLink(moid, pciLink, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'pci.Switch' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param pciSwitch The &#39;pci.Switch&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchPciSwitch(moid: string, pciSwitch: PciSwitch, ifMatch?: string, options?: Configuration): Promise<PciSwitch> {
    	const result = this.api.patchPciSwitch(moid, pciSwitch, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'pci.Device' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param pciDevice The &#39;pci.Device&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updatePciDevice(moid: string, pciDevice: PciDevice, ifMatch?: string, options?: Configuration): Promise<PciDevice> {
    	const result = this.api.updatePciDevice(moid, pciDevice, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'pci.Link' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param pciLink The &#39;pci.Link&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updatePciLink(moid: string, pciLink: PciLink, ifMatch?: string, options?: Configuration): Promise<PciLink> {
    	const result = this.api.updatePciLink(moid, pciLink, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'pci.Switch' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param pciSwitch The &#39;pci.Switch&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updatePciSwitch(moid: string, pciSwitch: PciSwitch, ifMatch?: string, options?: Configuration): Promise<PciSwitch> {
    	const result = this.api.updatePciSwitch(moid, pciSwitch, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservablePortApi } from './ObservableAPI';


import { PortApiRequestFactory, PortApiResponseProcessor} from "../apis/PortApi";
export class PromisePortApi {
    private api: ObservablePortApi

    public constructor(
        configuration: Configuration,
        requestFactory?: PortApiRequestFactory,
        responseProcessor?: PortApiResponseProcessor
    ) {
        this.api = new ObservablePortApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'port.Group' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getPortGroupByMoid(moid: string, options?: Configuration): Promise<PortGroup> {
    	const result = this.api.getPortGroupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'port.Group' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getPortGroupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<PortGroupResponse> {
    	const result = this.api.getPortGroupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'port.SubGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getPortSubGroupByMoid(moid: string, options?: Configuration): Promise<PortSubGroup> {
    	const result = this.api.getPortSubGroupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'port.SubGroup' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getPortSubGroupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<PortSubGroupResponse> {
    	const result = this.api.getPortSubGroupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'port.Group' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param portGroup The &#39;port.Group&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchPortGroup(moid: string, portGroup: PortGroup, ifMatch?: string, options?: Configuration): Promise<PortGroup> {
    	const result = this.api.patchPortGroup(moid, portGroup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'port.SubGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param portSubGroup The &#39;port.SubGroup&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchPortSubGroup(moid: string, portSubGroup: PortSubGroup, ifMatch?: string, options?: Configuration): Promise<PortSubGroup> {
    	const result = this.api.patchPortSubGroup(moid, portSubGroup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'port.Group' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param portGroup The &#39;port.Group&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updatePortGroup(moid: string, portGroup: PortGroup, ifMatch?: string, options?: Configuration): Promise<PortGroup> {
    	const result = this.api.updatePortGroup(moid, portGroup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'port.SubGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param portSubGroup The &#39;port.SubGroup&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updatePortSubGroup(moid: string, portSubGroup: PortSubGroup, ifMatch?: string, options?: Configuration): Promise<PortSubGroup> {
    	const result = this.api.updatePortSubGroup(moid, portSubGroup, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableProcessorApi } from './ObservableAPI';


import { ProcessorApiRequestFactory, ProcessorApiResponseProcessor} from "../apis/ProcessorApi";
export class PromiseProcessorApi {
    private api: ObservableProcessorApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ProcessorApiRequestFactory,
        responseProcessor?: ProcessorApiResponseProcessor
    ) {
        this.api = new ObservableProcessorApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'processor.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getProcessorUnitByMoid(moid: string, options?: Configuration): Promise<ProcessorUnit> {
    	const result = this.api.getProcessorUnitByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'processor.Unit' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getProcessorUnitList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ProcessorUnitResponse> {
    	const result = this.api.getProcessorUnitList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'processor.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param processorUnit The &#39;processor.Unit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchProcessorUnit(moid: string, processorUnit: ProcessorUnit, ifMatch?: string, options?: Configuration): Promise<ProcessorUnit> {
    	const result = this.api.patchProcessorUnit(moid, processorUnit, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'processor.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param processorUnit The &#39;processor.Unit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateProcessorUnit(moid: string, processorUnit: ProcessorUnit, ifMatch?: string, options?: Configuration): Promise<ProcessorUnit> {
    	const result = this.api.updateProcessorUnit(moid, processorUnit, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableRecoveryApi } from './ObservableAPI';


import { RecoveryApiRequestFactory, RecoveryApiResponseProcessor} from "../apis/RecoveryApi";
export class PromiseRecoveryApi {
    private api: ObservableRecoveryApi

    public constructor(
        configuration: Configuration,
        requestFactory?: RecoveryApiRequestFactory,
        responseProcessor?: RecoveryApiResponseProcessor
    ) {
        this.api = new ObservableRecoveryApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'recovery.BackupConfigPolicy' resource.
     * @param recoveryBackupConfigPolicy The &#39;recovery.BackupConfigPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createRecoveryBackupConfigPolicy(recoveryBackupConfigPolicy: RecoveryBackupConfigPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<RecoveryBackupConfigPolicy> {
    	const result = this.api.createRecoveryBackupConfigPolicy(recoveryBackupConfigPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'recovery.BackupProfile' resource.
     * @param recoveryBackupProfile The &#39;recovery.BackupProfile&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createRecoveryBackupProfile(recoveryBackupProfile: RecoveryBackupProfile, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<RecoveryBackupProfile> {
    	const result = this.api.createRecoveryBackupProfile(recoveryBackupProfile, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'recovery.OnDemandBackup' resource.
     * @param recoveryOnDemandBackup The &#39;recovery.OnDemandBackup&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createRecoveryOnDemandBackup(recoveryOnDemandBackup: RecoveryOnDemandBackup, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<RecoveryOnDemandBackup> {
    	const result = this.api.createRecoveryOnDemandBackup(recoveryOnDemandBackup, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'recovery.Restore' resource.
     * @param recoveryRestore The &#39;recovery.Restore&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createRecoveryRestore(recoveryRestore: RecoveryRestore, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<RecoveryRestore> {
    	const result = this.api.createRecoveryRestore(recoveryRestore, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'recovery.ScheduleConfigPolicy' resource.
     * @param recoveryScheduleConfigPolicy The &#39;recovery.ScheduleConfigPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createRecoveryScheduleConfigPolicy(recoveryScheduleConfigPolicy: RecoveryScheduleConfigPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<RecoveryScheduleConfigPolicy> {
    	const result = this.api.createRecoveryScheduleConfigPolicy(recoveryScheduleConfigPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'recovery.BackupConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteRecoveryBackupConfigPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteRecoveryBackupConfigPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'recovery.BackupProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteRecoveryBackupProfile(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteRecoveryBackupProfile(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'recovery.OnDemandBackup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteRecoveryOnDemandBackup(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteRecoveryOnDemandBackup(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'recovery.Restore' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteRecoveryRestore(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteRecoveryRestore(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'recovery.ScheduleConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteRecoveryScheduleConfigPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteRecoveryScheduleConfigPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.BackupConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getRecoveryBackupConfigPolicyByMoid(moid: string, options?: Configuration): Promise<RecoveryBackupConfigPolicy> {
    	const result = this.api.getRecoveryBackupConfigPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.BackupConfigPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getRecoveryBackupConfigPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<RecoveryBackupConfigPolicyResponse> {
    	const result = this.api.getRecoveryBackupConfigPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.BackupProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getRecoveryBackupProfileByMoid(moid: string, options?: Configuration): Promise<RecoveryBackupProfile> {
    	const result = this.api.getRecoveryBackupProfileByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.BackupProfile' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getRecoveryBackupProfileList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<RecoveryBackupProfileResponse> {
    	const result = this.api.getRecoveryBackupProfileList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.ConfigResult' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getRecoveryConfigResultByMoid(moid: string, options?: Configuration): Promise<RecoveryConfigResult> {
    	const result = this.api.getRecoveryConfigResultByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.ConfigResultEntry' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getRecoveryConfigResultEntryByMoid(moid: string, options?: Configuration): Promise<RecoveryConfigResultEntry> {
    	const result = this.api.getRecoveryConfigResultEntryByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.ConfigResultEntry' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getRecoveryConfigResultEntryList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<RecoveryConfigResultEntryResponse> {
    	const result = this.api.getRecoveryConfigResultEntryList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.ConfigResult' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getRecoveryConfigResultList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<RecoveryConfigResultResponse> {
    	const result = this.api.getRecoveryConfigResultList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.OnDemandBackup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getRecoveryOnDemandBackupByMoid(moid: string, options?: Configuration): Promise<RecoveryOnDemandBackup> {
    	const result = this.api.getRecoveryOnDemandBackupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.OnDemandBackup' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getRecoveryOnDemandBackupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<RecoveryOnDemandBackupResponse> {
    	const result = this.api.getRecoveryOnDemandBackupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.Restore' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getRecoveryRestoreByMoid(moid: string, options?: Configuration): Promise<RecoveryRestore> {
    	const result = this.api.getRecoveryRestoreByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.Restore' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getRecoveryRestoreList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<RecoveryRestoreResponse> {
    	const result = this.api.getRecoveryRestoreList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.ScheduleConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getRecoveryScheduleConfigPolicyByMoid(moid: string, options?: Configuration): Promise<RecoveryScheduleConfigPolicy> {
    	const result = this.api.getRecoveryScheduleConfigPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'recovery.ScheduleConfigPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getRecoveryScheduleConfigPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<RecoveryScheduleConfigPolicyResponse> {
    	const result = this.api.getRecoveryScheduleConfigPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'recovery.BackupConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param recoveryBackupConfigPolicy The &#39;recovery.BackupConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchRecoveryBackupConfigPolicy(moid: string, recoveryBackupConfigPolicy: RecoveryBackupConfigPolicy, ifMatch?: string, options?: Configuration): Promise<RecoveryBackupConfigPolicy> {
    	const result = this.api.patchRecoveryBackupConfigPolicy(moid, recoveryBackupConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'recovery.BackupProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param recoveryBackupProfile The &#39;recovery.BackupProfile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchRecoveryBackupProfile(moid: string, recoveryBackupProfile: RecoveryBackupProfile, ifMatch?: string, options?: Configuration): Promise<RecoveryBackupProfile> {
    	const result = this.api.patchRecoveryBackupProfile(moid, recoveryBackupProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'recovery.OnDemandBackup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param recoveryOnDemandBackup The &#39;recovery.OnDemandBackup&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchRecoveryOnDemandBackup(moid: string, recoveryOnDemandBackup: RecoveryOnDemandBackup, ifMatch?: string, options?: Configuration): Promise<RecoveryOnDemandBackup> {
    	const result = this.api.patchRecoveryOnDemandBackup(moid, recoveryOnDemandBackup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'recovery.ScheduleConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param recoveryScheduleConfigPolicy The &#39;recovery.ScheduleConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchRecoveryScheduleConfigPolicy(moid: string, recoveryScheduleConfigPolicy: RecoveryScheduleConfigPolicy, ifMatch?: string, options?: Configuration): Promise<RecoveryScheduleConfigPolicy> {
    	const result = this.api.patchRecoveryScheduleConfigPolicy(moid, recoveryScheduleConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'recovery.BackupConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param recoveryBackupConfigPolicy The &#39;recovery.BackupConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateRecoveryBackupConfigPolicy(moid: string, recoveryBackupConfigPolicy: RecoveryBackupConfigPolicy, ifMatch?: string, options?: Configuration): Promise<RecoveryBackupConfigPolicy> {
    	const result = this.api.updateRecoveryBackupConfigPolicy(moid, recoveryBackupConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'recovery.BackupProfile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param recoveryBackupProfile The &#39;recovery.BackupProfile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateRecoveryBackupProfile(moid: string, recoveryBackupProfile: RecoveryBackupProfile, ifMatch?: string, options?: Configuration): Promise<RecoveryBackupProfile> {
    	const result = this.api.updateRecoveryBackupProfile(moid, recoveryBackupProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'recovery.OnDemandBackup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param recoveryOnDemandBackup The &#39;recovery.OnDemandBackup&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateRecoveryOnDemandBackup(moid: string, recoveryOnDemandBackup: RecoveryOnDemandBackup, ifMatch?: string, options?: Configuration): Promise<RecoveryOnDemandBackup> {
    	const result = this.api.updateRecoveryOnDemandBackup(moid, recoveryOnDemandBackup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'recovery.ScheduleConfigPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param recoveryScheduleConfigPolicy The &#39;recovery.ScheduleConfigPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateRecoveryScheduleConfigPolicy(moid: string, recoveryScheduleConfigPolicy: RecoveryScheduleConfigPolicy, ifMatch?: string, options?: Configuration): Promise<RecoveryScheduleConfigPolicy> {
    	const result = this.api.updateRecoveryScheduleConfigPolicy(moid, recoveryScheduleConfigPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableResourceApi } from './ObservableAPI';


import { ResourceApiRequestFactory, ResourceApiResponseProcessor} from "../apis/ResourceApi";
export class PromiseResourceApi {
    private api: ObservableResourceApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ResourceApiRequestFactory,
        responseProcessor?: ResourceApiResponseProcessor
    ) {
        this.api = new ObservableResourceApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'resource.Group' resource.
     * @param resourceGroup The &#39;resource.Group&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createResourceGroup(resourceGroup: ResourceGroup, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ResourceGroup> {
    	const result = this.api.createResourceGroup(resourceGroup, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'resource.Group' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteResourceGroup(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteResourceGroup(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.Group' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getResourceGroupByMoid(moid: string, options?: Configuration): Promise<ResourceGroup> {
    	const result = this.api.getResourceGroupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.Group' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getResourceGroupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ResourceGroupResponse> {
    	const result = this.api.getResourceGroupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.GroupMember' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getResourceGroupMemberByMoid(moid: string, options?: Configuration): Promise<ResourceGroupMember> {
    	const result = this.api.getResourceGroupMemberByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.GroupMember' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getResourceGroupMemberList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ResourceGroupMemberResponse> {
    	const result = this.api.getResourceGroupMemberList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.LicenseResourceCount' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getResourceLicenseResourceCountByMoid(moid: string, options?: Configuration): Promise<ResourceLicenseResourceCount> {
    	const result = this.api.getResourceLicenseResourceCountByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.LicenseResourceCount' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getResourceLicenseResourceCountList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ResourceLicenseResourceCountResponse> {
    	const result = this.api.getResourceLicenseResourceCountList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.Membership' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getResourceMembershipByMoid(moid: string, options?: Configuration): Promise<ResourceMembership> {
    	const result = this.api.getResourceMembershipByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.MembershipHolder' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getResourceMembershipHolderByMoid(moid: string, options?: Configuration): Promise<ResourceMembershipHolder> {
    	const result = this.api.getResourceMembershipHolderByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.MembershipHolder' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getResourceMembershipHolderList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ResourceMembershipHolderResponse> {
    	const result = this.api.getResourceMembershipHolderList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'resource.Membership' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getResourceMembershipList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ResourceMembershipResponse> {
    	const result = this.api.getResourceMembershipList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'resource.Group' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param resourceGroup The &#39;resource.Group&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchResourceGroup(moid: string, resourceGroup: ResourceGroup, ifMatch?: string, options?: Configuration): Promise<ResourceGroup> {
    	const result = this.api.patchResourceGroup(moid, resourceGroup, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'resource.Group' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param resourceGroup The &#39;resource.Group&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateResourceGroup(moid: string, resourceGroup: ResourceGroup, ifMatch?: string, options?: Configuration): Promise<ResourceGroup> {
    	const result = this.api.updateResourceGroup(moid, resourceGroup, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSdcardApi } from './ObservableAPI';


import { SdcardApiRequestFactory, SdcardApiResponseProcessor} from "../apis/SdcardApi";
export class PromiseSdcardApi {
    private api: ObservableSdcardApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SdcardApiRequestFactory,
        responseProcessor?: SdcardApiResponseProcessor
    ) {
        this.api = new ObservableSdcardApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'sdcard.Policy' resource.
     * @param sdcardPolicy The &#39;sdcard.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSdcardPolicy(sdcardPolicy: SdcardPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SdcardPolicy> {
    	const result = this.api.createSdcardPolicy(sdcardPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'sdcard.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSdcardPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSdcardPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdcard.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSdcardPolicyByMoid(moid: string, options?: Configuration): Promise<SdcardPolicy> {
    	const result = this.api.getSdcardPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdcard.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSdcardPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SdcardPolicyResponse> {
    	const result = this.api.getSdcardPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdcard.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdcardPolicy The &#39;sdcard.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSdcardPolicy(moid: string, sdcardPolicy: SdcardPolicy, ifMatch?: string, options?: Configuration): Promise<SdcardPolicy> {
    	const result = this.api.patchSdcardPolicy(moid, sdcardPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdcard.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdcardPolicy The &#39;sdcard.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSdcardPolicy(moid: string, sdcardPolicy: SdcardPolicy, ifMatch?: string, options?: Configuration): Promise<SdcardPolicy> {
    	const result = this.api.updateSdcardPolicy(moid, sdcardPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSdwanApi } from './ObservableAPI';


import { SdwanApiRequestFactory, SdwanApiResponseProcessor} from "../apis/SdwanApi";
export class PromiseSdwanApi {
    private api: ObservableSdwanApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SdwanApiRequestFactory,
        responseProcessor?: SdwanApiResponseProcessor
    ) {
        this.api = new ObservableSdwanApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'sdwan.Profile' resource.
     * @param sdwanProfile The &#39;sdwan.Profile&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSdwanProfile(sdwanProfile: SdwanProfile, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SdwanProfile> {
    	const result = this.api.createSdwanProfile(sdwanProfile, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'sdwan.RouterNode' resource.
     * @param sdwanRouterNode The &#39;sdwan.RouterNode&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSdwanRouterNode(sdwanRouterNode: SdwanRouterNode, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SdwanRouterNode> {
    	const result = this.api.createSdwanRouterNode(sdwanRouterNode, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'sdwan.RouterPolicy' resource.
     * @param sdwanRouterPolicy The &#39;sdwan.RouterPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSdwanRouterPolicy(sdwanRouterPolicy: SdwanRouterPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SdwanRouterPolicy> {
    	const result = this.api.createSdwanRouterPolicy(sdwanRouterPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'sdwan.VmanageAccountPolicy' resource.
     * @param sdwanVmanageAccountPolicy The &#39;sdwan.VmanageAccountPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSdwanVmanageAccountPolicy(sdwanVmanageAccountPolicy: SdwanVmanageAccountPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SdwanVmanageAccountPolicy> {
    	const result = this.api.createSdwanVmanageAccountPolicy(sdwanVmanageAccountPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'sdwan.Profile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSdwanProfile(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSdwanProfile(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'sdwan.RouterNode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSdwanRouterNode(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSdwanRouterNode(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'sdwan.RouterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSdwanRouterPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSdwanRouterPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'sdwan.VmanageAccountPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSdwanVmanageAccountPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSdwanVmanageAccountPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdwan.Profile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSdwanProfileByMoid(moid: string, options?: Configuration): Promise<SdwanProfile> {
    	const result = this.api.getSdwanProfileByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdwan.Profile' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSdwanProfileList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SdwanProfileResponse> {
    	const result = this.api.getSdwanProfileList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdwan.RouterNode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSdwanRouterNodeByMoid(moid: string, options?: Configuration): Promise<SdwanRouterNode> {
    	const result = this.api.getSdwanRouterNodeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdwan.RouterNode' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSdwanRouterNodeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SdwanRouterNodeResponse> {
    	const result = this.api.getSdwanRouterNodeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdwan.RouterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSdwanRouterPolicyByMoid(moid: string, options?: Configuration): Promise<SdwanRouterPolicy> {
    	const result = this.api.getSdwanRouterPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdwan.RouterPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSdwanRouterPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SdwanRouterPolicyResponse> {
    	const result = this.api.getSdwanRouterPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdwan.VmanageAccountPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSdwanVmanageAccountPolicyByMoid(moid: string, options?: Configuration): Promise<SdwanVmanageAccountPolicy> {
    	const result = this.api.getSdwanVmanageAccountPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sdwan.VmanageAccountPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSdwanVmanageAccountPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SdwanVmanageAccountPolicyResponse> {
    	const result = this.api.getSdwanVmanageAccountPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdwan.Profile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdwanProfile The &#39;sdwan.Profile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSdwanProfile(moid: string, sdwanProfile: SdwanProfile, ifMatch?: string, options?: Configuration): Promise<SdwanProfile> {
    	const result = this.api.patchSdwanProfile(moid, sdwanProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdwan.RouterNode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdwanRouterNode The &#39;sdwan.RouterNode&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSdwanRouterNode(moid: string, sdwanRouterNode: SdwanRouterNode, ifMatch?: string, options?: Configuration): Promise<SdwanRouterNode> {
    	const result = this.api.patchSdwanRouterNode(moid, sdwanRouterNode, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdwan.RouterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdwanRouterPolicy The &#39;sdwan.RouterPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSdwanRouterPolicy(moid: string, sdwanRouterPolicy: SdwanRouterPolicy, ifMatch?: string, options?: Configuration): Promise<SdwanRouterPolicy> {
    	const result = this.api.patchSdwanRouterPolicy(moid, sdwanRouterPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdwan.VmanageAccountPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdwanVmanageAccountPolicy The &#39;sdwan.VmanageAccountPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSdwanVmanageAccountPolicy(moid: string, sdwanVmanageAccountPolicy: SdwanVmanageAccountPolicy, ifMatch?: string, options?: Configuration): Promise<SdwanVmanageAccountPolicy> {
    	const result = this.api.patchSdwanVmanageAccountPolicy(moid, sdwanVmanageAccountPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdwan.Profile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdwanProfile The &#39;sdwan.Profile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSdwanProfile(moid: string, sdwanProfile: SdwanProfile, ifMatch?: string, options?: Configuration): Promise<SdwanProfile> {
    	const result = this.api.updateSdwanProfile(moid, sdwanProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdwan.RouterNode' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdwanRouterNode The &#39;sdwan.RouterNode&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSdwanRouterNode(moid: string, sdwanRouterNode: SdwanRouterNode, ifMatch?: string, options?: Configuration): Promise<SdwanRouterNode> {
    	const result = this.api.updateSdwanRouterNode(moid, sdwanRouterNode, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdwan.RouterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdwanRouterPolicy The &#39;sdwan.RouterPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSdwanRouterPolicy(moid: string, sdwanRouterPolicy: SdwanRouterPolicy, ifMatch?: string, options?: Configuration): Promise<SdwanRouterPolicy> {
    	const result = this.api.updateSdwanRouterPolicy(moid, sdwanRouterPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sdwan.VmanageAccountPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sdwanVmanageAccountPolicy The &#39;sdwan.VmanageAccountPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSdwanVmanageAccountPolicy(moid: string, sdwanVmanageAccountPolicy: SdwanVmanageAccountPolicy, ifMatch?: string, options?: Configuration): Promise<SdwanVmanageAccountPolicy> {
    	const result = this.api.updateSdwanVmanageAccountPolicy(moid, sdwanVmanageAccountPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSearchApi } from './ObservableAPI';


import { SearchApiRequestFactory, SearchApiResponseProcessor} from "../apis/SearchApi";
export class PromiseSearchApi {
    private api: ObservableSearchApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SearchApiRequestFactory,
        responseProcessor?: SearchApiResponseProcessor
    ) {
        this.api = new ObservableSearchApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'search.SuggestItem' resource.
     * @param searchSuggestItem The &#39;search.SuggestItem&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSearchSuggestItem(searchSuggestItem: SearchSuggestItem, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SearchSuggestItem> {
    	const result = this.api.createSearchSuggestItem(searchSuggestItem, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'search.SearchItem' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSearchSearchItemByMoid(moid: string, options?: Configuration): Promise<SearchSearchItem> {
    	const result = this.api.getSearchSearchItemByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'search.SearchItem' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSearchSearchItemList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SearchSearchItemResponse> {
    	const result = this.api.getSearchSearchItemList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'search.TagItem' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSearchTagItemByMoid(moid: string, options?: Configuration): Promise<SearchTagItem> {
    	const result = this.api.getSearchTagItemByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'search.TagItem' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSearchTagItemList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SearchTagItemResponse> {
    	const result = this.api.getSearchTagItemList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableSecurityApi } from './ObservableAPI';


import { SecurityApiRequestFactory, SecurityApiResponseProcessor} from "../apis/SecurityApi";
export class PromiseSecurityApi {
    private api: ObservableSecurityApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SecurityApiRequestFactory,
        responseProcessor?: SecurityApiResponseProcessor
    ) {
        this.api = new ObservableSecurityApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'security.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSecurityUnitByMoid(moid: string, options?: Configuration): Promise<SecurityUnit> {
    	const result = this.api.getSecurityUnitByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'security.Unit' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSecurityUnitList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SecurityUnitResponse> {
    	const result = this.api.getSecurityUnitList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'security.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param securityUnit The &#39;security.Unit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSecurityUnit(moid: string, securityUnit: SecurityUnit, ifMatch?: string, options?: Configuration): Promise<SecurityUnit> {
    	const result = this.api.patchSecurityUnit(moid, securityUnit, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'security.Unit' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param securityUnit The &#39;security.Unit&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSecurityUnit(moid: string, securityUnit: SecurityUnit, ifMatch?: string, options?: Configuration): Promise<SecurityUnit> {
    	const result = this.api.updateSecurityUnit(moid, securityUnit, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableServerApi } from './ObservableAPI';


import { ServerApiRequestFactory, ServerApiResponseProcessor} from "../apis/ServerApi";
export class PromiseServerApi {
    private api: ObservableServerApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ServerApiRequestFactory,
        responseProcessor?: ServerApiResponseProcessor
    ) {
        this.api = new ObservableServerApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'server.ConfigImport' resource.
     * @param serverConfigImport The &#39;server.ConfigImport&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createServerConfigImport(serverConfigImport: ServerConfigImport, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ServerConfigImport> {
    	const result = this.api.createServerConfigImport(serverConfigImport, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'server.Profile' resource.
     * @param serverProfile The &#39;server.Profile&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createServerProfile(serverProfile: ServerProfile, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<ServerProfile> {
    	const result = this.api.createServerProfile(serverProfile, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'server.Profile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteServerProfile(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteServerProfile(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.ConfigChangeDetail' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getServerConfigChangeDetailByMoid(moid: string, options?: Configuration): Promise<ServerConfigChangeDetail> {
    	const result = this.api.getServerConfigChangeDetailByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.ConfigChangeDetail' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getServerConfigChangeDetailList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ServerConfigChangeDetailResponse> {
    	const result = this.api.getServerConfigChangeDetailList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.ConfigImport' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getServerConfigImportByMoid(moid: string, options?: Configuration): Promise<ServerConfigImport> {
    	const result = this.api.getServerConfigImportByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.ConfigImport' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getServerConfigImportList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ServerConfigImportResponse> {
    	const result = this.api.getServerConfigImportList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.ConfigResult' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getServerConfigResultByMoid(moid: string, options?: Configuration): Promise<ServerConfigResult> {
    	const result = this.api.getServerConfigResultByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.ConfigResultEntry' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getServerConfigResultEntryByMoid(moid: string, options?: Configuration): Promise<ServerConfigResultEntry> {
    	const result = this.api.getServerConfigResultEntryByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.ConfigResultEntry' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getServerConfigResultEntryList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ServerConfigResultEntryResponse> {
    	const result = this.api.getServerConfigResultEntryList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.ConfigResult' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getServerConfigResultList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ServerConfigResultResponse> {
    	const result = this.api.getServerConfigResultList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.Profile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getServerProfileByMoid(moid: string, options?: Configuration): Promise<ServerProfile> {
    	const result = this.api.getServerProfileByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'server.Profile' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getServerProfileList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<ServerProfileResponse> {
    	const result = this.api.getServerProfileList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'server.Profile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param serverProfile The &#39;server.Profile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchServerProfile(moid: string, serverProfile: ServerProfile, ifMatch?: string, options?: Configuration): Promise<ServerProfile> {
    	const result = this.api.patchServerProfile(moid, serverProfile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'server.Profile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param serverProfile The &#39;server.Profile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateServerProfile(moid: string, serverProfile: ServerProfile, ifMatch?: string, options?: Configuration): Promise<ServerProfile> {
    	const result = this.api.updateServerProfile(moid, serverProfile, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSmtpApi } from './ObservableAPI';


import { SmtpApiRequestFactory, SmtpApiResponseProcessor} from "../apis/SmtpApi";
export class PromiseSmtpApi {
    private api: ObservableSmtpApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SmtpApiRequestFactory,
        responseProcessor?: SmtpApiResponseProcessor
    ) {
        this.api = new ObservableSmtpApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'smtp.Policy' resource.
     * @param smtpPolicy The &#39;smtp.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSmtpPolicy(smtpPolicy: SmtpPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SmtpPolicy> {
    	const result = this.api.createSmtpPolicy(smtpPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'smtp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSmtpPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSmtpPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'smtp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSmtpPolicyByMoid(moid: string, options?: Configuration): Promise<SmtpPolicy> {
    	const result = this.api.getSmtpPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'smtp.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSmtpPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SmtpPolicyResponse> {
    	const result = this.api.getSmtpPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'smtp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param smtpPolicy The &#39;smtp.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSmtpPolicy(moid: string, smtpPolicy: SmtpPolicy, ifMatch?: string, options?: Configuration): Promise<SmtpPolicy> {
    	const result = this.api.patchSmtpPolicy(moid, smtpPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'smtp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param smtpPolicy The &#39;smtp.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSmtpPolicy(moid: string, smtpPolicy: SmtpPolicy, ifMatch?: string, options?: Configuration): Promise<SmtpPolicy> {
    	const result = this.api.updateSmtpPolicy(moid, smtpPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSnmpApi } from './ObservableAPI';


import { SnmpApiRequestFactory, SnmpApiResponseProcessor} from "../apis/SnmpApi";
export class PromiseSnmpApi {
    private api: ObservableSnmpApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SnmpApiRequestFactory,
        responseProcessor?: SnmpApiResponseProcessor
    ) {
        this.api = new ObservableSnmpApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'snmp.Policy' resource.
     * @param snmpPolicy The &#39;snmp.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSnmpPolicy(snmpPolicy: SnmpPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SnmpPolicy> {
    	const result = this.api.createSnmpPolicy(snmpPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'snmp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSnmpPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSnmpPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'snmp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSnmpPolicyByMoid(moid: string, options?: Configuration): Promise<SnmpPolicy> {
    	const result = this.api.getSnmpPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'snmp.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSnmpPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SnmpPolicyResponse> {
    	const result = this.api.getSnmpPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'snmp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param snmpPolicy The &#39;snmp.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSnmpPolicy(moid: string, snmpPolicy: SnmpPolicy, ifMatch?: string, options?: Configuration): Promise<SnmpPolicy> {
    	const result = this.api.patchSnmpPolicy(moid, snmpPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'snmp.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param snmpPolicy The &#39;snmp.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSnmpPolicy(moid: string, snmpPolicy: SnmpPolicy, ifMatch?: string, options?: Configuration): Promise<SnmpPolicy> {
    	const result = this.api.updateSnmpPolicy(moid, snmpPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSoftwareApi } from './ObservableAPI';


import { SoftwareApiRequestFactory, SoftwareApiResponseProcessor} from "../apis/SoftwareApi";
export class PromiseSoftwareApi {
    private api: ObservableSoftwareApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SoftwareApiRequestFactory,
        responseProcessor?: SoftwareApiResponseProcessor
    ) {
        this.api = new ObservableSoftwareApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'software.HclMeta' resource.
     * @param softwareHclMeta The &#39;software.HclMeta&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSoftwareHclMeta(softwareHclMeta: SoftwareHclMeta, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SoftwareHclMeta> {
    	const result = this.api.createSoftwareHclMeta(softwareHclMeta, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'software.HyperflexDistributable' resource.
     * @param softwareHyperflexDistributable The &#39;software.HyperflexDistributable&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSoftwareHyperflexDistributable(softwareHyperflexDistributable: SoftwareHyperflexDistributable, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SoftwareHyperflexDistributable> {
    	const result = this.api.createSoftwareHyperflexDistributable(softwareHyperflexDistributable, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'software.SolutionDistributable' resource.
     * @param softwareSolutionDistributable The &#39;software.SolutionDistributable&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSoftwareSolutionDistributable(softwareSolutionDistributable: SoftwareSolutionDistributable, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SoftwareSolutionDistributable> {
    	const result = this.api.createSoftwareSolutionDistributable(softwareSolutionDistributable, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'software.HclMeta' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSoftwareHclMeta(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSoftwareHclMeta(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'software.HyperflexDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSoftwareHyperflexDistributable(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSoftwareHyperflexDistributable(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'software.SolutionDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSoftwareSolutionDistributable(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSoftwareSolutionDistributable(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'software.HclMeta' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSoftwareHclMetaByMoid(moid: string, options?: Configuration): Promise<SoftwareHclMeta> {
    	const result = this.api.getSoftwareHclMetaByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'software.HclMeta' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSoftwareHclMetaList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SoftwareHclMetaResponse> {
    	const result = this.api.getSoftwareHclMetaList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'software.HyperflexDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSoftwareHyperflexDistributableByMoid(moid: string, options?: Configuration): Promise<SoftwareHyperflexDistributable> {
    	const result = this.api.getSoftwareHyperflexDistributableByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'software.HyperflexDistributable' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSoftwareHyperflexDistributableList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SoftwareHyperflexDistributableResponse> {
    	const result = this.api.getSoftwareHyperflexDistributableList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'software.SolutionDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSoftwareSolutionDistributableByMoid(moid: string, options?: Configuration): Promise<SoftwareSolutionDistributable> {
    	const result = this.api.getSoftwareSolutionDistributableByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'software.SolutionDistributable' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSoftwareSolutionDistributableList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SoftwareSolutionDistributableResponse> {
    	const result = this.api.getSoftwareSolutionDistributableList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'software.HclMeta' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwareHclMeta The &#39;software.HclMeta&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSoftwareHclMeta(moid: string, softwareHclMeta: SoftwareHclMeta, ifMatch?: string, options?: Configuration): Promise<SoftwareHclMeta> {
    	const result = this.api.patchSoftwareHclMeta(moid, softwareHclMeta, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'software.HyperflexDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwareHyperflexDistributable The &#39;software.HyperflexDistributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSoftwareHyperflexDistributable(moid: string, softwareHyperflexDistributable: SoftwareHyperflexDistributable, ifMatch?: string, options?: Configuration): Promise<SoftwareHyperflexDistributable> {
    	const result = this.api.patchSoftwareHyperflexDistributable(moid, softwareHyperflexDistributable, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'software.SolutionDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwareSolutionDistributable The &#39;software.SolutionDistributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSoftwareSolutionDistributable(moid: string, softwareSolutionDistributable: SoftwareSolutionDistributable, ifMatch?: string, options?: Configuration): Promise<SoftwareSolutionDistributable> {
    	const result = this.api.patchSoftwareSolutionDistributable(moid, softwareSolutionDistributable, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'software.HclMeta' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwareHclMeta The &#39;software.HclMeta&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSoftwareHclMeta(moid: string, softwareHclMeta: SoftwareHclMeta, ifMatch?: string, options?: Configuration): Promise<SoftwareHclMeta> {
    	const result = this.api.updateSoftwareHclMeta(moid, softwareHclMeta, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'software.HyperflexDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwareHyperflexDistributable The &#39;software.HyperflexDistributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSoftwareHyperflexDistributable(moid: string, softwareHyperflexDistributable: SoftwareHyperflexDistributable, ifMatch?: string, options?: Configuration): Promise<SoftwareHyperflexDistributable> {
    	const result = this.api.updateSoftwareHyperflexDistributable(moid, softwareHyperflexDistributable, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'software.SolutionDistributable' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwareSolutionDistributable The &#39;software.SolutionDistributable&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSoftwareSolutionDistributable(moid: string, softwareSolutionDistributable: SoftwareSolutionDistributable, ifMatch?: string, options?: Configuration): Promise<SoftwareSolutionDistributable> {
    	const result = this.api.updateSoftwareSolutionDistributable(moid, softwareSolutionDistributable, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSoftwarerepositoryApi } from './ObservableAPI';


import { SoftwarerepositoryApiRequestFactory, SoftwarerepositoryApiResponseProcessor} from "../apis/SoftwarerepositoryApi";
export class PromiseSoftwarerepositoryApi {
    private api: ObservableSoftwarerepositoryApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SoftwarerepositoryApiRequestFactory,
        responseProcessor?: SoftwarerepositoryApiResponseProcessor
    ) {
        this.api = new ObservableSoftwarerepositoryApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'softwarerepository.Authorization' resource.
     * @param softwarerepositoryAuthorization The &#39;softwarerepository.Authorization&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSoftwarerepositoryAuthorization(softwarerepositoryAuthorization: SoftwarerepositoryAuthorization, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SoftwarerepositoryAuthorization> {
    	const result = this.api.createSoftwarerepositoryAuthorization(softwarerepositoryAuthorization, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'softwarerepository.OperatingSystemFile' resource.
     * @param softwarerepositoryOperatingSystemFile The &#39;softwarerepository.OperatingSystemFile&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSoftwarerepositoryOperatingSystemFile(softwarerepositoryOperatingSystemFile: SoftwarerepositoryOperatingSystemFile, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SoftwarerepositoryOperatingSystemFile> {
    	const result = this.api.createSoftwarerepositoryOperatingSystemFile(softwarerepositoryOperatingSystemFile, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'softwarerepository.OperatingSystemFile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSoftwarerepositoryOperatingSystemFile(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSoftwarerepositoryOperatingSystemFile(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'softwarerepository.Authorization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSoftwarerepositoryAuthorizationByMoid(moid: string, options?: Configuration): Promise<SoftwarerepositoryAuthorization> {
    	const result = this.api.getSoftwarerepositoryAuthorizationByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'softwarerepository.Authorization' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSoftwarerepositoryAuthorizationList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SoftwarerepositoryAuthorizationResponse> {
    	const result = this.api.getSoftwarerepositoryAuthorizationList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'softwarerepository.Catalog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSoftwarerepositoryCatalogByMoid(moid: string, options?: Configuration): Promise<SoftwarerepositoryCatalog> {
    	const result = this.api.getSoftwarerepositoryCatalogByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'softwarerepository.Catalog' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSoftwarerepositoryCatalogList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SoftwarerepositoryCatalogResponse> {
    	const result = this.api.getSoftwarerepositoryCatalogList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'softwarerepository.OperatingSystemFile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSoftwarerepositoryOperatingSystemFileByMoid(moid: string, options?: Configuration): Promise<SoftwarerepositoryOperatingSystemFile> {
    	const result = this.api.getSoftwarerepositoryOperatingSystemFileByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'softwarerepository.OperatingSystemFile' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSoftwarerepositoryOperatingSystemFileList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SoftwarerepositoryOperatingSystemFileResponse> {
    	const result = this.api.getSoftwarerepositoryOperatingSystemFileList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'softwarerepository.Authorization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwarerepositoryAuthorization The &#39;softwarerepository.Authorization&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSoftwarerepositoryAuthorization(moid: string, softwarerepositoryAuthorization: SoftwarerepositoryAuthorization, ifMatch?: string, options?: Configuration): Promise<SoftwarerepositoryAuthorization> {
    	const result = this.api.patchSoftwarerepositoryAuthorization(moid, softwarerepositoryAuthorization, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'softwarerepository.OperatingSystemFile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwarerepositoryOperatingSystemFile The &#39;softwarerepository.OperatingSystemFile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSoftwarerepositoryOperatingSystemFile(moid: string, softwarerepositoryOperatingSystemFile: SoftwarerepositoryOperatingSystemFile, ifMatch?: string, options?: Configuration): Promise<SoftwarerepositoryOperatingSystemFile> {
    	const result = this.api.patchSoftwarerepositoryOperatingSystemFile(moid, softwarerepositoryOperatingSystemFile, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'softwarerepository.Authorization' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwarerepositoryAuthorization The &#39;softwarerepository.Authorization&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSoftwarerepositoryAuthorization(moid: string, softwarerepositoryAuthorization: SoftwarerepositoryAuthorization, ifMatch?: string, options?: Configuration): Promise<SoftwarerepositoryAuthorization> {
    	const result = this.api.updateSoftwarerepositoryAuthorization(moid, softwarerepositoryAuthorization, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'softwarerepository.OperatingSystemFile' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param softwarerepositoryOperatingSystemFile The &#39;softwarerepository.OperatingSystemFile&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSoftwarerepositoryOperatingSystemFile(moid: string, softwarerepositoryOperatingSystemFile: SoftwarerepositoryOperatingSystemFile, ifMatch?: string, options?: Configuration): Promise<SoftwarerepositoryOperatingSystemFile> {
    	const result = this.api.updateSoftwarerepositoryOperatingSystemFile(moid, softwarerepositoryOperatingSystemFile, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSolApi } from './ObservableAPI';


import { SolApiRequestFactory, SolApiResponseProcessor} from "../apis/SolApi";
export class PromiseSolApi {
    private api: ObservableSolApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SolApiRequestFactory,
        responseProcessor?: SolApiResponseProcessor
    ) {
        this.api = new ObservableSolApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'sol.Policy' resource.
     * @param solPolicy The &#39;sol.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSolPolicy(solPolicy: SolPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SolPolicy> {
    	const result = this.api.createSolPolicy(solPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'sol.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSolPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSolPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sol.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSolPolicyByMoid(moid: string, options?: Configuration): Promise<SolPolicy> {
    	const result = this.api.getSolPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'sol.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSolPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SolPolicyResponse> {
    	const result = this.api.getSolPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sol.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param solPolicy The &#39;sol.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSolPolicy(moid: string, solPolicy: SolPolicy, ifMatch?: string, options?: Configuration): Promise<SolPolicy> {
    	const result = this.api.patchSolPolicy(moid, solPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'sol.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param solPolicy The &#39;sol.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSolPolicy(moid: string, solPolicy: SolPolicy, ifMatch?: string, options?: Configuration): Promise<SolPolicy> {
    	const result = this.api.updateSolPolicy(moid, solPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSshApi } from './ObservableAPI';


import { SshApiRequestFactory, SshApiResponseProcessor} from "../apis/SshApi";
export class PromiseSshApi {
    private api: ObservableSshApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SshApiRequestFactory,
        responseProcessor?: SshApiResponseProcessor
    ) {
        this.api = new ObservableSshApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'ssh.Policy' resource.
     * @param sshPolicy The &#39;ssh.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSshPolicy(sshPolicy: SshPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SshPolicy> {
    	const result = this.api.createSshPolicy(sshPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'ssh.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSshPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSshPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ssh.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSshPolicyByMoid(moid: string, options?: Configuration): Promise<SshPolicy> {
    	const result = this.api.getSshPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ssh.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSshPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SshPolicyResponse> {
    	const result = this.api.getSshPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ssh.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sshPolicy The &#39;ssh.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSshPolicy(moid: string, sshPolicy: SshPolicy, ifMatch?: string, options?: Configuration): Promise<SshPolicy> {
    	const result = this.api.patchSshPolicy(moid, sshPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'ssh.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param sshPolicy The &#39;ssh.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSshPolicy(moid: string, sshPolicy: SshPolicy, ifMatch?: string, options?: Configuration): Promise<SshPolicy> {
    	const result = this.api.updateSshPolicy(moid, sshPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableStorageApi } from './ObservableAPI';


import { StorageApiRequestFactory, StorageApiResponseProcessor} from "../apis/StorageApi";
export class PromiseStorageApi {
    private api: ObservableStorageApi

    public constructor(
        configuration: Configuration,
        requestFactory?: StorageApiRequestFactory,
        responseProcessor?: StorageApiResponseProcessor
    ) {
        this.api = new ObservableStorageApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'storage.DiskGroupPolicy' resource.
     * @param storageDiskGroupPolicy The &#39;storage.DiskGroupPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createStorageDiskGroupPolicy(storageDiskGroupPolicy: StorageDiskGroupPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<StorageDiskGroupPolicy> {
    	const result = this.api.createStorageDiskGroupPolicy(storageDiskGroupPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'storage.StoragePolicy' resource.
     * @param storageStoragePolicy The &#39;storage.StoragePolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createStorageStoragePolicy(storageStoragePolicy: StorageStoragePolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<StorageStoragePolicy> {
    	const result = this.api.createStorageStoragePolicy(storageStoragePolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'storage.DiskGroupPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteStorageDiskGroupPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteStorageDiskGroupPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'storage.StoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteStorageStoragePolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteStorageStoragePolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.Controller' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageControllerByMoid(moid: string, options?: Configuration): Promise<StorageController> {
    	const result = this.api.getStorageControllerByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.Controller' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageControllerList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageControllerResponse> {
    	const result = this.api.getStorageControllerList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.DiskGroupPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageDiskGroupPolicyByMoid(moid: string, options?: Configuration): Promise<StorageDiskGroupPolicy> {
    	const result = this.api.getStorageDiskGroupPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.DiskGroupPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageDiskGroupPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageDiskGroupPolicyResponse> {
    	const result = this.api.getStorageDiskGroupPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.Enclosure' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageEnclosureByMoid(moid: string, options?: Configuration): Promise<StorageEnclosure> {
    	const result = this.api.getStorageEnclosureByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.EnclosureDisk' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageEnclosureDiskByMoid(moid: string, options?: Configuration): Promise<StorageEnclosureDisk> {
    	const result = this.api.getStorageEnclosureDiskByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.EnclosureDisk' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageEnclosureDiskList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageEnclosureDiskResponse> {
    	const result = this.api.getStorageEnclosureDiskList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.EnclosureDiskSlotEp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageEnclosureDiskSlotEpByMoid(moid: string, options?: Configuration): Promise<StorageEnclosureDiskSlotEp> {
    	const result = this.api.getStorageEnclosureDiskSlotEpByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.EnclosureDiskSlotEp' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageEnclosureDiskSlotEpList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageEnclosureDiskSlotEpResponse> {
    	const result = this.api.getStorageEnclosureDiskSlotEpList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.Enclosure' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageEnclosureList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageEnclosureResponse> {
    	const result = this.api.getStorageEnclosureList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexFlashController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageFlexFlashControllerByMoid(moid: string, options?: Configuration): Promise<StorageFlexFlashController> {
    	const result = this.api.getStorageFlexFlashControllerByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexFlashController' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageFlexFlashControllerList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageFlexFlashControllerResponse> {
    	const result = this.api.getStorageFlexFlashControllerList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexFlashControllerProps' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageFlexFlashControllerPropsByMoid(moid: string, options?: Configuration): Promise<StorageFlexFlashControllerProps> {
    	const result = this.api.getStorageFlexFlashControllerPropsByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexFlashControllerProps' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageFlexFlashControllerPropsList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageFlexFlashControllerPropsResponse> {
    	const result = this.api.getStorageFlexFlashControllerPropsList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexFlashPhysicalDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageFlexFlashPhysicalDriveByMoid(moid: string, options?: Configuration): Promise<StorageFlexFlashPhysicalDrive> {
    	const result = this.api.getStorageFlexFlashPhysicalDriveByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexFlashPhysicalDrive' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageFlexFlashPhysicalDriveList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageFlexFlashPhysicalDriveResponse> {
    	const result = this.api.getStorageFlexFlashPhysicalDriveList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexFlashVirtualDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageFlexFlashVirtualDriveByMoid(moid: string, options?: Configuration): Promise<StorageFlexFlashVirtualDrive> {
    	const result = this.api.getStorageFlexFlashVirtualDriveByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexFlashVirtualDrive' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageFlexFlashVirtualDriveList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageFlexFlashVirtualDriveResponse> {
    	const result = this.api.getStorageFlexFlashVirtualDriveList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexUtilController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageFlexUtilControllerByMoid(moid: string, options?: Configuration): Promise<StorageFlexUtilController> {
    	const result = this.api.getStorageFlexUtilControllerByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexUtilController' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageFlexUtilControllerList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageFlexUtilControllerResponse> {
    	const result = this.api.getStorageFlexUtilControllerList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexUtilPhysicalDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageFlexUtilPhysicalDriveByMoid(moid: string, options?: Configuration): Promise<StorageFlexUtilPhysicalDrive> {
    	const result = this.api.getStorageFlexUtilPhysicalDriveByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexUtilPhysicalDrive' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageFlexUtilPhysicalDriveList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageFlexUtilPhysicalDriveResponse> {
    	const result = this.api.getStorageFlexUtilPhysicalDriveList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexUtilVirtualDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageFlexUtilVirtualDriveByMoid(moid: string, options?: Configuration): Promise<StorageFlexUtilVirtualDrive> {
    	const result = this.api.getStorageFlexUtilVirtualDriveByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.FlexUtilVirtualDrive' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageFlexUtilVirtualDriveList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageFlexUtilVirtualDriveResponse> {
    	const result = this.api.getStorageFlexUtilVirtualDriveList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PhysicalDisk' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePhysicalDiskByMoid(moid: string, options?: Configuration): Promise<StoragePhysicalDisk> {
    	const result = this.api.getStoragePhysicalDiskByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PhysicalDiskExtension' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePhysicalDiskExtensionByMoid(moid: string, options?: Configuration): Promise<StoragePhysicalDiskExtension> {
    	const result = this.api.getStoragePhysicalDiskExtensionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PhysicalDiskExtension' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePhysicalDiskExtensionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePhysicalDiskExtensionResponse> {
    	const result = this.api.getStoragePhysicalDiskExtensionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PhysicalDisk' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePhysicalDiskList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePhysicalDiskResponse> {
    	const result = this.api.getStoragePhysicalDiskList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PhysicalDiskUsage' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePhysicalDiskUsageByMoid(moid: string, options?: Configuration): Promise<StoragePhysicalDiskUsage> {
    	const result = this.api.getStoragePhysicalDiskUsageByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PhysicalDiskUsage' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePhysicalDiskUsageList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePhysicalDiskUsageResponse> {
    	const result = this.api.getStoragePhysicalDiskUsageList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureArray' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureArrayByMoid(moid: string, options?: Configuration): Promise<StoragePureArray> {
    	const result = this.api.getStoragePureArrayByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureArray' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureArrayList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureArrayResponse> {
    	const result = this.api.getStoragePureArrayList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureControllerByMoid(moid: string, options?: Configuration): Promise<StoragePureController> {
    	const result = this.api.getStoragePureControllerByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureController' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureControllerList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureControllerResponse> {
    	const result = this.api.getStoragePureControllerList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureDisk' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureDiskByMoid(moid: string, options?: Configuration): Promise<StoragePureDisk> {
    	const result = this.api.getStoragePureDiskByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureDisk' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureDiskList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureDiskResponse> {
    	const result = this.api.getStoragePureDiskList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureHost' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureHostByMoid(moid: string, options?: Configuration): Promise<StoragePureHost> {
    	const result = this.api.getStoragePureHostByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureHostGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureHostGroupByMoid(moid: string, options?: Configuration): Promise<StoragePureHostGroup> {
    	const result = this.api.getStoragePureHostGroupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureHostGroup' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureHostGroupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureHostGroupResponse> {
    	const result = this.api.getStoragePureHostGroupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureHost' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureHostList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureHostResponse> {
    	const result = this.api.getStoragePureHostList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureHostLun' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureHostLunByMoid(moid: string, options?: Configuration): Promise<StoragePureHostLun> {
    	const result = this.api.getStoragePureHostLunByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureHostLun' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureHostLunList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureHostLunResponse> {
    	const result = this.api.getStoragePureHostLunList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PurePort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePurePortByMoid(moid: string, options?: Configuration): Promise<StoragePurePort> {
    	const result = this.api.getStoragePurePortByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PurePort' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePurePortList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePurePortResponse> {
    	const result = this.api.getStoragePurePortList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureProtectionGroup' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureProtectionGroupByMoid(moid: string, options?: Configuration): Promise<StoragePureProtectionGroup> {
    	const result = this.api.getStoragePureProtectionGroupByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureProtectionGroup' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureProtectionGroupList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureProtectionGroupResponse> {
    	const result = this.api.getStoragePureProtectionGroupList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureProtectionGroupSnapshot' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureProtectionGroupSnapshotByMoid(moid: string, options?: Configuration): Promise<StoragePureProtectionGroupSnapshot> {
    	const result = this.api.getStoragePureProtectionGroupSnapshotByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureProtectionGroupSnapshot' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureProtectionGroupSnapshotList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureProtectionGroupSnapshotResponse> {
    	const result = this.api.getStoragePureProtectionGroupSnapshotList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureReplicationSchedule' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureReplicationScheduleByMoid(moid: string, options?: Configuration): Promise<StoragePureReplicationSchedule> {
    	const result = this.api.getStoragePureReplicationScheduleByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureReplicationSchedule' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureReplicationScheduleList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureReplicationScheduleResponse> {
    	const result = this.api.getStoragePureReplicationScheduleList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureSnapshotSchedule' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureSnapshotScheduleByMoid(moid: string, options?: Configuration): Promise<StoragePureSnapshotSchedule> {
    	const result = this.api.getStoragePureSnapshotScheduleByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureSnapshotSchedule' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureSnapshotScheduleList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureSnapshotScheduleResponse> {
    	const result = this.api.getStoragePureSnapshotScheduleList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureVolume' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureVolumeByMoid(moid: string, options?: Configuration): Promise<StoragePureVolume> {
    	const result = this.api.getStoragePureVolumeByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureVolume' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureVolumeList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureVolumeResponse> {
    	const result = this.api.getStoragePureVolumeList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureVolumeSnapshot' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStoragePureVolumeSnapshotByMoid(moid: string, options?: Configuration): Promise<StoragePureVolumeSnapshot> {
    	const result = this.api.getStoragePureVolumeSnapshotByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.PureVolumeSnapshot' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStoragePureVolumeSnapshotList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StoragePureVolumeSnapshotResponse> {
    	const result = this.api.getStoragePureVolumeSnapshotList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.SasExpander' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageSasExpanderByMoid(moid: string, options?: Configuration): Promise<StorageSasExpander> {
    	const result = this.api.getStorageSasExpanderByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.SasExpander' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageSasExpanderList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageSasExpanderResponse> {
    	const result = this.api.getStorageSasExpanderList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.SasPort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageSasPortByMoid(moid: string, options?: Configuration): Promise<StorageSasPort> {
    	const result = this.api.getStorageSasPortByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.SasPort' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageSasPortList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageSasPortResponse> {
    	const result = this.api.getStorageSasPortList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.StoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageStoragePolicyByMoid(moid: string, options?: Configuration): Promise<StorageStoragePolicy> {
    	const result = this.api.getStorageStoragePolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.StoragePolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageStoragePolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageStoragePolicyResponse> {
    	const result = this.api.getStorageStoragePolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.VdMemberEp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageVdMemberEpByMoid(moid: string, options?: Configuration): Promise<StorageVdMemberEp> {
    	const result = this.api.getStorageVdMemberEpByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.VdMemberEp' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageVdMemberEpList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageVdMemberEpResponse> {
    	const result = this.api.getStorageVdMemberEpList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.VirtualDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageVirtualDriveByMoid(moid: string, options?: Configuration): Promise<StorageVirtualDrive> {
    	const result = this.api.getStorageVirtualDriveByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.VirtualDriveExtension' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getStorageVirtualDriveExtensionByMoid(moid: string, options?: Configuration): Promise<StorageVirtualDriveExtension> {
    	const result = this.api.getStorageVirtualDriveExtensionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.VirtualDriveExtension' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageVirtualDriveExtensionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageVirtualDriveExtensionResponse> {
    	const result = this.api.getStorageVirtualDriveExtensionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'storage.VirtualDrive' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getStorageVirtualDriveList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<StorageVirtualDriveResponse> {
    	const result = this.api.getStorageVirtualDriveList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.Controller' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageController The &#39;storage.Controller&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageController(moid: string, storageController: StorageController, ifMatch?: string, options?: Configuration): Promise<StorageController> {
    	const result = this.api.patchStorageController(moid, storageController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.DiskGroupPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageDiskGroupPolicy The &#39;storage.DiskGroupPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageDiskGroupPolicy(moid: string, storageDiskGroupPolicy: StorageDiskGroupPolicy, ifMatch?: string, options?: Configuration): Promise<StorageDiskGroupPolicy> {
    	const result = this.api.patchStorageDiskGroupPolicy(moid, storageDiskGroupPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.Enclosure' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageEnclosure The &#39;storage.Enclosure&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageEnclosure(moid: string, storageEnclosure: StorageEnclosure, ifMatch?: string, options?: Configuration): Promise<StorageEnclosure> {
    	const result = this.api.patchStorageEnclosure(moid, storageEnclosure, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.EnclosureDisk' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageEnclosureDisk The &#39;storage.EnclosureDisk&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageEnclosureDisk(moid: string, storageEnclosureDisk: StorageEnclosureDisk, ifMatch?: string, options?: Configuration): Promise<StorageEnclosureDisk> {
    	const result = this.api.patchStorageEnclosureDisk(moid, storageEnclosureDisk, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.EnclosureDiskSlotEp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageEnclosureDiskSlotEp The &#39;storage.EnclosureDiskSlotEp&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageEnclosureDiskSlotEp(moid: string, storageEnclosureDiskSlotEp: StorageEnclosureDiskSlotEp, ifMatch?: string, options?: Configuration): Promise<StorageEnclosureDiskSlotEp> {
    	const result = this.api.patchStorageEnclosureDiskSlotEp(moid, storageEnclosureDiskSlotEp, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexFlashController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexFlashController The &#39;storage.FlexFlashController&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageFlexFlashController(moid: string, storageFlexFlashController: StorageFlexFlashController, ifMatch?: string, options?: Configuration): Promise<StorageFlexFlashController> {
    	const result = this.api.patchStorageFlexFlashController(moid, storageFlexFlashController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexFlashControllerProps' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexFlashControllerProps The &#39;storage.FlexFlashControllerProps&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageFlexFlashControllerProps(moid: string, storageFlexFlashControllerProps: StorageFlexFlashControllerProps, ifMatch?: string, options?: Configuration): Promise<StorageFlexFlashControllerProps> {
    	const result = this.api.patchStorageFlexFlashControllerProps(moid, storageFlexFlashControllerProps, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexFlashPhysicalDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexFlashPhysicalDrive The &#39;storage.FlexFlashPhysicalDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageFlexFlashPhysicalDrive(moid: string, storageFlexFlashPhysicalDrive: StorageFlexFlashPhysicalDrive, ifMatch?: string, options?: Configuration): Promise<StorageFlexFlashPhysicalDrive> {
    	const result = this.api.patchStorageFlexFlashPhysicalDrive(moid, storageFlexFlashPhysicalDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexFlashVirtualDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexFlashVirtualDrive The &#39;storage.FlexFlashVirtualDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageFlexFlashVirtualDrive(moid: string, storageFlexFlashVirtualDrive: StorageFlexFlashVirtualDrive, ifMatch?: string, options?: Configuration): Promise<StorageFlexFlashVirtualDrive> {
    	const result = this.api.patchStorageFlexFlashVirtualDrive(moid, storageFlexFlashVirtualDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexUtilController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexUtilController The &#39;storage.FlexUtilController&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageFlexUtilController(moid: string, storageFlexUtilController: StorageFlexUtilController, ifMatch?: string, options?: Configuration): Promise<StorageFlexUtilController> {
    	const result = this.api.patchStorageFlexUtilController(moid, storageFlexUtilController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexUtilPhysicalDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexUtilPhysicalDrive The &#39;storage.FlexUtilPhysicalDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageFlexUtilPhysicalDrive(moid: string, storageFlexUtilPhysicalDrive: StorageFlexUtilPhysicalDrive, ifMatch?: string, options?: Configuration): Promise<StorageFlexUtilPhysicalDrive> {
    	const result = this.api.patchStorageFlexUtilPhysicalDrive(moid, storageFlexUtilPhysicalDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexUtilVirtualDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexUtilVirtualDrive The &#39;storage.FlexUtilVirtualDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageFlexUtilVirtualDrive(moid: string, storageFlexUtilVirtualDrive: StorageFlexUtilVirtualDrive, ifMatch?: string, options?: Configuration): Promise<StorageFlexUtilVirtualDrive> {
    	const result = this.api.patchStorageFlexUtilVirtualDrive(moid, storageFlexUtilVirtualDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.PhysicalDisk' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storagePhysicalDisk The &#39;storage.PhysicalDisk&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStoragePhysicalDisk(moid: string, storagePhysicalDisk: StoragePhysicalDisk, ifMatch?: string, options?: Configuration): Promise<StoragePhysicalDisk> {
    	const result = this.api.patchStoragePhysicalDisk(moid, storagePhysicalDisk, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.PhysicalDiskExtension' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storagePhysicalDiskExtension The &#39;storage.PhysicalDiskExtension&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStoragePhysicalDiskExtension(moid: string, storagePhysicalDiskExtension: StoragePhysicalDiskExtension, ifMatch?: string, options?: Configuration): Promise<StoragePhysicalDiskExtension> {
    	const result = this.api.patchStoragePhysicalDiskExtension(moid, storagePhysicalDiskExtension, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.PhysicalDiskUsage' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storagePhysicalDiskUsage The &#39;storage.PhysicalDiskUsage&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStoragePhysicalDiskUsage(moid: string, storagePhysicalDiskUsage: StoragePhysicalDiskUsage, ifMatch?: string, options?: Configuration): Promise<StoragePhysicalDiskUsage> {
    	const result = this.api.patchStoragePhysicalDiskUsage(moid, storagePhysicalDiskUsage, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.PureArray' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storagePureArray The &#39;storage.PureArray&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStoragePureArray(moid: string, storagePureArray: StoragePureArray, ifMatch?: string, options?: Configuration): Promise<StoragePureArray> {
    	const result = this.api.patchStoragePureArray(moid, storagePureArray, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.SasExpander' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageSasExpander The &#39;storage.SasExpander&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageSasExpander(moid: string, storageSasExpander: StorageSasExpander, ifMatch?: string, options?: Configuration): Promise<StorageSasExpander> {
    	const result = this.api.patchStorageSasExpander(moid, storageSasExpander, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.SasPort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageSasPort The &#39;storage.SasPort&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageSasPort(moid: string, storageSasPort: StorageSasPort, ifMatch?: string, options?: Configuration): Promise<StorageSasPort> {
    	const result = this.api.patchStorageSasPort(moid, storageSasPort, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.StoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageStoragePolicy The &#39;storage.StoragePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageStoragePolicy(moid: string, storageStoragePolicy: StorageStoragePolicy, ifMatch?: string, options?: Configuration): Promise<StorageStoragePolicy> {
    	const result = this.api.patchStorageStoragePolicy(moid, storageStoragePolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.VdMemberEp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageVdMemberEp The &#39;storage.VdMemberEp&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageVdMemberEp(moid: string, storageVdMemberEp: StorageVdMemberEp, ifMatch?: string, options?: Configuration): Promise<StorageVdMemberEp> {
    	const result = this.api.patchStorageVdMemberEp(moid, storageVdMemberEp, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.VirtualDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageVirtualDrive The &#39;storage.VirtualDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageVirtualDrive(moid: string, storageVirtualDrive: StorageVirtualDrive, ifMatch?: string, options?: Configuration): Promise<StorageVirtualDrive> {
    	const result = this.api.patchStorageVirtualDrive(moid, storageVirtualDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.VirtualDriveExtension' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageVirtualDriveExtension The &#39;storage.VirtualDriveExtension&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchStorageVirtualDriveExtension(moid: string, storageVirtualDriveExtension: StorageVirtualDriveExtension, ifMatch?: string, options?: Configuration): Promise<StorageVirtualDriveExtension> {
    	const result = this.api.patchStorageVirtualDriveExtension(moid, storageVirtualDriveExtension, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.Controller' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageController The &#39;storage.Controller&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageController(moid: string, storageController: StorageController, ifMatch?: string, options?: Configuration): Promise<StorageController> {
    	const result = this.api.updateStorageController(moid, storageController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.DiskGroupPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageDiskGroupPolicy The &#39;storage.DiskGroupPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageDiskGroupPolicy(moid: string, storageDiskGroupPolicy: StorageDiskGroupPolicy, ifMatch?: string, options?: Configuration): Promise<StorageDiskGroupPolicy> {
    	const result = this.api.updateStorageDiskGroupPolicy(moid, storageDiskGroupPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.Enclosure' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageEnclosure The &#39;storage.Enclosure&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageEnclosure(moid: string, storageEnclosure: StorageEnclosure, ifMatch?: string, options?: Configuration): Promise<StorageEnclosure> {
    	const result = this.api.updateStorageEnclosure(moid, storageEnclosure, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.EnclosureDisk' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageEnclosureDisk The &#39;storage.EnclosureDisk&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageEnclosureDisk(moid: string, storageEnclosureDisk: StorageEnclosureDisk, ifMatch?: string, options?: Configuration): Promise<StorageEnclosureDisk> {
    	const result = this.api.updateStorageEnclosureDisk(moid, storageEnclosureDisk, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.EnclosureDiskSlotEp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageEnclosureDiskSlotEp The &#39;storage.EnclosureDiskSlotEp&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageEnclosureDiskSlotEp(moid: string, storageEnclosureDiskSlotEp: StorageEnclosureDiskSlotEp, ifMatch?: string, options?: Configuration): Promise<StorageEnclosureDiskSlotEp> {
    	const result = this.api.updateStorageEnclosureDiskSlotEp(moid, storageEnclosureDiskSlotEp, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexFlashController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexFlashController The &#39;storage.FlexFlashController&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageFlexFlashController(moid: string, storageFlexFlashController: StorageFlexFlashController, ifMatch?: string, options?: Configuration): Promise<StorageFlexFlashController> {
    	const result = this.api.updateStorageFlexFlashController(moid, storageFlexFlashController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexFlashControllerProps' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexFlashControllerProps The &#39;storage.FlexFlashControllerProps&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageFlexFlashControllerProps(moid: string, storageFlexFlashControllerProps: StorageFlexFlashControllerProps, ifMatch?: string, options?: Configuration): Promise<StorageFlexFlashControllerProps> {
    	const result = this.api.updateStorageFlexFlashControllerProps(moid, storageFlexFlashControllerProps, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexFlashPhysicalDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexFlashPhysicalDrive The &#39;storage.FlexFlashPhysicalDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageFlexFlashPhysicalDrive(moid: string, storageFlexFlashPhysicalDrive: StorageFlexFlashPhysicalDrive, ifMatch?: string, options?: Configuration): Promise<StorageFlexFlashPhysicalDrive> {
    	const result = this.api.updateStorageFlexFlashPhysicalDrive(moid, storageFlexFlashPhysicalDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexFlashVirtualDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexFlashVirtualDrive The &#39;storage.FlexFlashVirtualDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageFlexFlashVirtualDrive(moid: string, storageFlexFlashVirtualDrive: StorageFlexFlashVirtualDrive, ifMatch?: string, options?: Configuration): Promise<StorageFlexFlashVirtualDrive> {
    	const result = this.api.updateStorageFlexFlashVirtualDrive(moid, storageFlexFlashVirtualDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexUtilController' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexUtilController The &#39;storage.FlexUtilController&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageFlexUtilController(moid: string, storageFlexUtilController: StorageFlexUtilController, ifMatch?: string, options?: Configuration): Promise<StorageFlexUtilController> {
    	const result = this.api.updateStorageFlexUtilController(moid, storageFlexUtilController, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexUtilPhysicalDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexUtilPhysicalDrive The &#39;storage.FlexUtilPhysicalDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageFlexUtilPhysicalDrive(moid: string, storageFlexUtilPhysicalDrive: StorageFlexUtilPhysicalDrive, ifMatch?: string, options?: Configuration): Promise<StorageFlexUtilPhysicalDrive> {
    	const result = this.api.updateStorageFlexUtilPhysicalDrive(moid, storageFlexUtilPhysicalDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.FlexUtilVirtualDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageFlexUtilVirtualDrive The &#39;storage.FlexUtilVirtualDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageFlexUtilVirtualDrive(moid: string, storageFlexUtilVirtualDrive: StorageFlexUtilVirtualDrive, ifMatch?: string, options?: Configuration): Promise<StorageFlexUtilVirtualDrive> {
    	const result = this.api.updateStorageFlexUtilVirtualDrive(moid, storageFlexUtilVirtualDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.PhysicalDisk' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storagePhysicalDisk The &#39;storage.PhysicalDisk&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStoragePhysicalDisk(moid: string, storagePhysicalDisk: StoragePhysicalDisk, ifMatch?: string, options?: Configuration): Promise<StoragePhysicalDisk> {
    	const result = this.api.updateStoragePhysicalDisk(moid, storagePhysicalDisk, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.PhysicalDiskExtension' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storagePhysicalDiskExtension The &#39;storage.PhysicalDiskExtension&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStoragePhysicalDiskExtension(moid: string, storagePhysicalDiskExtension: StoragePhysicalDiskExtension, ifMatch?: string, options?: Configuration): Promise<StoragePhysicalDiskExtension> {
    	const result = this.api.updateStoragePhysicalDiskExtension(moid, storagePhysicalDiskExtension, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.PhysicalDiskUsage' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storagePhysicalDiskUsage The &#39;storage.PhysicalDiskUsage&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStoragePhysicalDiskUsage(moid: string, storagePhysicalDiskUsage: StoragePhysicalDiskUsage, ifMatch?: string, options?: Configuration): Promise<StoragePhysicalDiskUsage> {
    	const result = this.api.updateStoragePhysicalDiskUsage(moid, storagePhysicalDiskUsage, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.PureArray' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storagePureArray The &#39;storage.PureArray&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStoragePureArray(moid: string, storagePureArray: StoragePureArray, ifMatch?: string, options?: Configuration): Promise<StoragePureArray> {
    	const result = this.api.updateStoragePureArray(moid, storagePureArray, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.SasExpander' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageSasExpander The &#39;storage.SasExpander&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageSasExpander(moid: string, storageSasExpander: StorageSasExpander, ifMatch?: string, options?: Configuration): Promise<StorageSasExpander> {
    	const result = this.api.updateStorageSasExpander(moid, storageSasExpander, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.SasPort' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageSasPort The &#39;storage.SasPort&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageSasPort(moid: string, storageSasPort: StorageSasPort, ifMatch?: string, options?: Configuration): Promise<StorageSasPort> {
    	const result = this.api.updateStorageSasPort(moid, storageSasPort, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.StoragePolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageStoragePolicy The &#39;storage.StoragePolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageStoragePolicy(moid: string, storageStoragePolicy: StorageStoragePolicy, ifMatch?: string, options?: Configuration): Promise<StorageStoragePolicy> {
    	const result = this.api.updateStorageStoragePolicy(moid, storageStoragePolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.VdMemberEp' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageVdMemberEp The &#39;storage.VdMemberEp&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageVdMemberEp(moid: string, storageVdMemberEp: StorageVdMemberEp, ifMatch?: string, options?: Configuration): Promise<StorageVdMemberEp> {
    	const result = this.api.updateStorageVdMemberEp(moid, storageVdMemberEp, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.VirtualDrive' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageVirtualDrive The &#39;storage.VirtualDrive&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageVirtualDrive(moid: string, storageVirtualDrive: StorageVirtualDrive, ifMatch?: string, options?: Configuration): Promise<StorageVirtualDrive> {
    	const result = this.api.updateStorageVirtualDrive(moid, storageVirtualDrive, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'storage.VirtualDriveExtension' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param storageVirtualDriveExtension The &#39;storage.VirtualDriveExtension&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateStorageVirtualDriveExtension(moid: string, storageVirtualDriveExtension: StorageVirtualDriveExtension, ifMatch?: string, options?: Configuration): Promise<StorageVirtualDriveExtension> {
    	const result = this.api.updateStorageVirtualDriveExtension(moid, storageVirtualDriveExtension, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableSyslogApi } from './ObservableAPI';


import { SyslogApiRequestFactory, SyslogApiResponseProcessor} from "../apis/SyslogApi";
export class PromiseSyslogApi {
    private api: ObservableSyslogApi

    public constructor(
        configuration: Configuration,
        requestFactory?: SyslogApiRequestFactory,
        responseProcessor?: SyslogApiResponseProcessor
    ) {
        this.api = new ObservableSyslogApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'syslog.Policy' resource.
     * @param syslogPolicy The &#39;syslog.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createSyslogPolicy(syslogPolicy: SyslogPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<SyslogPolicy> {
    	const result = this.api.createSyslogPolicy(syslogPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'syslog.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteSyslogPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteSyslogPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'syslog.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getSyslogPolicyByMoid(moid: string, options?: Configuration): Promise<SyslogPolicy> {
    	const result = this.api.getSyslogPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'syslog.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getSyslogPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<SyslogPolicyResponse> {
    	const result = this.api.getSyslogPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'syslog.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param syslogPolicy The &#39;syslog.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchSyslogPolicy(moid: string, syslogPolicy: SyslogPolicy, ifMatch?: string, options?: Configuration): Promise<SyslogPolicy> {
    	const result = this.api.patchSyslogPolicy(moid, syslogPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'syslog.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param syslogPolicy The &#39;syslog.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateSyslogPolicy(moid: string, syslogPolicy: SyslogPolicy, ifMatch?: string, options?: Configuration): Promise<SyslogPolicy> {
    	const result = this.api.updateSyslogPolicy(moid, syslogPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableTamApi } from './ObservableAPI';


import { TamApiRequestFactory, TamApiResponseProcessor} from "../apis/TamApi";
export class PromiseTamApi {
    private api: ObservableTamApi

    public constructor(
        configuration: Configuration,
        requestFactory?: TamApiRequestFactory,
        responseProcessor?: TamApiResponseProcessor
    ) {
        this.api = new ObservableTamApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'tam.AdvisoryCount' resource.
     * @param tamAdvisoryCount The &#39;tam.AdvisoryCount&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createTamAdvisoryCount(tamAdvisoryCount: TamAdvisoryCount, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<TamAdvisoryCount> {
    	const result = this.api.createTamAdvisoryCount(tamAdvisoryCount, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'tam.AdvisoryInfo' resource.
     * @param tamAdvisoryInfo The &#39;tam.AdvisoryInfo&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createTamAdvisoryInfo(tamAdvisoryInfo: TamAdvisoryInfo, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<TamAdvisoryInfo> {
    	const result = this.api.createTamAdvisoryInfo(tamAdvisoryInfo, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'tam.AdvisoryInstance' resource.
     * @param tamAdvisoryInstance The &#39;tam.AdvisoryInstance&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createTamAdvisoryInstance(tamAdvisoryInstance: TamAdvisoryInstance, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<TamAdvisoryInstance> {
    	const result = this.api.createTamAdvisoryInstance(tamAdvisoryInstance, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'tam.SecurityAdvisory' resource.
     * @param tamSecurityAdvisory The &#39;tam.SecurityAdvisory&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createTamSecurityAdvisory(tamSecurityAdvisory: TamSecurityAdvisory, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<TamSecurityAdvisory> {
    	const result = this.api.createTamSecurityAdvisory(tamSecurityAdvisory, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'tam.AdvisoryCount' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteTamAdvisoryCount(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteTamAdvisoryCount(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'tam.AdvisoryInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteTamAdvisoryInfo(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteTamAdvisoryInfo(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'tam.AdvisoryInstance' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteTamAdvisoryInstance(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteTamAdvisoryInstance(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'tam.SecurityAdvisory' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteTamSecurityAdvisory(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteTamSecurityAdvisory(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'tam.AdvisoryCount' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getTamAdvisoryCountByMoid(moid: string, options?: Configuration): Promise<TamAdvisoryCount> {
    	const result = this.api.getTamAdvisoryCountByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'tam.AdvisoryCount' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getTamAdvisoryCountList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<TamAdvisoryCountResponse> {
    	const result = this.api.getTamAdvisoryCountList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'tam.AdvisoryInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getTamAdvisoryInfoByMoid(moid: string, options?: Configuration): Promise<TamAdvisoryInfo> {
    	const result = this.api.getTamAdvisoryInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'tam.AdvisoryInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getTamAdvisoryInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<TamAdvisoryInfoResponse> {
    	const result = this.api.getTamAdvisoryInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'tam.AdvisoryInstance' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getTamAdvisoryInstanceByMoid(moid: string, options?: Configuration): Promise<TamAdvisoryInstance> {
    	const result = this.api.getTamAdvisoryInstanceByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'tam.AdvisoryInstance' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getTamAdvisoryInstanceList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<TamAdvisoryInstanceResponse> {
    	const result = this.api.getTamAdvisoryInstanceList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'tam.SecurityAdvisory' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getTamSecurityAdvisoryByMoid(moid: string, options?: Configuration): Promise<TamSecurityAdvisory> {
    	const result = this.api.getTamSecurityAdvisoryByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'tam.SecurityAdvisory' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getTamSecurityAdvisoryList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<TamSecurityAdvisoryResponse> {
    	const result = this.api.getTamSecurityAdvisoryList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'tam.AdvisoryCount' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param tamAdvisoryCount The &#39;tam.AdvisoryCount&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchTamAdvisoryCount(moid: string, tamAdvisoryCount: TamAdvisoryCount, ifMatch?: string, options?: Configuration): Promise<TamAdvisoryCount> {
    	const result = this.api.patchTamAdvisoryCount(moid, tamAdvisoryCount, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'tam.AdvisoryInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param tamAdvisoryInfo The &#39;tam.AdvisoryInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchTamAdvisoryInfo(moid: string, tamAdvisoryInfo: TamAdvisoryInfo, ifMatch?: string, options?: Configuration): Promise<TamAdvisoryInfo> {
    	const result = this.api.patchTamAdvisoryInfo(moid, tamAdvisoryInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'tam.AdvisoryInstance' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param tamAdvisoryInstance The &#39;tam.AdvisoryInstance&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchTamAdvisoryInstance(moid: string, tamAdvisoryInstance: TamAdvisoryInstance, ifMatch?: string, options?: Configuration): Promise<TamAdvisoryInstance> {
    	const result = this.api.patchTamAdvisoryInstance(moid, tamAdvisoryInstance, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'tam.SecurityAdvisory' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param tamSecurityAdvisory The &#39;tam.SecurityAdvisory&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchTamSecurityAdvisory(moid: string, tamSecurityAdvisory: TamSecurityAdvisory, ifMatch?: string, options?: Configuration): Promise<TamSecurityAdvisory> {
    	const result = this.api.patchTamSecurityAdvisory(moid, tamSecurityAdvisory, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'tam.AdvisoryCount' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param tamAdvisoryCount The &#39;tam.AdvisoryCount&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateTamAdvisoryCount(moid: string, tamAdvisoryCount: TamAdvisoryCount, ifMatch?: string, options?: Configuration): Promise<TamAdvisoryCount> {
    	const result = this.api.updateTamAdvisoryCount(moid, tamAdvisoryCount, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'tam.AdvisoryInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param tamAdvisoryInfo The &#39;tam.AdvisoryInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateTamAdvisoryInfo(moid: string, tamAdvisoryInfo: TamAdvisoryInfo, ifMatch?: string, options?: Configuration): Promise<TamAdvisoryInfo> {
    	const result = this.api.updateTamAdvisoryInfo(moid, tamAdvisoryInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'tam.AdvisoryInstance' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param tamAdvisoryInstance The &#39;tam.AdvisoryInstance&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateTamAdvisoryInstance(moid: string, tamAdvisoryInstance: TamAdvisoryInstance, ifMatch?: string, options?: Configuration): Promise<TamAdvisoryInstance> {
    	const result = this.api.updateTamAdvisoryInstance(moid, tamAdvisoryInstance, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'tam.SecurityAdvisory' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param tamSecurityAdvisory The &#39;tam.SecurityAdvisory&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateTamSecurityAdvisory(moid: string, tamSecurityAdvisory: TamSecurityAdvisory, ifMatch?: string, options?: Configuration): Promise<TamSecurityAdvisory> {
    	const result = this.api.updateTamSecurityAdvisory(moid, tamSecurityAdvisory, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableTaskApi } from './ObservableAPI';


import { TaskApiRequestFactory, TaskApiResponseProcessor} from "../apis/TaskApi";
export class PromiseTaskApi {
    private api: ObservableTaskApi

    public constructor(
        configuration: Configuration,
        requestFactory?: TaskApiRequestFactory,
        responseProcessor?: TaskApiResponseProcessor
    ) {
        this.api = new ObservableTaskApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'task.PureScopedInventory' resource.
     * @param taskPureScopedInventory The &#39;task.PureScopedInventory&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createTaskPureScopedInventory(taskPureScopedInventory: TaskPureScopedInventory, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<TaskPureScopedInventory> {
    	const result = this.api.createTaskPureScopedInventory(taskPureScopedInventory, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableTelemetryApi } from './ObservableAPI';


import { TelemetryApiRequestFactory, TelemetryApiResponseProcessor} from "../apis/TelemetryApi";
export class PromiseTelemetryApi {
    private api: ObservableTelemetryApi

    public constructor(
        configuration: Configuration,
        requestFactory?: TelemetryApiRequestFactory,
        responseProcessor?: TelemetryApiResponseProcessor
    ) {
        this.api = new ObservableTelemetryApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Endpoint that exposes Druid requests for time series data. This endpoint exposes multiple requests, including Time series, Top N, GroupBy, Scan, Time Boundary, Segment meta-data and datasource meta-data.
     * Perform a Druid time series aggregation request.
     * @param telemetryDruidAggregateRequest The Druid request schema for time series queries.
     */
    public queryTelemetryTimeSeries(telemetryDruidAggregateRequest: TelemetryDruidAggregateRequest, options?: Configuration): Promise<Array<TelemetryDruidIntervalResult>> {
    	const result = this.api.queryTelemetryTimeSeries(telemetryDruidAggregateRequest, options);
        return result.toPromise();
    }
	

}



import { ObservableTerminalApi } from './ObservableAPI';


import { TerminalApiRequestFactory, TerminalApiResponseProcessor} from "../apis/TerminalApi";
export class PromiseTerminalApi {
    private api: ObservableTerminalApi

    public constructor(
        configuration: Configuration,
        requestFactory?: TerminalApiRequestFactory,
        responseProcessor?: TerminalApiResponseProcessor
    ) {
        this.api = new ObservableTerminalApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'terminal.AuditLog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getTerminalAuditLogByMoid(moid: string, options?: Configuration): Promise<TerminalAuditLog> {
    	const result = this.api.getTerminalAuditLogByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'terminal.AuditLog' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getTerminalAuditLogList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<TerminalAuditLogResponse> {
    	const result = this.api.getTerminalAuditLogList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableTopApi } from './ObservableAPI';


import { TopApiRequestFactory, TopApiResponseProcessor} from "../apis/TopApi";
export class PromiseTopApi {
    private api: ObservableTopApi

    public constructor(
        configuration: Configuration,
        requestFactory?: TopApiRequestFactory,
        responseProcessor?: TopApiResponseProcessor
    ) {
        this.api = new ObservableTopApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'top.System' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getTopSystemByMoid(moid: string, options?: Configuration): Promise<TopSystem> {
    	const result = this.api.getTopSystemByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'top.System' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getTopSystemList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<TopSystemResponse> {
    	const result = this.api.getTopSystemList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'top.System' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param topSystem The &#39;top.System&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchTopSystem(moid: string, topSystem: TopSystem, ifMatch?: string, options?: Configuration): Promise<TopSystem> {
    	const result = this.api.patchTopSystem(moid, topSystem, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'top.System' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param topSystem The &#39;top.System&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateTopSystem(moid: string, topSystem: TopSystem, ifMatch?: string, options?: Configuration): Promise<TopSystem> {
    	const result = this.api.updateTopSystem(moid, topSystem, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableUcsdApi } from './ObservableAPI';


import { UcsdApiRequestFactory, UcsdApiResponseProcessor} from "../apis/UcsdApi";
export class PromiseUcsdApi {
    private api: ObservableUcsdApi

    public constructor(
        configuration: Configuration,
        requestFactory?: UcsdApiRequestFactory,
        responseProcessor?: UcsdApiResponseProcessor
    ) {
        this.api = new ObservableUcsdApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Delete a 'ucsd.BackupInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteUcsdBackupInfo(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteUcsdBackupInfo(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ucsd.BackupInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getUcsdBackupInfoByMoid(moid: string, options?: Configuration): Promise<UcsdBackupInfo> {
    	const result = this.api.getUcsdBackupInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'ucsd.BackupInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getUcsdBackupInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<UcsdBackupInfoResponse> {
    	const result = this.api.getUcsdBackupInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	

}



import { ObservableVirtualizationApi } from './ObservableAPI';


import { VirtualizationApiRequestFactory, VirtualizationApiResponseProcessor} from "../apis/VirtualizationApi";
export class PromiseVirtualizationApi {
    private api: ObservableVirtualizationApi

    public constructor(
        configuration: Configuration,
        requestFactory?: VirtualizationApiRequestFactory,
        responseProcessor?: VirtualizationApiResponseProcessor
    ) {
        this.api = new ObservableVirtualizationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Read a 'virtualization.VmwareCluster' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVirtualizationVmwareClusterByMoid(moid: string, options?: Configuration): Promise<VirtualizationVmwareCluster> {
    	const result = this.api.getVirtualizationVmwareClusterByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareCluster' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVirtualizationVmwareClusterList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VirtualizationVmwareClusterResponse> {
    	const result = this.api.getVirtualizationVmwareClusterList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareDatacenter' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVirtualizationVmwareDatacenterByMoid(moid: string, options?: Configuration): Promise<VirtualizationVmwareDatacenter> {
    	const result = this.api.getVirtualizationVmwareDatacenterByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareDatacenter' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVirtualizationVmwareDatacenterList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VirtualizationVmwareDatacenterResponse> {
    	const result = this.api.getVirtualizationVmwareDatacenterList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareDatastore' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVirtualizationVmwareDatastoreByMoid(moid: string, options?: Configuration): Promise<VirtualizationVmwareDatastore> {
    	const result = this.api.getVirtualizationVmwareDatastoreByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareDatastore' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVirtualizationVmwareDatastoreList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VirtualizationVmwareDatastoreResponse> {
    	const result = this.api.getVirtualizationVmwareDatastoreList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareHost' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVirtualizationVmwareHostByMoid(moid: string, options?: Configuration): Promise<VirtualizationVmwareHost> {
    	const result = this.api.getVirtualizationVmwareHostByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareHost' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVirtualizationVmwareHostList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VirtualizationVmwareHostResponse> {
    	const result = this.api.getVirtualizationVmwareHostList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareVcenter' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVirtualizationVmwareVcenterByMoid(moid: string, options?: Configuration): Promise<VirtualizationVmwareVcenter> {
    	const result = this.api.getVirtualizationVmwareVcenterByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareVcenter' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVirtualizationVmwareVcenterList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VirtualizationVmwareVcenterResponse> {
    	const result = this.api.getVirtualizationVmwareVcenterList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareVirtualMachine' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVirtualizationVmwareVirtualMachineByMoid(moid: string, options?: Configuration): Promise<VirtualizationVmwareVirtualMachine> {
    	const result = this.api.getVirtualizationVmwareVirtualMachineByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'virtualization.VmwareVirtualMachine' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVirtualizationVmwareVirtualMachineList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VirtualizationVmwareVirtualMachineResponse> {
    	const result = this.api.getVirtualizationVmwareVirtualMachineList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareCluster' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareCluster The &#39;virtualization.VmwareCluster&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVirtualizationVmwareCluster(moid: string, virtualizationVmwareCluster: VirtualizationVmwareCluster, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareCluster> {
    	const result = this.api.patchVirtualizationVmwareCluster(moid, virtualizationVmwareCluster, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareDatacenter' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareDatacenter The &#39;virtualization.VmwareDatacenter&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVirtualizationVmwareDatacenter(moid: string, virtualizationVmwareDatacenter: VirtualizationVmwareDatacenter, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareDatacenter> {
    	const result = this.api.patchVirtualizationVmwareDatacenter(moid, virtualizationVmwareDatacenter, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareDatastore' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareDatastore The &#39;virtualization.VmwareDatastore&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVirtualizationVmwareDatastore(moid: string, virtualizationVmwareDatastore: VirtualizationVmwareDatastore, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareDatastore> {
    	const result = this.api.patchVirtualizationVmwareDatastore(moid, virtualizationVmwareDatastore, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareHost' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareHost The &#39;virtualization.VmwareHost&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVirtualizationVmwareHost(moid: string, virtualizationVmwareHost: VirtualizationVmwareHost, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareHost> {
    	const result = this.api.patchVirtualizationVmwareHost(moid, virtualizationVmwareHost, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareVirtualMachine' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareVirtualMachine The &#39;virtualization.VmwareVirtualMachine&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVirtualizationVmwareVirtualMachine(moid: string, virtualizationVmwareVirtualMachine: VirtualizationVmwareVirtualMachine, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareVirtualMachine> {
    	const result = this.api.patchVirtualizationVmwareVirtualMachine(moid, virtualizationVmwareVirtualMachine, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareCluster' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareCluster The &#39;virtualization.VmwareCluster&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVirtualizationVmwareCluster(moid: string, virtualizationVmwareCluster: VirtualizationVmwareCluster, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareCluster> {
    	const result = this.api.updateVirtualizationVmwareCluster(moid, virtualizationVmwareCluster, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareDatacenter' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareDatacenter The &#39;virtualization.VmwareDatacenter&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVirtualizationVmwareDatacenter(moid: string, virtualizationVmwareDatacenter: VirtualizationVmwareDatacenter, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareDatacenter> {
    	const result = this.api.updateVirtualizationVmwareDatacenter(moid, virtualizationVmwareDatacenter, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareDatastore' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareDatastore The &#39;virtualization.VmwareDatastore&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVirtualizationVmwareDatastore(moid: string, virtualizationVmwareDatastore: VirtualizationVmwareDatastore, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareDatastore> {
    	const result = this.api.updateVirtualizationVmwareDatastore(moid, virtualizationVmwareDatastore, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareHost' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareHost The &#39;virtualization.VmwareHost&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVirtualizationVmwareHost(moid: string, virtualizationVmwareHost: VirtualizationVmwareHost, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareHost> {
    	const result = this.api.updateVirtualizationVmwareHost(moid, virtualizationVmwareHost, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'virtualization.VmwareVirtualMachine' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param virtualizationVmwareVirtualMachine The &#39;virtualization.VmwareVirtualMachine&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVirtualizationVmwareVirtualMachine(moid: string, virtualizationVmwareVirtualMachine: VirtualizationVmwareVirtualMachine, ifMatch?: string, options?: Configuration): Promise<VirtualizationVmwareVirtualMachine> {
    	const result = this.api.updateVirtualizationVmwareVirtualMachine(moid, virtualizationVmwareVirtualMachine, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableVmediaApi } from './ObservableAPI';


import { VmediaApiRequestFactory, VmediaApiResponseProcessor} from "../apis/VmediaApi";
export class PromiseVmediaApi {
    private api: ObservableVmediaApi

    public constructor(
        configuration: Configuration,
        requestFactory?: VmediaApiRequestFactory,
        responseProcessor?: VmediaApiResponseProcessor
    ) {
        this.api = new ObservableVmediaApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'vmedia.Policy' resource.
     * @param vmediaPolicy The &#39;vmedia.Policy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVmediaPolicy(vmediaPolicy: VmediaPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VmediaPolicy> {
    	const result = this.api.createVmediaPolicy(vmediaPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vmedia.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVmediaPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVmediaPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vmedia.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVmediaPolicyByMoid(moid: string, options?: Configuration): Promise<VmediaPolicy> {
    	const result = this.api.getVmediaPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vmedia.Policy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVmediaPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VmediaPolicyResponse> {
    	const result = this.api.getVmediaPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vmedia.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vmediaPolicy The &#39;vmedia.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVmediaPolicy(moid: string, vmediaPolicy: VmediaPolicy, ifMatch?: string, options?: Configuration): Promise<VmediaPolicy> {
    	const result = this.api.patchVmediaPolicy(moid, vmediaPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vmedia.Policy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vmediaPolicy The &#39;vmedia.Policy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVmediaPolicy(moid: string, vmediaPolicy: VmediaPolicy, ifMatch?: string, options?: Configuration): Promise<VmediaPolicy> {
    	const result = this.api.updateVmediaPolicy(moid, vmediaPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableVnicApi } from './ObservableAPI';


import { VnicApiRequestFactory, VnicApiResponseProcessor} from "../apis/VnicApi";
export class PromiseVnicApi {
    private api: ObservableVnicApi

    public constructor(
        configuration: Configuration,
        requestFactory?: VnicApiRequestFactory,
        responseProcessor?: VnicApiResponseProcessor
    ) {
        this.api = new ObservableVnicApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'vnic.EthAdapterPolicy' resource.
     * @param vnicEthAdapterPolicy The &#39;vnic.EthAdapterPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicEthAdapterPolicy(vnicEthAdapterPolicy: VnicEthAdapterPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicEthAdapterPolicy> {
    	const result = this.api.createVnicEthAdapterPolicy(vnicEthAdapterPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'vnic.EthIf' resource.
     * @param vnicEthIf The &#39;vnic.EthIf&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicEthIf(vnicEthIf: VnicEthIf, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicEthIf> {
    	const result = this.api.createVnicEthIf(vnicEthIf, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'vnic.EthNetworkPolicy' resource.
     * @param vnicEthNetworkPolicy The &#39;vnic.EthNetworkPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicEthNetworkPolicy(vnicEthNetworkPolicy: VnicEthNetworkPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicEthNetworkPolicy> {
    	const result = this.api.createVnicEthNetworkPolicy(vnicEthNetworkPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'vnic.EthQosPolicy' resource.
     * @param vnicEthQosPolicy The &#39;vnic.EthQosPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicEthQosPolicy(vnicEthQosPolicy: VnicEthQosPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicEthQosPolicy> {
    	const result = this.api.createVnicEthQosPolicy(vnicEthQosPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'vnic.FcAdapterPolicy' resource.
     * @param vnicFcAdapterPolicy The &#39;vnic.FcAdapterPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicFcAdapterPolicy(vnicFcAdapterPolicy: VnicFcAdapterPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicFcAdapterPolicy> {
    	const result = this.api.createVnicFcAdapterPolicy(vnicFcAdapterPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'vnic.FcIf' resource.
     * @param vnicFcIf The &#39;vnic.FcIf&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicFcIf(vnicFcIf: VnicFcIf, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicFcIf> {
    	const result = this.api.createVnicFcIf(vnicFcIf, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'vnic.FcNetworkPolicy' resource.
     * @param vnicFcNetworkPolicy The &#39;vnic.FcNetworkPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicFcNetworkPolicy(vnicFcNetworkPolicy: VnicFcNetworkPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicFcNetworkPolicy> {
    	const result = this.api.createVnicFcNetworkPolicy(vnicFcNetworkPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'vnic.FcQosPolicy' resource.
     * @param vnicFcQosPolicy The &#39;vnic.FcQosPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicFcQosPolicy(vnicFcQosPolicy: VnicFcQosPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicFcQosPolicy> {
    	const result = this.api.createVnicFcQosPolicy(vnicFcQosPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'vnic.LanConnectivityPolicy' resource.
     * @param vnicLanConnectivityPolicy The &#39;vnic.LanConnectivityPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicLanConnectivityPolicy(vnicLanConnectivityPolicy: VnicLanConnectivityPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicLanConnectivityPolicy> {
    	const result = this.api.createVnicLanConnectivityPolicy(vnicLanConnectivityPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'vnic.SanConnectivityPolicy' resource.
     * @param vnicSanConnectivityPolicy The &#39;vnic.SanConnectivityPolicy&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createVnicSanConnectivityPolicy(vnicSanConnectivityPolicy: VnicSanConnectivityPolicy, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<VnicSanConnectivityPolicy> {
    	const result = this.api.createVnicSanConnectivityPolicy(vnicSanConnectivityPolicy, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.EthAdapterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicEthAdapterPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicEthAdapterPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.EthIf' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicEthIf(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicEthIf(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.EthNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicEthNetworkPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicEthNetworkPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.EthQosPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicEthQosPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicEthQosPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.FcAdapterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicFcAdapterPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicFcAdapterPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.FcIf' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicFcIf(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicFcIf(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.FcNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicFcNetworkPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicFcNetworkPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.FcQosPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicFcQosPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicFcQosPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.LanConnectivityPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicLanConnectivityPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicLanConnectivityPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'vnic.SanConnectivityPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteVnicSanConnectivityPolicy(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteVnicSanConnectivityPolicy(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.EthAdapterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicEthAdapterPolicyByMoid(moid: string, options?: Configuration): Promise<VnicEthAdapterPolicy> {
    	const result = this.api.getVnicEthAdapterPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.EthAdapterPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicEthAdapterPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicEthAdapterPolicyResponse> {
    	const result = this.api.getVnicEthAdapterPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.EthIf' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicEthIfByMoid(moid: string, options?: Configuration): Promise<VnicEthIf> {
    	const result = this.api.getVnicEthIfByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.EthIf' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicEthIfList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicEthIfResponse> {
    	const result = this.api.getVnicEthIfList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.EthNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicEthNetworkPolicyByMoid(moid: string, options?: Configuration): Promise<VnicEthNetworkPolicy> {
    	const result = this.api.getVnicEthNetworkPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.EthNetworkPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicEthNetworkPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicEthNetworkPolicyResponse> {
    	const result = this.api.getVnicEthNetworkPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.EthQosPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicEthQosPolicyByMoid(moid: string, options?: Configuration): Promise<VnicEthQosPolicy> {
    	const result = this.api.getVnicEthQosPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.EthQosPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicEthQosPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicEthQosPolicyResponse> {
    	const result = this.api.getVnicEthQosPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.FcAdapterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicFcAdapterPolicyByMoid(moid: string, options?: Configuration): Promise<VnicFcAdapterPolicy> {
    	const result = this.api.getVnicFcAdapterPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.FcAdapterPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicFcAdapterPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicFcAdapterPolicyResponse> {
    	const result = this.api.getVnicFcAdapterPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.FcIf' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicFcIfByMoid(moid: string, options?: Configuration): Promise<VnicFcIf> {
    	const result = this.api.getVnicFcIfByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.FcIf' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicFcIfList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicFcIfResponse> {
    	const result = this.api.getVnicFcIfList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.FcNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicFcNetworkPolicyByMoid(moid: string, options?: Configuration): Promise<VnicFcNetworkPolicy> {
    	const result = this.api.getVnicFcNetworkPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.FcNetworkPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicFcNetworkPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicFcNetworkPolicyResponse> {
    	const result = this.api.getVnicFcNetworkPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.FcQosPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicFcQosPolicyByMoid(moid: string, options?: Configuration): Promise<VnicFcQosPolicy> {
    	const result = this.api.getVnicFcQosPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.FcQosPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicFcQosPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicFcQosPolicyResponse> {
    	const result = this.api.getVnicFcQosPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.LanConnectivityPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicLanConnectivityPolicyByMoid(moid: string, options?: Configuration): Promise<VnicLanConnectivityPolicy> {
    	const result = this.api.getVnicLanConnectivityPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.LanConnectivityPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicLanConnectivityPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicLanConnectivityPolicyResponse> {
    	const result = this.api.getVnicLanConnectivityPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.SanConnectivityPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getVnicSanConnectivityPolicyByMoid(moid: string, options?: Configuration): Promise<VnicSanConnectivityPolicy> {
    	const result = this.api.getVnicSanConnectivityPolicyByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'vnic.SanConnectivityPolicy' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getVnicSanConnectivityPolicyList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<VnicSanConnectivityPolicyResponse> {
    	const result = this.api.getVnicSanConnectivityPolicyList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.EthAdapterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicEthAdapterPolicy The &#39;vnic.EthAdapterPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicEthAdapterPolicy(moid: string, vnicEthAdapterPolicy: VnicEthAdapterPolicy, ifMatch?: string, options?: Configuration): Promise<VnicEthAdapterPolicy> {
    	const result = this.api.patchVnicEthAdapterPolicy(moid, vnicEthAdapterPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.EthIf' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicEthIf The &#39;vnic.EthIf&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicEthIf(moid: string, vnicEthIf: VnicEthIf, ifMatch?: string, options?: Configuration): Promise<VnicEthIf> {
    	const result = this.api.patchVnicEthIf(moid, vnicEthIf, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.EthNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicEthNetworkPolicy The &#39;vnic.EthNetworkPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicEthNetworkPolicy(moid: string, vnicEthNetworkPolicy: VnicEthNetworkPolicy, ifMatch?: string, options?: Configuration): Promise<VnicEthNetworkPolicy> {
    	const result = this.api.patchVnicEthNetworkPolicy(moid, vnicEthNetworkPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.EthQosPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicEthQosPolicy The &#39;vnic.EthQosPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicEthQosPolicy(moid: string, vnicEthQosPolicy: VnicEthQosPolicy, ifMatch?: string, options?: Configuration): Promise<VnicEthQosPolicy> {
    	const result = this.api.patchVnicEthQosPolicy(moid, vnicEthQosPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.FcAdapterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicFcAdapterPolicy The &#39;vnic.FcAdapterPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicFcAdapterPolicy(moid: string, vnicFcAdapterPolicy: VnicFcAdapterPolicy, ifMatch?: string, options?: Configuration): Promise<VnicFcAdapterPolicy> {
    	const result = this.api.patchVnicFcAdapterPolicy(moid, vnicFcAdapterPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.FcIf' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicFcIf The &#39;vnic.FcIf&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicFcIf(moid: string, vnicFcIf: VnicFcIf, ifMatch?: string, options?: Configuration): Promise<VnicFcIf> {
    	const result = this.api.patchVnicFcIf(moid, vnicFcIf, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.FcNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicFcNetworkPolicy The &#39;vnic.FcNetworkPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicFcNetworkPolicy(moid: string, vnicFcNetworkPolicy: VnicFcNetworkPolicy, ifMatch?: string, options?: Configuration): Promise<VnicFcNetworkPolicy> {
    	const result = this.api.patchVnicFcNetworkPolicy(moid, vnicFcNetworkPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.FcQosPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicFcQosPolicy The &#39;vnic.FcQosPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicFcQosPolicy(moid: string, vnicFcQosPolicy: VnicFcQosPolicy, ifMatch?: string, options?: Configuration): Promise<VnicFcQosPolicy> {
    	const result = this.api.patchVnicFcQosPolicy(moid, vnicFcQosPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.LanConnectivityPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicLanConnectivityPolicy The &#39;vnic.LanConnectivityPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicLanConnectivityPolicy(moid: string, vnicLanConnectivityPolicy: VnicLanConnectivityPolicy, ifMatch?: string, options?: Configuration): Promise<VnicLanConnectivityPolicy> {
    	const result = this.api.patchVnicLanConnectivityPolicy(moid, vnicLanConnectivityPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.SanConnectivityPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicSanConnectivityPolicy The &#39;vnic.SanConnectivityPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchVnicSanConnectivityPolicy(moid: string, vnicSanConnectivityPolicy: VnicSanConnectivityPolicy, ifMatch?: string, options?: Configuration): Promise<VnicSanConnectivityPolicy> {
    	const result = this.api.patchVnicSanConnectivityPolicy(moid, vnicSanConnectivityPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.EthAdapterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicEthAdapterPolicy The &#39;vnic.EthAdapterPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicEthAdapterPolicy(moid: string, vnicEthAdapterPolicy: VnicEthAdapterPolicy, ifMatch?: string, options?: Configuration): Promise<VnicEthAdapterPolicy> {
    	const result = this.api.updateVnicEthAdapterPolicy(moid, vnicEthAdapterPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.EthIf' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicEthIf The &#39;vnic.EthIf&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicEthIf(moid: string, vnicEthIf: VnicEthIf, ifMatch?: string, options?: Configuration): Promise<VnicEthIf> {
    	const result = this.api.updateVnicEthIf(moid, vnicEthIf, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.EthNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicEthNetworkPolicy The &#39;vnic.EthNetworkPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicEthNetworkPolicy(moid: string, vnicEthNetworkPolicy: VnicEthNetworkPolicy, ifMatch?: string, options?: Configuration): Promise<VnicEthNetworkPolicy> {
    	const result = this.api.updateVnicEthNetworkPolicy(moid, vnicEthNetworkPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.EthQosPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicEthQosPolicy The &#39;vnic.EthQosPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicEthQosPolicy(moid: string, vnicEthQosPolicy: VnicEthQosPolicy, ifMatch?: string, options?: Configuration): Promise<VnicEthQosPolicy> {
    	const result = this.api.updateVnicEthQosPolicy(moid, vnicEthQosPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.FcAdapterPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicFcAdapterPolicy The &#39;vnic.FcAdapterPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicFcAdapterPolicy(moid: string, vnicFcAdapterPolicy: VnicFcAdapterPolicy, ifMatch?: string, options?: Configuration): Promise<VnicFcAdapterPolicy> {
    	const result = this.api.updateVnicFcAdapterPolicy(moid, vnicFcAdapterPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.FcIf' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicFcIf The &#39;vnic.FcIf&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicFcIf(moid: string, vnicFcIf: VnicFcIf, ifMatch?: string, options?: Configuration): Promise<VnicFcIf> {
    	const result = this.api.updateVnicFcIf(moid, vnicFcIf, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.FcNetworkPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicFcNetworkPolicy The &#39;vnic.FcNetworkPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicFcNetworkPolicy(moid: string, vnicFcNetworkPolicy: VnicFcNetworkPolicy, ifMatch?: string, options?: Configuration): Promise<VnicFcNetworkPolicy> {
    	const result = this.api.updateVnicFcNetworkPolicy(moid, vnicFcNetworkPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.FcQosPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicFcQosPolicy The &#39;vnic.FcQosPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicFcQosPolicy(moid: string, vnicFcQosPolicy: VnicFcQosPolicy, ifMatch?: string, options?: Configuration): Promise<VnicFcQosPolicy> {
    	const result = this.api.updateVnicFcQosPolicy(moid, vnicFcQosPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.LanConnectivityPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicLanConnectivityPolicy The &#39;vnic.LanConnectivityPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicLanConnectivityPolicy(moid: string, vnicLanConnectivityPolicy: VnicLanConnectivityPolicy, ifMatch?: string, options?: Configuration): Promise<VnicLanConnectivityPolicy> {
    	const result = this.api.updateVnicLanConnectivityPolicy(moid, vnicLanConnectivityPolicy, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'vnic.SanConnectivityPolicy' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param vnicSanConnectivityPolicy The &#39;vnic.SanConnectivityPolicy&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateVnicSanConnectivityPolicy(moid: string, vnicSanConnectivityPolicy: VnicSanConnectivityPolicy, ifMatch?: string, options?: Configuration): Promise<VnicSanConnectivityPolicy> {
    	const result = this.api.updateVnicSanConnectivityPolicy(moid, vnicSanConnectivityPolicy, ifMatch, options);
        return result.toPromise();
    }
	

}



import { ObservableWorkflowApi } from './ObservableAPI';


import { WorkflowApiRequestFactory, WorkflowApiResponseProcessor} from "../apis/WorkflowApi";
export class PromiseWorkflowApi {
    private api: ObservableWorkflowApi

    public constructor(
        configuration: Configuration,
        requestFactory?: WorkflowApiRequestFactory,
        responseProcessor?: WorkflowApiResponseProcessor
    ) {
        this.api = new ObservableWorkflowApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a 'workflow.BatchApiExecutor' resource.
     * @param workflowBatchApiExecutor The &#39;workflow.BatchApiExecutor&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createWorkflowBatchApiExecutor(workflowBatchApiExecutor: WorkflowBatchApiExecutor, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<WorkflowBatchApiExecutor> {
    	const result = this.api.createWorkflowBatchApiExecutor(workflowBatchApiExecutor, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'workflow.CustomDataTypeDefinition' resource.
     * @param workflowCustomDataTypeDefinition The &#39;workflow.CustomDataTypeDefinition&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createWorkflowCustomDataTypeDefinition(workflowCustomDataTypeDefinition: WorkflowCustomDataTypeDefinition, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<WorkflowCustomDataTypeDefinition> {
    	const result = this.api.createWorkflowCustomDataTypeDefinition(workflowCustomDataTypeDefinition, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'workflow.TaskDefinition' resource.
     * @param workflowTaskDefinition The &#39;workflow.TaskDefinition&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createWorkflowTaskDefinition(workflowTaskDefinition: WorkflowTaskDefinition, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<WorkflowTaskDefinition> {
    	const result = this.api.createWorkflowTaskDefinition(workflowTaskDefinition, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'workflow.WorkflowDefinition' resource.
     * @param workflowWorkflowDefinition The &#39;workflow.WorkflowDefinition&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createWorkflowWorkflowDefinition(workflowWorkflowDefinition: WorkflowWorkflowDefinition, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<WorkflowWorkflowDefinition> {
    	const result = this.api.createWorkflowWorkflowDefinition(workflowWorkflowDefinition, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Create a 'workflow.WorkflowInfo' resource.
     * @param workflowWorkflowInfo The &#39;workflow.WorkflowInfo&#39; resource to create.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     * @param ifNoneMatch For methods that apply server-side changes, If-None-Match used with the * value can be used to create a resource not known to exist, guaranteeing that another resource creation didn&#39;t happen before, losing the data of the previous put. The request will be processed only if the eventually existing resource&#39;s ETag doesn&#39;t match any of the values listed. Otherwise, the status code 412 (Precondition Failed) is used. The asterisk is a special value representing any resource. It is only useful when creating a resource, usually with PUT, to check if another resource with the identity has already been created before. The comparison with the stored ETag uses the weak comparison algorithm, meaning two resources are considered identical if the content is equivalent - they don&#39;t have to be identical byte for byte.
     */
    public createWorkflowWorkflowInfo(workflowWorkflowInfo: WorkflowWorkflowInfo, ifMatch?: string, ifNoneMatch?: string, options?: Configuration): Promise<WorkflowWorkflowInfo> {
    	const result = this.api.createWorkflowWorkflowInfo(workflowWorkflowInfo, ifMatch, ifNoneMatch, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'workflow.BatchApiExecutor' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteWorkflowBatchApiExecutor(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteWorkflowBatchApiExecutor(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'workflow.CustomDataTypeDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteWorkflowCustomDataTypeDefinition(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteWorkflowCustomDataTypeDefinition(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'workflow.TaskDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteWorkflowTaskDefinition(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteWorkflowTaskDefinition(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'workflow.WorkflowDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteWorkflowWorkflowDefinition(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteWorkflowWorkflowDefinition(moid, options);
        return result.toPromise();
    }
	
    /**
     * Delete a 'workflow.WorkflowInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public deleteWorkflowWorkflowInfo(moid: string, options?: Configuration): Promise<void> {
    	const result = this.api.deleteWorkflowWorkflowInfo(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.BatchApiExecutor' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowBatchApiExecutorByMoid(moid: string, options?: Configuration): Promise<WorkflowBatchApiExecutor> {
    	const result = this.api.getWorkflowBatchApiExecutorByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.BatchApiExecutor' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowBatchApiExecutorList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowBatchApiExecutorResponse> {
    	const result = this.api.getWorkflowBatchApiExecutorList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.BuildTaskMeta' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowBuildTaskMetaByMoid(moid: string, options?: Configuration): Promise<WorkflowBuildTaskMeta> {
    	const result = this.api.getWorkflowBuildTaskMetaByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.BuildTaskMeta' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowBuildTaskMetaList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowBuildTaskMetaResponse> {
    	const result = this.api.getWorkflowBuildTaskMetaList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.BuildTaskMetaOwner' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowBuildTaskMetaOwnerByMoid(moid: string, options?: Configuration): Promise<WorkflowBuildTaskMetaOwner> {
    	const result = this.api.getWorkflowBuildTaskMetaOwnerByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.BuildTaskMetaOwner' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowBuildTaskMetaOwnerList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowBuildTaskMetaOwnerResponse> {
    	const result = this.api.getWorkflowBuildTaskMetaOwnerList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.Catalog' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowCatalogByMoid(moid: string, options?: Configuration): Promise<WorkflowCatalog> {
    	const result = this.api.getWorkflowCatalogByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.Catalog' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowCatalogList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowCatalogResponse> {
    	const result = this.api.getWorkflowCatalogList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.CustomDataTypeDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowCustomDataTypeDefinitionByMoid(moid: string, options?: Configuration): Promise<WorkflowCustomDataTypeDefinition> {
    	const result = this.api.getWorkflowCustomDataTypeDefinitionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.CustomDataTypeDefinition' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowCustomDataTypeDefinitionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowCustomDataTypeDefinitionResponse> {
    	const result = this.api.getWorkflowCustomDataTypeDefinitionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.PendingDynamicWorkflowInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowPendingDynamicWorkflowInfoByMoid(moid: string, options?: Configuration): Promise<WorkflowPendingDynamicWorkflowInfo> {
    	const result = this.api.getWorkflowPendingDynamicWorkflowInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.PendingDynamicWorkflowInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowPendingDynamicWorkflowInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowPendingDynamicWorkflowInfoResponse> {
    	const result = this.api.getWorkflowPendingDynamicWorkflowInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.TaskDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowTaskDefinitionByMoid(moid: string, options?: Configuration): Promise<WorkflowTaskDefinition> {
    	const result = this.api.getWorkflowTaskDefinitionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.TaskDefinition' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowTaskDefinitionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowTaskDefinitionResponse> {
    	const result = this.api.getWorkflowTaskDefinitionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.TaskInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowTaskInfoByMoid(moid: string, options?: Configuration): Promise<WorkflowTaskInfo> {
    	const result = this.api.getWorkflowTaskInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.TaskInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowTaskInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowTaskInfoResponse> {
    	const result = this.api.getWorkflowTaskInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.TaskMeta' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowTaskMetaByMoid(moid: string, options?: Configuration): Promise<WorkflowTaskMeta> {
    	const result = this.api.getWorkflowTaskMetaByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.TaskMeta' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowTaskMetaList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowTaskMetaResponse> {
    	const result = this.api.getWorkflowTaskMetaList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.WorkflowDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowWorkflowDefinitionByMoid(moid: string, options?: Configuration): Promise<WorkflowWorkflowDefinition> {
    	const result = this.api.getWorkflowWorkflowDefinitionByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.WorkflowDefinition' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowWorkflowDefinitionList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowWorkflowDefinitionResponse> {
    	const result = this.api.getWorkflowWorkflowDefinitionList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.WorkflowInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowWorkflowInfoByMoid(moid: string, options?: Configuration): Promise<WorkflowWorkflowInfo> {
    	const result = this.api.getWorkflowWorkflowInfoByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.WorkflowInfo' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowWorkflowInfoList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowWorkflowInfoResponse> {
    	const result = this.api.getWorkflowWorkflowInfoList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.WorkflowMeta' resource.
     * @param moid The unique Moid identifier of a resource instance.
     */
    public getWorkflowWorkflowMetaByMoid(moid: string, options?: Configuration): Promise<WorkflowWorkflowMeta> {
    	const result = this.api.getWorkflowWorkflowMetaByMoid(moid, options);
        return result.toPromise();
    }
	
    /**
     * Read a 'workflow.WorkflowMeta' resource.
     * @param filter Filter criteria for the resources to return. A URI with a $filter query option identifies a subset of the entries from the Collection of Entries. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the $filter option. The expression language that is used in $filter queries supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false).
     * @param orderby Determines what properties are used to sort the collection of resources.
     * @param top Specifies the maximum number of resources to return in the response.
     * @param skip Specifies the number of resources to skip in the response.
     * @param select Specifies a subset of properties to return.
     * @param expand Specify additional attributes or related resources to return in addition to the primary resources.
     * @param apply Specify one or more transformation operations to perform aggregation on the resources. The transformations are processed in order with the output from a transformation being used as input for the subsequent transformation. The \&quot;$apply\&quot; query takes a sequence of set transformations, separated by forward slashes to express that they are consecutively applied, i.e. the result of each transformation is the input to the next transformation. Supported aggregation methods are \&quot;aggregate\&quot; and \&quot;groupby\&quot;. The **aggregate** transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for all instances in the input set. The **groupby** transformation takes one or two parameters and 1. Splits the initial set into subsets where all instances in a subset have the same values for the grouping properties specified in the first parameter, 2. Applies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality, 3. Ensures that the instances in the result set contain all grouping properties with the correct values for the group, 4. Concatenates the intermediate result sets into one result set. A groupby transformation affects the structure of the result set.
     * @param count The $count query specifies the service should return the count of the matching resources, instead of returning the resources.
     * @param inlinecount The $inlinecount query option allows clients to request an inline count of the matching resources included with the resources in the response.
     * @param at Similar to \&quot;$filter\&quot;, but \&quot;at\&quot; is specifically used to filter versioning information properties for resources to return. A URI with an \&quot;at\&quot; Query Option identifies a subset of the Entries from the Collection of Entries identified by the Resource Path section of the URI. The subset is determined by selecting only the Entries that satisfy the predicate expression specified by the query option. The expression language that is used in at operators supports references to properties and literals. The literal values can be strings enclosed in single quotes, numbers and boolean values (true or false) or any of the additional literal representations shown in the Abstract Type System section.
     * @param tags The &#39;tags&#39; parameter is used to request a summary of the Tag utilization for this resource. When the &#39;tags&#39; parameter is specified, the response provides a list of tag keys, the number of times the key has been used across all documents, and the tag values that have been assigned to the tag key.
     */
    public getWorkflowWorkflowMetaList(filter?: string, orderby?: string, top?: number, skip?: number, select?: string, expand?: string, apply?: string, count?: boolean, inlinecount?: 'allpages' | 'none', at?: string, tags?: string, options?: Configuration): Promise<WorkflowWorkflowMetaResponse> {
    	const result = this.api.getWorkflowWorkflowMetaList(filter, orderby, top, skip, select, expand, apply, count, inlinecount, at, tags, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.BatchApiExecutor' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowBatchApiExecutor The &#39;workflow.BatchApiExecutor&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchWorkflowBatchApiExecutor(moid: string, workflowBatchApiExecutor: WorkflowBatchApiExecutor, ifMatch?: string, options?: Configuration): Promise<WorkflowBatchApiExecutor> {
    	const result = this.api.patchWorkflowBatchApiExecutor(moid, workflowBatchApiExecutor, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.CustomDataTypeDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowCustomDataTypeDefinition The &#39;workflow.CustomDataTypeDefinition&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchWorkflowCustomDataTypeDefinition(moid: string, workflowCustomDataTypeDefinition: WorkflowCustomDataTypeDefinition, ifMatch?: string, options?: Configuration): Promise<WorkflowCustomDataTypeDefinition> {
    	const result = this.api.patchWorkflowCustomDataTypeDefinition(moid, workflowCustomDataTypeDefinition, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.TaskDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowTaskDefinition The &#39;workflow.TaskDefinition&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchWorkflowTaskDefinition(moid: string, workflowTaskDefinition: WorkflowTaskDefinition, ifMatch?: string, options?: Configuration): Promise<WorkflowTaskDefinition> {
    	const result = this.api.patchWorkflowTaskDefinition(moid, workflowTaskDefinition, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.TaskInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowTaskInfo The &#39;workflow.TaskInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchWorkflowTaskInfo(moid: string, workflowTaskInfo: WorkflowTaskInfo, ifMatch?: string, options?: Configuration): Promise<WorkflowTaskInfo> {
    	const result = this.api.patchWorkflowTaskInfo(moid, workflowTaskInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.WorkflowDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowWorkflowDefinition The &#39;workflow.WorkflowDefinition&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchWorkflowWorkflowDefinition(moid: string, workflowWorkflowDefinition: WorkflowWorkflowDefinition, ifMatch?: string, options?: Configuration): Promise<WorkflowWorkflowDefinition> {
    	const result = this.api.patchWorkflowWorkflowDefinition(moid, workflowWorkflowDefinition, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.WorkflowInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowWorkflowInfo The &#39;workflow.WorkflowInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public patchWorkflowWorkflowInfo(moid: string, workflowWorkflowInfo: WorkflowWorkflowInfo, ifMatch?: string, options?: Configuration): Promise<WorkflowWorkflowInfo> {
    	const result = this.api.patchWorkflowWorkflowInfo(moid, workflowWorkflowInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.BatchApiExecutor' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowBatchApiExecutor The &#39;workflow.BatchApiExecutor&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateWorkflowBatchApiExecutor(moid: string, workflowBatchApiExecutor: WorkflowBatchApiExecutor, ifMatch?: string, options?: Configuration): Promise<WorkflowBatchApiExecutor> {
    	const result = this.api.updateWorkflowBatchApiExecutor(moid, workflowBatchApiExecutor, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.CustomDataTypeDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowCustomDataTypeDefinition The &#39;workflow.CustomDataTypeDefinition&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateWorkflowCustomDataTypeDefinition(moid: string, workflowCustomDataTypeDefinition: WorkflowCustomDataTypeDefinition, ifMatch?: string, options?: Configuration): Promise<WorkflowCustomDataTypeDefinition> {
    	const result = this.api.updateWorkflowCustomDataTypeDefinition(moid, workflowCustomDataTypeDefinition, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.TaskDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowTaskDefinition The &#39;workflow.TaskDefinition&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateWorkflowTaskDefinition(moid: string, workflowTaskDefinition: WorkflowTaskDefinition, ifMatch?: string, options?: Configuration): Promise<WorkflowTaskDefinition> {
    	const result = this.api.updateWorkflowTaskDefinition(moid, workflowTaskDefinition, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.TaskInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowTaskInfo The &#39;workflow.TaskInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateWorkflowTaskInfo(moid: string, workflowTaskInfo: WorkflowTaskInfo, ifMatch?: string, options?: Configuration): Promise<WorkflowTaskInfo> {
    	const result = this.api.updateWorkflowTaskInfo(moid, workflowTaskInfo, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.WorkflowDefinition' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowWorkflowDefinition The &#39;workflow.WorkflowDefinition&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateWorkflowWorkflowDefinition(moid: string, workflowWorkflowDefinition: WorkflowWorkflowDefinition, ifMatch?: string, options?: Configuration): Promise<WorkflowWorkflowDefinition> {
    	const result = this.api.updateWorkflowWorkflowDefinition(moid, workflowWorkflowDefinition, ifMatch, options);
        return result.toPromise();
    }
	
    /**
     * Update a 'workflow.WorkflowInfo' resource.
     * @param moid The unique Moid identifier of a resource instance.
     * @param workflowWorkflowInfo The &#39;workflow.WorkflowInfo&#39; resource to update.
     * @param ifMatch For methods that apply server-side changes, and in particular for PUT, If-Match can be used to prevent the lost update problem. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the 412 (Precondition Failed) response is returned. When modifying a resource using POST or PUT, the If-Match header must be set to the value of the resource ModTime property after which no lost update problem should occur. For example, a client send a GET request to obtain a resource, which includes the ModTime property. The ModTime indicates the last time the resource was created or modified. The client then sends a POST or PUT request with the If-Match header set to the ModTime property of the resource as obtained in the GET request.
     */
    public updateWorkflowWorkflowInfo(moid: string, workflowWorkflowInfo: WorkflowWorkflowInfo, ifMatch?: string, options?: Configuration): Promise<WorkflowWorkflowInfo> {
    	const result = this.api.updateWorkflowWorkflowInfo(moid, workflowWorkflowInfo, ifMatch, options);
        return result.toPromise();
    }
	

}



